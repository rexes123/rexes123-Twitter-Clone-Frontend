{"version":3,"file":"rtk-query-react.umd.js","sources":["rtk-query-react.umd.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n};\r\nvar __create = Object.create;\r\nvar __defProp = Object.defineProperty;\r\nvar __defProps = Object.defineProperties;\r\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\r\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\r\nvar __getOwnPropNames = Object.getOwnPropertyNames;\r\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\r\nvar __getProtoOf = Object.getPrototypeOf;\r\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp = function (obj, key, value) { return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value }) : obj[key] = value; };\r\nvar __spreadValues = function (a2, b2) {\r\n    for (var prop in b2 || (b2 = {}))\r\n        if (__hasOwnProp.call(b2, prop))\r\n            __defNormalProp(a2, prop, b2[prop]);\r\n    if (__getOwnPropSymbols)\r\n        for (var _j = 0, _k = __getOwnPropSymbols(b2); _j < _k.length; _j++) {\r\n            var prop = _k[_j];\r\n            if (__propIsEnum.call(b2, prop))\r\n                __defNormalProp(a2, prop, b2[prop]);\r\n        }\r\n    return a2;\r\n};\r\nvar __spreadProps = function (a2, b2) { return __defProps(a2, __getOwnPropDescs(b2)); };\r\nvar __markAsModule = function (target) { return __defProp(target, \"__esModule\", { value: true }); };\r\nvar __objRest = function (source, exclude) {\r\n    var target = {};\r\n    for (var prop in source)\r\n        if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\r\n            target[prop] = source[prop];\r\n    if (source != null && __getOwnPropSymbols)\r\n        for (var _j = 0, _k = __getOwnPropSymbols(source); _j < _k.length; _j++) {\r\n            var prop = _k[_j];\r\n            if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\r\n                target[prop] = source[prop];\r\n        }\r\n    return target;\r\n};\r\nvar __commonJS = function (cb, mod) { return function __require() {\r\n    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\r\n}; };\r\nvar __reExport = function (target, module, desc) {\r\n    if (module && typeof module === \"object\" || typeof module === \"function\") {\r\n        var _loop_1 = function (key) {\r\n            if (!__hasOwnProp.call(target, key) && key !== \"default\")\r\n                __defProp(target, key, { get: function () { return module[key]; }, enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });\r\n        };\r\n        for (var _j = 0, _k = __getOwnPropNames(module); _j < _k.length; _j++) {\r\n            var key = _k[_j];\r\n            _loop_1(key);\r\n        }\r\n    }\r\n    return target;\r\n};\r\nvar __toModule = function (module) {\r\n    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", module && module.__esModule && \"default\" in module ? { get: function () { return module.default; }, enumerable: true } : { value: module, enumerable: true })), module);\r\n};\r\nvar __async = function (__this, __arguments, generator) {\r\n    return new Promise(function (resolve, reject) {\r\n        var fulfilled = function (value) {\r\n            try {\r\n                step(generator.next(value));\r\n            }\r\n            catch (e2) {\r\n                reject(e2);\r\n            }\r\n        };\r\n        var rejected = function (value) {\r\n            try {\r\n                step(generator.throw(value));\r\n            }\r\n            catch (e2) {\r\n                reject(e2);\r\n            }\r\n        };\r\n        var step = function (x2) { return x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected); };\r\n        step((generator = generator.apply(__this, __arguments)).next());\r\n    });\r\n};\r\n// ../../node_modules/react/cjs/react.development.js\r\nvar require_react_development = __commonJS({\r\n    \"../../node_modules/react/cjs/react.development.js\": function (exports, module) {\r\n        \"use strict\";\r\n        if (true) {\r\n            (function () {\r\n                \"use strict\";\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n                }\r\n                var ReactVersion = \"18.1.0\";\r\n                var enableScopeAPI = false;\r\n                var enableCacheElement = false;\r\n                var enableTransitionTracing = false;\r\n                var enableLegacyHidden = false;\r\n                var enableDebugTracing = false;\r\n                var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\r\n                var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\r\n                var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\r\n                var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\r\n                var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\r\n                var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\r\n                var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\r\n                var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\r\n                var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\r\n                var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\r\n                var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\r\n                var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\r\n                var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\r\n                var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\r\n                var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\r\n                function getIteratorFn(maybeIterable) {\r\n                    if (maybeIterable === null || typeof maybeIterable !== \"object\") {\r\n                        return null;\r\n                    }\r\n                    var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n                    if (typeof maybeIterator === \"function\") {\r\n                        return maybeIterator;\r\n                    }\r\n                    return null;\r\n                }\r\n                var ReactCurrentDispatcher = {\r\n                    current: null\r\n                };\r\n                var ReactCurrentBatchConfig = {\r\n                    transition: null\r\n                };\r\n                var ReactCurrentActQueue = {\r\n                    current: null,\r\n                    isBatchingLegacy: false,\r\n                    didScheduleLegacyUpdate: false\r\n                };\r\n                var ReactCurrentOwner = {\r\n                    current: null\r\n                };\r\n                var ReactDebugCurrentFrame = {};\r\n                var currentExtraStackFrame = null;\r\n                function setExtraStackFrame(stack) {\r\n                    {\r\n                        currentExtraStackFrame = stack;\r\n                    }\r\n                }\r\n                {\r\n                    ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\r\n                        {\r\n                            currentExtraStackFrame = stack;\r\n                        }\r\n                    };\r\n                    ReactDebugCurrentFrame.getCurrentStack = null;\r\n                    ReactDebugCurrentFrame.getStackAddendum = function () {\r\n                        var stack = \"\";\r\n                        if (currentExtraStackFrame) {\r\n                            stack += currentExtraStackFrame;\r\n                        }\r\n                        var impl = ReactDebugCurrentFrame.getCurrentStack;\r\n                        if (impl) {\r\n                            stack += impl() || \"\";\r\n                        }\r\n                        return stack;\r\n                    };\r\n                }\r\n                var ReactSharedInternals = {\r\n                    ReactCurrentDispatcher: ReactCurrentDispatcher,\r\n                    ReactCurrentBatchConfig: ReactCurrentBatchConfig,\r\n                    ReactCurrentOwner: ReactCurrentOwner\r\n                };\r\n                {\r\n                    ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\r\n                    ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\r\n                }\r\n                function warn(format) {\r\n                    {\r\n                        {\r\n                            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n                                args[_key - 1] = arguments[_key];\r\n                            }\r\n                            printWarning(\"warn\", format, args);\r\n                        }\r\n                    }\r\n                }\r\n                function error(format) {\r\n                    {\r\n                        {\r\n                            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n                                args[_key2 - 1] = arguments[_key2];\r\n                            }\r\n                            printWarning(\"error\", format, args);\r\n                        }\r\n                    }\r\n                }\r\n                function printWarning(level, format, args) {\r\n                    {\r\n                        var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n                        var stack = ReactDebugCurrentFrame2.getStackAddendum();\r\n                        if (stack !== \"\") {\r\n                            format += \"%s\";\r\n                            args = args.concat([stack]);\r\n                        }\r\n                        var argsWithFormat = args.map(function (item) {\r\n                            return String(item);\r\n                        });\r\n                        argsWithFormat.unshift(\"Warning: \" + format);\r\n                        Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n                    }\r\n                }\r\n                var didWarnStateUpdateForUnmountedComponent = {};\r\n                function warnNoop(publicInstance, callerName) {\r\n                    {\r\n                        var _constructor = publicInstance.constructor;\r\n                        var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\r\n                        var warningKey = componentName + \".\" + callerName;\r\n                        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\r\n                            return;\r\n                        }\r\n                        error(\"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\", callerName, componentName);\r\n                        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\r\n                    }\r\n                }\r\n                var ReactNoopUpdateQueue = {\r\n                    isMounted: function (publicInstance) {\r\n                        return false;\r\n                    },\r\n                    enqueueForceUpdate: function (publicInstance, callback, callerName) {\r\n                        warnNoop(publicInstance, \"forceUpdate\");\r\n                    },\r\n                    enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\r\n                        warnNoop(publicInstance, \"replaceState\");\r\n                    },\r\n                    enqueueSetState: function (publicInstance, partialState, callback, callerName) {\r\n                        warnNoop(publicInstance, \"setState\");\r\n                    }\r\n                };\r\n                var assign = Object.assign;\r\n                var emptyObject = {};\r\n                {\r\n                    Object.freeze(emptyObject);\r\n                }\r\n                function Component(props, context, updater) {\r\n                    this.props = props;\r\n                    this.context = context;\r\n                    this.refs = emptyObject;\r\n                    this.updater = updater || ReactNoopUpdateQueue;\r\n                }\r\n                Component.prototype.isReactComponent = {};\r\n                Component.prototype.setState = function (partialState, callback) {\r\n                    if (typeof partialState !== \"object\" && typeof partialState !== \"function\" && partialState != null) {\r\n                        throw new Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\r\n                    }\r\n                    this.updater.enqueueSetState(this, partialState, callback, \"setState\");\r\n                };\r\n                Component.prototype.forceUpdate = function (callback) {\r\n                    this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\r\n                };\r\n                {\r\n                    var deprecatedAPIs = {\r\n                        isMounted: [\"isMounted\", \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"],\r\n                        replaceState: [\"replaceState\", \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"]\r\n                    };\r\n                    var defineDeprecationWarning = function (methodName, info) {\r\n                        Object.defineProperty(Component.prototype, methodName, {\r\n                            get: function () {\r\n                                warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\r\n                                return void 0;\r\n                            }\r\n                        });\r\n                    };\r\n                    for (var fnName in deprecatedAPIs) {\r\n                        if (deprecatedAPIs.hasOwnProperty(fnName)) {\r\n                            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\r\n                        }\r\n                    }\r\n                }\r\n                function ComponentDummy() {\r\n                }\r\n                ComponentDummy.prototype = Component.prototype;\r\n                function PureComponent(props, context, updater) {\r\n                    this.props = props;\r\n                    this.context = context;\r\n                    this.refs = emptyObject;\r\n                    this.updater = updater || ReactNoopUpdateQueue;\r\n                }\r\n                var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\r\n                pureComponentPrototype.constructor = PureComponent;\r\n                assign(pureComponentPrototype, Component.prototype);\r\n                pureComponentPrototype.isPureReactComponent = true;\r\n                function createRef() {\r\n                    var refObject = {\r\n                        current: null\r\n                    };\r\n                    {\r\n                        Object.seal(refObject);\r\n                    }\r\n                    return refObject;\r\n                }\r\n                var isArrayImpl = Array.isArray;\r\n                function isArray(a2) {\r\n                    return isArrayImpl(a2);\r\n                }\r\n                function typeName(value) {\r\n                    {\r\n                        var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\r\n                        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\r\n                        return type;\r\n                    }\r\n                }\r\n                function willCoercionThrow(value) {\r\n                    {\r\n                        try {\r\n                            testStringCoercion(value);\r\n                            return false;\r\n                        }\r\n                        catch (e2) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                function testStringCoercion(value) {\r\n                    return \"\" + value;\r\n                }\r\n                function checkKeyStringCoercion(value) {\r\n                    {\r\n                        if (willCoercionThrow(value)) {\r\n                            error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\r\n                            return testStringCoercion(value);\r\n                        }\r\n                    }\r\n                }\r\n                function getWrappedName(outerType, innerType, wrapperName) {\r\n                    var displayName = outerType.displayName;\r\n                    if (displayName) {\r\n                        return displayName;\r\n                    }\r\n                    var functionName = innerType.displayName || innerType.name || \"\";\r\n                    return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\r\n                }\r\n                function getContextName(type) {\r\n                    return type.displayName || \"Context\";\r\n                }\r\n                function getComponentNameFromType(type) {\r\n                    if (type == null) {\r\n                        return null;\r\n                    }\r\n                    {\r\n                        if (typeof type.tag === \"number\") {\r\n                            error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n                    if (typeof type === \"function\") {\r\n                        return type.displayName || type.name || null;\r\n                    }\r\n                    if (typeof type === \"string\") {\r\n                        return type;\r\n                    }\r\n                    switch (type) {\r\n                        case REACT_FRAGMENT_TYPE:\r\n                            return \"Fragment\";\r\n                        case REACT_PORTAL_TYPE:\r\n                            return \"Portal\";\r\n                        case REACT_PROFILER_TYPE:\r\n                            return \"Profiler\";\r\n                        case REACT_STRICT_MODE_TYPE:\r\n                            return \"StrictMode\";\r\n                        case REACT_SUSPENSE_TYPE:\r\n                            return \"Suspense\";\r\n                        case REACT_SUSPENSE_LIST_TYPE:\r\n                            return \"SuspenseList\";\r\n                    }\r\n                    if (typeof type === \"object\") {\r\n                        switch (type.$$typeof) {\r\n                            case REACT_CONTEXT_TYPE:\r\n                                var context = type;\r\n                                return getContextName(context) + \".Consumer\";\r\n                            case REACT_PROVIDER_TYPE:\r\n                                var provider = type;\r\n                                return getContextName(provider._context) + \".Provider\";\r\n                            case REACT_FORWARD_REF_TYPE:\r\n                                return getWrappedName(type, type.render, \"ForwardRef\");\r\n                            case REACT_MEMO_TYPE:\r\n                                var outerName = type.displayName || null;\r\n                                if (outerName !== null) {\r\n                                    return outerName;\r\n                                }\r\n                                return getComponentNameFromType(type.type) || \"Memo\";\r\n                            case REACT_LAZY_TYPE: {\r\n                                var lazyComponent = type;\r\n                                var payload = lazyComponent._payload;\r\n                                var init = lazyComponent._init;\r\n                                try {\r\n                                    return getComponentNameFromType(init(payload));\r\n                                }\r\n                                catch (x2) {\r\n                                    return null;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n                var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n                var RESERVED_PROPS = {\r\n                    key: true,\r\n                    ref: true,\r\n                    __self: true,\r\n                    __source: true\r\n                };\r\n                var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\r\n                {\r\n                    didWarnAboutStringRefs = {};\r\n                }\r\n                function hasValidRef(config) {\r\n                    {\r\n                        if (hasOwnProperty.call(config, \"ref\")) {\r\n                            var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\r\n                            if (getter && getter.isReactWarning) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                    return config.ref !== void 0;\r\n                }\r\n                function hasValidKey(config) {\r\n                    {\r\n                        if (hasOwnProperty.call(config, \"key\")) {\r\n                            var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\r\n                            if (getter && getter.isReactWarning) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                    return config.key !== void 0;\r\n                }\r\n                function defineKeyPropWarningGetter(props, displayName) {\r\n                    var warnAboutAccessingKey = function () {\r\n                        {\r\n                            if (!specialPropKeyWarningShown) {\r\n                                specialPropKeyWarningShown = true;\r\n                                error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\r\n                            }\r\n                        }\r\n                    };\r\n                    warnAboutAccessingKey.isReactWarning = true;\r\n                    Object.defineProperty(props, \"key\", {\r\n                        get: warnAboutAccessingKey,\r\n                        configurable: true\r\n                    });\r\n                }\r\n                function defineRefPropWarningGetter(props, displayName) {\r\n                    var warnAboutAccessingRef = function () {\r\n                        {\r\n                            if (!specialPropRefWarningShown) {\r\n                                specialPropRefWarningShown = true;\r\n                                error(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\r\n                            }\r\n                        }\r\n                    };\r\n                    warnAboutAccessingRef.isReactWarning = true;\r\n                    Object.defineProperty(props, \"ref\", {\r\n                        get: warnAboutAccessingRef,\r\n                        configurable: true\r\n                    });\r\n                }\r\n                function warnIfStringRefCannotBeAutoConverted(config) {\r\n                    {\r\n                        if (typeof config.ref === \"string\" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\r\n                            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\r\n                            if (!didWarnAboutStringRefs[componentName]) {\r\n                                error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\r\n                                didWarnAboutStringRefs[componentName] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var ReactElement = function (type, key, ref, self, source, owner, props) {\r\n                    var element = {\r\n                        $$typeof: REACT_ELEMENT_TYPE,\r\n                        type: type,\r\n                        key: key,\r\n                        ref: ref,\r\n                        props: props,\r\n                        _owner: owner\r\n                    };\r\n                    {\r\n                        element._store = {};\r\n                        Object.defineProperty(element._store, \"validated\", {\r\n                            configurable: false,\r\n                            enumerable: false,\r\n                            writable: true,\r\n                            value: false\r\n                        });\r\n                        Object.defineProperty(element, \"_self\", {\r\n                            configurable: false,\r\n                            enumerable: false,\r\n                            writable: false,\r\n                            value: self\r\n                        });\r\n                        Object.defineProperty(element, \"_source\", {\r\n                            configurable: false,\r\n                            enumerable: false,\r\n                            writable: false,\r\n                            value: source\r\n                        });\r\n                        if (Object.freeze) {\r\n                            Object.freeze(element.props);\r\n                            Object.freeze(element);\r\n                        }\r\n                    }\r\n                    return element;\r\n                };\r\n                function createElement(type, config, children) {\r\n                    var propName;\r\n                    var props = {};\r\n                    var key = null;\r\n                    var ref = null;\r\n                    var self = null;\r\n                    var source = null;\r\n                    if (config != null) {\r\n                        if (hasValidRef(config)) {\r\n                            ref = config.ref;\r\n                            {\r\n                                warnIfStringRefCannotBeAutoConverted(config);\r\n                            }\r\n                        }\r\n                        if (hasValidKey(config)) {\r\n                            {\r\n                                checkKeyStringCoercion(config.key);\r\n                            }\r\n                            key = \"\" + config.key;\r\n                        }\r\n                        self = config.__self === void 0 ? null : config.__self;\r\n                        source = config.__source === void 0 ? null : config.__source;\r\n                        for (propName in config) {\r\n                            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n                                props[propName] = config[propName];\r\n                            }\r\n                        }\r\n                    }\r\n                    var childrenLength = arguments.length - 2;\r\n                    if (childrenLength === 1) {\r\n                        props.children = children;\r\n                    }\r\n                    else if (childrenLength > 1) {\r\n                        var childArray = Array(childrenLength);\r\n                        for (var i2 = 0; i2 < childrenLength; i2++) {\r\n                            childArray[i2] = arguments[i2 + 2];\r\n                        }\r\n                        {\r\n                            if (Object.freeze) {\r\n                                Object.freeze(childArray);\r\n                            }\r\n                        }\r\n                        props.children = childArray;\r\n                    }\r\n                    if (type && type.defaultProps) {\r\n                        var defaultProps = type.defaultProps;\r\n                        for (propName in defaultProps) {\r\n                            if (props[propName] === void 0) {\r\n                                props[propName] = defaultProps[propName];\r\n                            }\r\n                        }\r\n                    }\r\n                    {\r\n                        if (key || ref) {\r\n                            var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\r\n                            if (key) {\r\n                                defineKeyPropWarningGetter(props, displayName);\r\n                            }\r\n                            if (ref) {\r\n                                defineRefPropWarningGetter(props, displayName);\r\n                            }\r\n                        }\r\n                    }\r\n                    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\r\n                }\r\n                function cloneAndReplaceKey(oldElement, newKey) {\r\n                    var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\r\n                    return newElement;\r\n                }\r\n                function cloneElement(element, config, children) {\r\n                    if (element === null || element === void 0) {\r\n                        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\r\n                    }\r\n                    var propName;\r\n                    var props = assign({}, element.props);\r\n                    var key = element.key;\r\n                    var ref = element.ref;\r\n                    var self = element._self;\r\n                    var source = element._source;\r\n                    var owner = element._owner;\r\n                    if (config != null) {\r\n                        if (hasValidRef(config)) {\r\n                            ref = config.ref;\r\n                            owner = ReactCurrentOwner.current;\r\n                        }\r\n                        if (hasValidKey(config)) {\r\n                            {\r\n                                checkKeyStringCoercion(config.key);\r\n                            }\r\n                            key = \"\" + config.key;\r\n                        }\r\n                        var defaultProps;\r\n                        if (element.type && element.type.defaultProps) {\r\n                            defaultProps = element.type.defaultProps;\r\n                        }\r\n                        for (propName in config) {\r\n                            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\r\n                                if (config[propName] === void 0 && defaultProps !== void 0) {\r\n                                    props[propName] = defaultProps[propName];\r\n                                }\r\n                                else {\r\n                                    props[propName] = config[propName];\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    var childrenLength = arguments.length - 2;\r\n                    if (childrenLength === 1) {\r\n                        props.children = children;\r\n                    }\r\n                    else if (childrenLength > 1) {\r\n                        var childArray = Array(childrenLength);\r\n                        for (var i2 = 0; i2 < childrenLength; i2++) {\r\n                            childArray[i2] = arguments[i2 + 2];\r\n                        }\r\n                        props.children = childArray;\r\n                    }\r\n                    return ReactElement(element.type, key, ref, self, source, owner, props);\r\n                }\r\n                function isValidElement(object) {\r\n                    return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\r\n                }\r\n                var SEPARATOR = \".\";\r\n                var SUBSEPARATOR = \":\";\r\n                function escape(key) {\r\n                    var escapeRegex = /[=:]/g;\r\n                    var escaperLookup = {\r\n                        \"=\": \"=0\",\r\n                        \":\": \"=2\"\r\n                    };\r\n                    var escapedString = key.replace(escapeRegex, function (match) {\r\n                        return escaperLookup[match];\r\n                    });\r\n                    return \"$\" + escapedString;\r\n                }\r\n                var didWarnAboutMaps = false;\r\n                var userProvidedKeyEscapeRegex = /\\/+/g;\r\n                function escapeUserProvidedKey(text) {\r\n                    return text.replace(userProvidedKeyEscapeRegex, \"$&/\");\r\n                }\r\n                function getElementKey(element, index) {\r\n                    if (typeof element === \"object\" && element !== null && element.key != null) {\r\n                        {\r\n                            checkKeyStringCoercion(element.key);\r\n                        }\r\n                        return escape(\"\" + element.key);\r\n                    }\r\n                    return index.toString(36);\r\n                }\r\n                function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\r\n                    var type = typeof children;\r\n                    if (type === \"undefined\" || type === \"boolean\") {\r\n                        children = null;\r\n                    }\r\n                    var invokeCallback = false;\r\n                    if (children === null) {\r\n                        invokeCallback = true;\r\n                    }\r\n                    else {\r\n                        switch (type) {\r\n                            case \"string\":\r\n                            case \"number\":\r\n                                invokeCallback = true;\r\n                                break;\r\n                            case \"object\":\r\n                                switch (children.$$typeof) {\r\n                                    case REACT_ELEMENT_TYPE:\r\n                                    case REACT_PORTAL_TYPE:\r\n                                        invokeCallback = true;\r\n                                }\r\n                        }\r\n                    }\r\n                    if (invokeCallback) {\r\n                        var _child = children;\r\n                        var mappedChild = callback(_child);\r\n                        var childKey = nameSoFar === \"\" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\r\n                        if (isArray(mappedChild)) {\r\n                            var escapedChildKey = \"\";\r\n                            if (childKey != null) {\r\n                                escapedChildKey = escapeUserProvidedKey(childKey) + \"/\";\r\n                            }\r\n                            mapIntoArray(mappedChild, array, escapedChildKey, \"\", function (c2) {\r\n                                return c2;\r\n                            });\r\n                        }\r\n                        else if (mappedChild != null) {\r\n                            if (isValidElement(mappedChild)) {\r\n                                {\r\n                                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\r\n                                        checkKeyStringCoercion(mappedChild.key);\r\n                                    }\r\n                                }\r\n                                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey(\"\" + mappedChild.key) + \"/\" : \"\") + childKey);\r\n                            }\r\n                            array.push(mappedChild);\r\n                        }\r\n                        return 1;\r\n                    }\r\n                    var child;\r\n                    var nextName;\r\n                    var subtreeCount = 0;\r\n                    var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\r\n                    if (isArray(children)) {\r\n                        for (var i2 = 0; i2 < children.length; i2++) {\r\n                            child = children[i2];\r\n                            nextName = nextNamePrefix + getElementKey(child, i2);\r\n                            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var iteratorFn = getIteratorFn(children);\r\n                        if (typeof iteratorFn === \"function\") {\r\n                            var iterableChildren = children;\r\n                            {\r\n                                if (iteratorFn === iterableChildren.entries) {\r\n                                    if (!didWarnAboutMaps) {\r\n                                        warn(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\");\r\n                                    }\r\n                                    didWarnAboutMaps = true;\r\n                                }\r\n                            }\r\n                            var iterator = iteratorFn.call(iterableChildren);\r\n                            var step;\r\n                            var ii = 0;\r\n                            while (!(step = iterator.next()).done) {\r\n                                child = step.value;\r\n                                nextName = nextNamePrefix + getElementKey(child, ii++);\r\n                                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\r\n                            }\r\n                        }\r\n                        else if (type === \"object\") {\r\n                            var childrenString = String(children);\r\n                            throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString) + \"). If you meant to render a collection of children, use an array instead.\");\r\n                        }\r\n                    }\r\n                    return subtreeCount;\r\n                }\r\n                function mapChildren(children, func, context) {\r\n                    if (children == null) {\r\n                        return children;\r\n                    }\r\n                    var result = [];\r\n                    var count = 0;\r\n                    mapIntoArray(children, result, \"\", \"\", function (child) {\r\n                        return func.call(context, child, count++);\r\n                    });\r\n                    return result;\r\n                }\r\n                function countChildren(children) {\r\n                    var n2 = 0;\r\n                    mapChildren(children, function () {\r\n                        n2++;\r\n                    });\r\n                    return n2;\r\n                }\r\n                function forEachChildren(children, forEachFunc, forEachContext) {\r\n                    mapChildren(children, function () {\r\n                        forEachFunc.apply(this, arguments);\r\n                    }, forEachContext);\r\n                }\r\n                function toArray(children) {\r\n                    return mapChildren(children, function (child) {\r\n                        return child;\r\n                    }) || [];\r\n                }\r\n                function onlyChild(children) {\r\n                    if (!isValidElement(children)) {\r\n                        throw new Error(\"React.Children.only expected to receive a single React element child.\");\r\n                    }\r\n                    return children;\r\n                }\r\n                function createContext(defaultValue) {\r\n                    var context = {\r\n                        $$typeof: REACT_CONTEXT_TYPE,\r\n                        _currentValue: defaultValue,\r\n                        _currentValue2: defaultValue,\r\n                        _threadCount: 0,\r\n                        Provider: null,\r\n                        Consumer: null,\r\n                        _defaultValue: null,\r\n                        _globalName: null\r\n                    };\r\n                    context.Provider = {\r\n                        $$typeof: REACT_PROVIDER_TYPE,\r\n                        _context: context\r\n                    };\r\n                    var hasWarnedAboutUsingNestedContextConsumers = false;\r\n                    var hasWarnedAboutUsingConsumerProvider = false;\r\n                    var hasWarnedAboutDisplayNameOnConsumer = false;\r\n                    {\r\n                        var Consumer = {\r\n                            $$typeof: REACT_CONTEXT_TYPE,\r\n                            _context: context\r\n                        };\r\n                        Object.defineProperties(Consumer, {\r\n                            Provider: {\r\n                                get: function () {\r\n                                    if (!hasWarnedAboutUsingConsumerProvider) {\r\n                                        hasWarnedAboutUsingConsumerProvider = true;\r\n                                        error(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?\");\r\n                                    }\r\n                                    return context.Provider;\r\n                                },\r\n                                set: function (_Provider) {\r\n                                    context.Provider = _Provider;\r\n                                }\r\n                            },\r\n                            _currentValue: {\r\n                                get: function () {\r\n                                    return context._currentValue;\r\n                                },\r\n                                set: function (_currentValue) {\r\n                                    context._currentValue = _currentValue;\r\n                                }\r\n                            },\r\n                            _currentValue2: {\r\n                                get: function () {\r\n                                    return context._currentValue2;\r\n                                },\r\n                                set: function (_currentValue2) {\r\n                                    context._currentValue2 = _currentValue2;\r\n                                }\r\n                            },\r\n                            _threadCount: {\r\n                                get: function () {\r\n                                    return context._threadCount;\r\n                                },\r\n                                set: function (_threadCount) {\r\n                                    context._threadCount = _threadCount;\r\n                                }\r\n                            },\r\n                            Consumer: {\r\n                                get: function () {\r\n                                    if (!hasWarnedAboutUsingNestedContextConsumers) {\r\n                                        hasWarnedAboutUsingNestedContextConsumers = true;\r\n                                        error(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?\");\r\n                                    }\r\n                                    return context.Consumer;\r\n                                }\r\n                            },\r\n                            displayName: {\r\n                                get: function () {\r\n                                    return context.displayName;\r\n                                },\r\n                                set: function (displayName) {\r\n                                    if (!hasWarnedAboutDisplayNameOnConsumer) {\r\n                                        warn(\"Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.\", displayName);\r\n                                        hasWarnedAboutDisplayNameOnConsumer = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                        context.Consumer = Consumer;\r\n                    }\r\n                    {\r\n                        context._currentRenderer = null;\r\n                        context._currentRenderer2 = null;\r\n                    }\r\n                    return context;\r\n                }\r\n                var Uninitialized = -1;\r\n                var Pending = 0;\r\n                var Resolved = 1;\r\n                var Rejected = 2;\r\n                function lazyInitializer(payload) {\r\n                    if (payload._status === Uninitialized) {\r\n                        var ctor = payload._result;\r\n                        var thenable = ctor();\r\n                        thenable.then(function (moduleObject2) {\r\n                            if (payload._status === Pending || payload._status === Uninitialized) {\r\n                                var resolved = payload;\r\n                                resolved._status = Resolved;\r\n                                resolved._result = moduleObject2;\r\n                            }\r\n                        }, function (error2) {\r\n                            if (payload._status === Pending || payload._status === Uninitialized) {\r\n                                var rejected = payload;\r\n                                rejected._status = Rejected;\r\n                                rejected._result = error2;\r\n                            }\r\n                        });\r\n                        if (payload._status === Uninitialized) {\r\n                            var pending = payload;\r\n                            pending._status = Pending;\r\n                            pending._result = thenable;\r\n                        }\r\n                    }\r\n                    if (payload._status === Resolved) {\r\n                        var moduleObject = payload._result;\r\n                        {\r\n                            if (moduleObject === void 0) {\r\n                                error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\", moduleObject);\r\n                            }\r\n                        }\r\n                        {\r\n                            if (!(\"default\" in moduleObject)) {\r\n                                error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\", moduleObject);\r\n                            }\r\n                        }\r\n                        return moduleObject.default;\r\n                    }\r\n                    else {\r\n                        throw payload._result;\r\n                    }\r\n                }\r\n                function lazy(ctor) {\r\n                    var payload = {\r\n                        _status: Uninitialized,\r\n                        _result: ctor\r\n                    };\r\n                    var lazyType = {\r\n                        $$typeof: REACT_LAZY_TYPE,\r\n                        _payload: payload,\r\n                        _init: lazyInitializer\r\n                    };\r\n                    {\r\n                        var defaultProps;\r\n                        var propTypes;\r\n                        Object.defineProperties(lazyType, {\r\n                            defaultProps: {\r\n                                configurable: true,\r\n                                get: function () {\r\n                                    return defaultProps;\r\n                                },\r\n                                set: function (newDefaultProps) {\r\n                                    error(\"React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\");\r\n                                    defaultProps = newDefaultProps;\r\n                                    Object.defineProperty(lazyType, \"defaultProps\", {\r\n                                        enumerable: true\r\n                                    });\r\n                                }\r\n                            },\r\n                            propTypes: {\r\n                                configurable: true,\r\n                                get: function () {\r\n                                    return propTypes;\r\n                                },\r\n                                set: function (newPropTypes) {\r\n                                    error(\"React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\");\r\n                                    propTypes = newPropTypes;\r\n                                    Object.defineProperty(lazyType, \"propTypes\", {\r\n                                        enumerable: true\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    return lazyType;\r\n                }\r\n                function forwardRef(render) {\r\n                    {\r\n                        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\r\n                            error(\"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\");\r\n                        }\r\n                        else if (typeof render !== \"function\") {\r\n                            error(\"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render);\r\n                        }\r\n                        else {\r\n                            if (render.length !== 0 && render.length !== 2) {\r\n                                error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", render.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\r\n                            }\r\n                        }\r\n                        if (render != null) {\r\n                            if (render.defaultProps != null || render.propTypes != null) {\r\n                                error(\"forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?\");\r\n                            }\r\n                        }\r\n                    }\r\n                    var elementType = {\r\n                        $$typeof: REACT_FORWARD_REF_TYPE,\r\n                        render: render\r\n                    };\r\n                    {\r\n                        var ownName;\r\n                        Object.defineProperty(elementType, \"displayName\", {\r\n                            enumerable: false,\r\n                            configurable: true,\r\n                            get: function () {\r\n                                return ownName;\r\n                            },\r\n                            set: function (name) {\r\n                                ownName = name;\r\n                                if (!render.name && !render.displayName) {\r\n                                    render.displayName = name;\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    return elementType;\r\n                }\r\n                var REACT_MODULE_REFERENCE;\r\n                {\r\n                    REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\r\n                }\r\n                function isValidElementType2(type) {\r\n                    if (typeof type === \"string\" || typeof type === \"function\") {\r\n                        return true;\r\n                    }\r\n                    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\r\n                        return true;\r\n                    }\r\n                    if (typeof type === \"object\" && type !== null) {\r\n                        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n                function memo(type, compare) {\r\n                    {\r\n                        if (!isValidElementType2(type)) {\r\n                            error(\"memo: The first argument must be a component. Instead received: %s\", type === null ? \"null\" : typeof type);\r\n                        }\r\n                    }\r\n                    var elementType = {\r\n                        $$typeof: REACT_MEMO_TYPE,\r\n                        type: type,\r\n                        compare: compare === void 0 ? null : compare\r\n                    };\r\n                    {\r\n                        var ownName;\r\n                        Object.defineProperty(elementType, \"displayName\", {\r\n                            enumerable: false,\r\n                            configurable: true,\r\n                            get: function () {\r\n                                return ownName;\r\n                            },\r\n                            set: function (name) {\r\n                                ownName = name;\r\n                                if (!type.name && !type.displayName) {\r\n                                    type.displayName = name;\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    return elementType;\r\n                }\r\n                function resolveDispatcher() {\r\n                    var dispatcher = ReactCurrentDispatcher.current;\r\n                    {\r\n                        if (dispatcher === null) {\r\n                            error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\r\n                        }\r\n                    }\r\n                    return dispatcher;\r\n                }\r\n                function useContext5(Context) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    {\r\n                        if (Context._context !== void 0) {\r\n                            var realContext = Context._context;\r\n                            if (realContext.Consumer === Context) {\r\n                                error(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?\");\r\n                            }\r\n                            else if (realContext.Provider === Context) {\r\n                                error(\"Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?\");\r\n                            }\r\n                        }\r\n                    }\r\n                    return dispatcher.useContext(Context);\r\n                }\r\n                function useState2(initialState2) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useState(initialState2);\r\n                }\r\n                function useReducer(reducer, initialArg, init) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useReducer(reducer, initialArg, init);\r\n                }\r\n                function useRef5(initialValue) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useRef(initialValue);\r\n                }\r\n                function useEffect6(create, deps) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useEffect(create, deps);\r\n                }\r\n                function useInsertionEffect(create, deps) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useInsertionEffect(create, deps);\r\n                }\r\n                function useLayoutEffect3(create, deps) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useLayoutEffect(create, deps);\r\n                }\r\n                function useCallback2(callback, deps) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useCallback(callback, deps);\r\n                }\r\n                function useMemo5(create, deps) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useMemo(create, deps);\r\n                }\r\n                function useImperativeHandle(ref, create, deps) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useImperativeHandle(ref, create, deps);\r\n                }\r\n                function useDebugValue3(value, formatterFn) {\r\n                    {\r\n                        var dispatcher = resolveDispatcher();\r\n                        return dispatcher.useDebugValue(value, formatterFn);\r\n                    }\r\n                }\r\n                function useTransition() {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useTransition();\r\n                }\r\n                function useDeferredValue(value) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useDeferredValue(value);\r\n                }\r\n                function useId() {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useId();\r\n                }\r\n                function useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot) {\r\n                    var dispatcher = resolveDispatcher();\r\n                    return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\r\n                }\r\n                var disabledDepth = 0;\r\n                var prevLog;\r\n                var prevInfo;\r\n                var prevWarn;\r\n                var prevError;\r\n                var prevGroup;\r\n                var prevGroupCollapsed;\r\n                var prevGroupEnd;\r\n                function disabledLog() {\r\n                }\r\n                disabledLog.__reactDisabledLog = true;\r\n                function disableLogs() {\r\n                    {\r\n                        if (disabledDepth === 0) {\r\n                            prevLog = console.log;\r\n                            prevInfo = console.info;\r\n                            prevWarn = console.warn;\r\n                            prevError = console.error;\r\n                            prevGroup = console.group;\r\n                            prevGroupCollapsed = console.groupCollapsed;\r\n                            prevGroupEnd = console.groupEnd;\r\n                            var props = {\r\n                                configurable: true,\r\n                                enumerable: true,\r\n                                value: disabledLog,\r\n                                writable: true\r\n                            };\r\n                            Object.defineProperties(console, {\r\n                                info: props,\r\n                                log: props,\r\n                                warn: props,\r\n                                error: props,\r\n                                group: props,\r\n                                groupCollapsed: props,\r\n                                groupEnd: props\r\n                            });\r\n                        }\r\n                        disabledDepth++;\r\n                    }\r\n                }\r\n                function reenableLogs() {\r\n                    {\r\n                        disabledDepth--;\r\n                        if (disabledDepth === 0) {\r\n                            var props = {\r\n                                configurable: true,\r\n                                enumerable: true,\r\n                                writable: true\r\n                            };\r\n                            Object.defineProperties(console, {\r\n                                log: assign({}, props, {\r\n                                    value: prevLog\r\n                                }),\r\n                                info: assign({}, props, {\r\n                                    value: prevInfo\r\n                                }),\r\n                                warn: assign({}, props, {\r\n                                    value: prevWarn\r\n                                }),\r\n                                error: assign({}, props, {\r\n                                    value: prevError\r\n                                }),\r\n                                group: assign({}, props, {\r\n                                    value: prevGroup\r\n                                }),\r\n                                groupCollapsed: assign({}, props, {\r\n                                    value: prevGroupCollapsed\r\n                                }),\r\n                                groupEnd: assign({}, props, {\r\n                                    value: prevGroupEnd\r\n                                })\r\n                            });\r\n                        }\r\n                        if (disabledDepth < 0) {\r\n                            error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n                }\r\n                var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\r\n                var prefix2;\r\n                function describeBuiltInComponentFrame(name, source, ownerFn) {\r\n                    {\r\n                        if (prefix2 === void 0) {\r\n                            try {\r\n                                throw Error();\r\n                            }\r\n                            catch (x2) {\r\n                                var match = x2.stack.trim().match(/\\n( *(at )?)/);\r\n                                prefix2 = match && match[1] || \"\";\r\n                            }\r\n                        }\r\n                        return \"\\n\" + prefix2 + name;\r\n                    }\r\n                }\r\n                var reentry = false;\r\n                var componentFrameCache;\r\n                {\r\n                    var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\r\n                    componentFrameCache = new PossiblyWeakMap();\r\n                }\r\n                function describeNativeComponentFrame(fn2, construct) {\r\n                    if (!fn2 || reentry) {\r\n                        return \"\";\r\n                    }\r\n                    {\r\n                        var frame = componentFrameCache.get(fn2);\r\n                        if (frame !== void 0) {\r\n                            return frame;\r\n                        }\r\n                    }\r\n                    var control;\r\n                    reentry = true;\r\n                    var previousPrepareStackTrace = Error.prepareStackTrace;\r\n                    Error.prepareStackTrace = void 0;\r\n                    var previousDispatcher;\r\n                    {\r\n                        previousDispatcher = ReactCurrentDispatcher$1.current;\r\n                        ReactCurrentDispatcher$1.current = null;\r\n                        disableLogs();\r\n                    }\r\n                    try {\r\n                        if (construct) {\r\n                            var Fake_1 = function () {\r\n                                throw Error();\r\n                            };\r\n                            Object.defineProperty(Fake_1.prototype, \"props\", {\r\n                                set: function () {\r\n                                    throw Error();\r\n                                }\r\n                            });\r\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\r\n                                try {\r\n                                    Reflect.construct(Fake_1, []);\r\n                                }\r\n                                catch (x2) {\r\n                                    control = x2;\r\n                                }\r\n                                Reflect.construct(fn2, [], Fake_1);\r\n                            }\r\n                            else {\r\n                                try {\r\n                                    Fake_1.call();\r\n                                }\r\n                                catch (x2) {\r\n                                    control = x2;\r\n                                }\r\n                                fn2.call(Fake_1.prototype);\r\n                            }\r\n                        }\r\n                        else {\r\n                            try {\r\n                                throw Error();\r\n                            }\r\n                            catch (x2) {\r\n                                control = x2;\r\n                            }\r\n                            fn2();\r\n                        }\r\n                    }\r\n                    catch (sample) {\r\n                        if (sample && control && typeof sample.stack === \"string\") {\r\n                            var sampleLines = sample.stack.split(\"\\n\");\r\n                            var controlLines = control.stack.split(\"\\n\");\r\n                            var s2 = sampleLines.length - 1;\r\n                            var c2 = controlLines.length - 1;\r\n                            while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {\r\n                                c2--;\r\n                            }\r\n                            for (; s2 >= 1 && c2 >= 0; s2--, c2--) {\r\n                                if (sampleLines[s2] !== controlLines[c2]) {\r\n                                    if (s2 !== 1 || c2 !== 1) {\r\n                                        do {\r\n                                            s2--;\r\n                                            c2--;\r\n                                            if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {\r\n                                                var _frame = \"\\n\" + sampleLines[s2].replace(\" at new \", \" at \");\r\n                                                if (fn2.displayName && _frame.includes(\"<anonymous>\")) {\r\n                                                    _frame = _frame.replace(\"<anonymous>\", fn2.displayName);\r\n                                                }\r\n                                                {\r\n                                                    if (typeof fn2 === \"function\") {\r\n                                                        componentFrameCache.set(fn2, _frame);\r\n                                                    }\r\n                                                }\r\n                                                return _frame;\r\n                                            }\r\n                                        } while (s2 >= 1 && c2 >= 0);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    finally {\r\n                        reentry = false;\r\n                        {\r\n                            ReactCurrentDispatcher$1.current = previousDispatcher;\r\n                            reenableLogs();\r\n                        }\r\n                        Error.prepareStackTrace = previousPrepareStackTrace;\r\n                    }\r\n                    var name = fn2 ? fn2.displayName || fn2.name : \"\";\r\n                    var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\r\n                    {\r\n                        if (typeof fn2 === \"function\") {\r\n                            componentFrameCache.set(fn2, syntheticFrame);\r\n                        }\r\n                    }\r\n                    return syntheticFrame;\r\n                }\r\n                function describeFunctionComponentFrame(fn2, source, ownerFn) {\r\n                    {\r\n                        return describeNativeComponentFrame(fn2, false);\r\n                    }\r\n                }\r\n                function shouldConstruct(Component2) {\r\n                    var prototype = Component2.prototype;\r\n                    return !!(prototype && prototype.isReactComponent);\r\n                }\r\n                function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\r\n                    if (type == null) {\r\n                        return \"\";\r\n                    }\r\n                    if (typeof type === \"function\") {\r\n                        {\r\n                            return describeNativeComponentFrame(type, shouldConstruct(type));\r\n                        }\r\n                    }\r\n                    if (typeof type === \"string\") {\r\n                        return describeBuiltInComponentFrame(type);\r\n                    }\r\n                    switch (type) {\r\n                        case REACT_SUSPENSE_TYPE:\r\n                            return describeBuiltInComponentFrame(\"Suspense\");\r\n                        case REACT_SUSPENSE_LIST_TYPE:\r\n                            return describeBuiltInComponentFrame(\"SuspenseList\");\r\n                    }\r\n                    if (typeof type === \"object\") {\r\n                        switch (type.$$typeof) {\r\n                            case REACT_FORWARD_REF_TYPE:\r\n                                return describeFunctionComponentFrame(type.render);\r\n                            case REACT_MEMO_TYPE:\r\n                                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n                            case REACT_LAZY_TYPE: {\r\n                                var lazyComponent = type;\r\n                                var payload = lazyComponent._payload;\r\n                                var init = lazyComponent._init;\r\n                                try {\r\n                                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\r\n                                }\r\n                                catch (x2) {\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    return \"\";\r\n                }\r\n                var loggedTypeFailures = {};\r\n                var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n                function setCurrentlyValidatingElement(element) {\r\n                    {\r\n                        if (element) {\r\n                            var owner = element._owner;\r\n                            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n                            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\r\n                        }\r\n                        else {\r\n                            ReactDebugCurrentFrame$1.setExtraStackFrame(null);\r\n                        }\r\n                    }\r\n                }\r\n                function checkPropTypes(typeSpecs, values, location, componentName, element) {\r\n                    {\r\n                        var has = Function.call.bind(hasOwnProperty);\r\n                        for (var typeSpecName in typeSpecs) {\r\n                            if (has(typeSpecs, typeSpecName)) {\r\n                                var error$1 = void 0;\r\n                                try {\r\n                                    if (typeof typeSpecs[typeSpecName] !== \"function\") {\r\n                                        var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\r\n                                        err.name = \"Invariant Violation\";\r\n                                        throw err;\r\n                                    }\r\n                                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\r\n                                }\r\n                                catch (ex) {\r\n                                    error$1 = ex;\r\n                                }\r\n                                if (error$1 && !(error$1 instanceof Error)) {\r\n                                    setCurrentlyValidatingElement(element);\r\n                                    error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\r\n                                    setCurrentlyValidatingElement(null);\r\n                                }\r\n                                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\r\n                                    loggedTypeFailures[error$1.message] = true;\r\n                                    setCurrentlyValidatingElement(element);\r\n                                    error(\"Failed %s type: %s\", location, error$1.message);\r\n                                    setCurrentlyValidatingElement(null);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function setCurrentlyValidatingElement$1(element) {\r\n                    {\r\n                        if (element) {\r\n                            var owner = element._owner;\r\n                            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\r\n                            setExtraStackFrame(stack);\r\n                        }\r\n                        else {\r\n                            setExtraStackFrame(null);\r\n                        }\r\n                    }\r\n                }\r\n                var propTypesMisspellWarningShown;\r\n                {\r\n                    propTypesMisspellWarningShown = false;\r\n                }\r\n                function getDeclarationErrorAddendum() {\r\n                    if (ReactCurrentOwner.current) {\r\n                        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\r\n                        if (name) {\r\n                            return \"\\n\\nCheck the render method of `\" + name + \"`.\";\r\n                        }\r\n                    }\r\n                    return \"\";\r\n                }\r\n                function getSourceInfoErrorAddendum(source) {\r\n                    if (source !== void 0) {\r\n                        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\r\n                        var lineNumber = source.lineNumber;\r\n                        return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\r\n                    }\r\n                    return \"\";\r\n                }\r\n                function getSourceInfoErrorAddendumForProps(elementProps) {\r\n                    if (elementProps !== null && elementProps !== void 0) {\r\n                        return getSourceInfoErrorAddendum(elementProps.__source);\r\n                    }\r\n                    return \"\";\r\n                }\r\n                var ownerHasKeyUseWarning = {};\r\n                function getCurrentComponentErrorInfo(parentType) {\r\n                    var info = getDeclarationErrorAddendum();\r\n                    if (!info) {\r\n                        var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\r\n                        if (parentName) {\r\n                            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\r\n                        }\r\n                    }\r\n                    return info;\r\n                }\r\n                function validateExplicitKey(element, parentType) {\r\n                    if (!element._store || element._store.validated || element.key != null) {\r\n                        return;\r\n                    }\r\n                    element._store.validated = true;\r\n                    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\r\n                    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\r\n                        return;\r\n                    }\r\n                    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\r\n                    var childOwner = \"\";\r\n                    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\r\n                        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\r\n                    }\r\n                    {\r\n                        setCurrentlyValidatingElement$1(element);\r\n                        error('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\r\n                        setCurrentlyValidatingElement$1(null);\r\n                    }\r\n                }\r\n                function validateChildKeys(node, parentType) {\r\n                    if (typeof node !== \"object\") {\r\n                        return;\r\n                    }\r\n                    if (isArray(node)) {\r\n                        for (var i2 = 0; i2 < node.length; i2++) {\r\n                            var child = node[i2];\r\n                            if (isValidElement(child)) {\r\n                                validateExplicitKey(child, parentType);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (isValidElement(node)) {\r\n                        if (node._store) {\r\n                            node._store.validated = true;\r\n                        }\r\n                    }\r\n                    else if (node) {\r\n                        var iteratorFn = getIteratorFn(node);\r\n                        if (typeof iteratorFn === \"function\") {\r\n                            if (iteratorFn !== node.entries) {\r\n                                var iterator = iteratorFn.call(node);\r\n                                var step;\r\n                                while (!(step = iterator.next()).done) {\r\n                                    if (isValidElement(step.value)) {\r\n                                        validateExplicitKey(step.value, parentType);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function validatePropTypes(element) {\r\n                    {\r\n                        var type = element.type;\r\n                        if (type === null || type === void 0 || typeof type === \"string\") {\r\n                            return;\r\n                        }\r\n                        var propTypes;\r\n                        if (typeof type === \"function\") {\r\n                            propTypes = type.propTypes;\r\n                        }\r\n                        else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {\r\n                            propTypes = type.propTypes;\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                        if (propTypes) {\r\n                            var name = getComponentNameFromType(type);\r\n                            checkPropTypes(propTypes, element.props, \"prop\", name, element);\r\n                        }\r\n                        else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {\r\n                            propTypesMisspellWarningShown = true;\r\n                            var _name = getComponentNameFromType(type);\r\n                            error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\r\n                        }\r\n                        if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\r\n                            error(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\r\n                        }\r\n                    }\r\n                }\r\n                function validateFragmentProps(fragment) {\r\n                    {\r\n                        var keys = Object.keys(fragment.props);\r\n                        for (var i2 = 0; i2 < keys.length; i2++) {\r\n                            var key = keys[i2];\r\n                            if (key !== \"children\" && key !== \"key\") {\r\n                                setCurrentlyValidatingElement$1(fragment);\r\n                                error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", key);\r\n                                setCurrentlyValidatingElement$1(null);\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (fragment.ref !== null) {\r\n                            setCurrentlyValidatingElement$1(fragment);\r\n                            error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\r\n                            setCurrentlyValidatingElement$1(null);\r\n                        }\r\n                    }\r\n                }\r\n                function createElementWithValidation(type, props, children) {\r\n                    var validType = isValidElementType2(type);\r\n                    if (!validType) {\r\n                        var info = \"\";\r\n                        if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\r\n                            info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\r\n                        }\r\n                        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\r\n                        if (sourceInfo) {\r\n                            info += sourceInfo;\r\n                        }\r\n                        else {\r\n                            info += getDeclarationErrorAddendum();\r\n                        }\r\n                        var typeString;\r\n                        if (type === null) {\r\n                            typeString = \"null\";\r\n                        }\r\n                        else if (isArray(type)) {\r\n                            typeString = \"array\";\r\n                        }\r\n                        else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {\r\n                            typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\r\n                            info = \" Did you accidentally export a JSX literal instead of a component?\";\r\n                        }\r\n                        else {\r\n                            typeString = typeof type;\r\n                        }\r\n                        {\r\n                            error(\"React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", typeString, info);\r\n                        }\r\n                    }\r\n                    var element = createElement.apply(this, arguments);\r\n                    if (element == null) {\r\n                        return element;\r\n                    }\r\n                    if (validType) {\r\n                        for (var i2 = 2; i2 < arguments.length; i2++) {\r\n                            validateChildKeys(arguments[i2], type);\r\n                        }\r\n                    }\r\n                    if (type === REACT_FRAGMENT_TYPE) {\r\n                        validateFragmentProps(element);\r\n                    }\r\n                    else {\r\n                        validatePropTypes(element);\r\n                    }\r\n                    return element;\r\n                }\r\n                var didWarnAboutDeprecatedCreateFactory = false;\r\n                function createFactoryWithValidation(type) {\r\n                    var validatedFactory = createElementWithValidation.bind(null, type);\r\n                    validatedFactory.type = type;\r\n                    {\r\n                        if (!didWarnAboutDeprecatedCreateFactory) {\r\n                            didWarnAboutDeprecatedCreateFactory = true;\r\n                            warn(\"React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.\");\r\n                        }\r\n                        Object.defineProperty(validatedFactory, \"type\", {\r\n                            enumerable: false,\r\n                            get: function () {\r\n                                warn(\"Factory.type is deprecated. Access the class directly before passing it to createFactory.\");\r\n                                Object.defineProperty(this, \"type\", {\r\n                                    value: type\r\n                                });\r\n                                return type;\r\n                            }\r\n                        });\r\n                    }\r\n                    return validatedFactory;\r\n                }\r\n                function cloneElementWithValidation(element, props, children) {\r\n                    var newElement = cloneElement.apply(this, arguments);\r\n                    for (var i2 = 2; i2 < arguments.length; i2++) {\r\n                        validateChildKeys(arguments[i2], newElement.type);\r\n                    }\r\n                    validatePropTypes(newElement);\r\n                    return newElement;\r\n                }\r\n                function startTransition(scope, options) {\r\n                    var prevTransition = ReactCurrentBatchConfig.transition;\r\n                    ReactCurrentBatchConfig.transition = {};\r\n                    var currentTransition = ReactCurrentBatchConfig.transition;\r\n                    {\r\n                        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\r\n                    }\r\n                    try {\r\n                        scope();\r\n                    }\r\n                    finally {\r\n                        ReactCurrentBatchConfig.transition = prevTransition;\r\n                        {\r\n                            if (prevTransition === null && currentTransition._updatedFibers) {\r\n                                var updatedFibersCount = currentTransition._updatedFibers.size;\r\n                                if (updatedFibersCount > 10) {\r\n                                    warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\");\r\n                                }\r\n                                currentTransition._updatedFibers.clear();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var didWarnAboutMessageChannel = false;\r\n                var enqueueTaskImpl = null;\r\n                function enqueueTask(task) {\r\n                    if (enqueueTaskImpl === null) {\r\n                        try {\r\n                            var requireString = (\"require\" + Math.random()).slice(0, 7);\r\n                            var nodeRequire = module && module[requireString];\r\n                            enqueueTaskImpl = nodeRequire.call(module, \"timers\").setImmediate;\r\n                        }\r\n                        catch (_err) {\r\n                            enqueueTaskImpl = function (callback) {\r\n                                {\r\n                                    if (didWarnAboutMessageChannel === false) {\r\n                                        didWarnAboutMessageChannel = true;\r\n                                        if (typeof MessageChannel === \"undefined\") {\r\n                                            error(\"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\");\r\n                                        }\r\n                                    }\r\n                                }\r\n                                var channel = new MessageChannel();\r\n                                channel.port1.onmessage = callback;\r\n                                channel.port2.postMessage(void 0);\r\n                            };\r\n                        }\r\n                    }\r\n                    return enqueueTaskImpl(task);\r\n                }\r\n                var actScopeDepth = 0;\r\n                var didWarnNoAwaitAct = false;\r\n                function act(callback) {\r\n                    {\r\n                        var prevActScopeDepth = actScopeDepth;\r\n                        actScopeDepth++;\r\n                        if (ReactCurrentActQueue.current === null) {\r\n                            ReactCurrentActQueue.current = [];\r\n                        }\r\n                        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\r\n                        var result;\r\n                        try {\r\n                            ReactCurrentActQueue.isBatchingLegacy = true;\r\n                            result = callback();\r\n                            if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\r\n                                var queue = ReactCurrentActQueue.current;\r\n                                if (queue !== null) {\r\n                                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;\r\n                                    flushActQueue(queue);\r\n                                }\r\n                            }\r\n                        }\r\n                        catch (error2) {\r\n                            popActScope(prevActScopeDepth);\r\n                            throw error2;\r\n                        }\r\n                        finally {\r\n                            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\r\n                        }\r\n                        if (result !== null && typeof result === \"object\" && typeof result.then === \"function\") {\r\n                            var thenableResult = result;\r\n                            var wasAwaited = false;\r\n                            var thenable = {\r\n                                then: function (resolve, reject) {\r\n                                    wasAwaited = true;\r\n                                    thenableResult.then(function (returnValue2) {\r\n                                        popActScope(prevActScopeDepth);\r\n                                        if (actScopeDepth === 0) {\r\n                                            recursivelyFlushAsyncActWork(returnValue2, resolve, reject);\r\n                                        }\r\n                                        else {\r\n                                            resolve(returnValue2);\r\n                                        }\r\n                                    }, function (error2) {\r\n                                        popActScope(prevActScopeDepth);\r\n                                        reject(error2);\r\n                                    });\r\n                                }\r\n                            };\r\n                            {\r\n                                if (!didWarnNoAwaitAct && typeof Promise !== \"undefined\") {\r\n                                    Promise.resolve().then(function () {\r\n                                    }).then(function () {\r\n                                        if (!wasAwaited) {\r\n                                            didWarnNoAwaitAct = true;\r\n                                            error(\"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\");\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                            return thenable;\r\n                        }\r\n                        else {\r\n                            var returnValue = result;\r\n                            popActScope(prevActScopeDepth);\r\n                            if (actScopeDepth === 0) {\r\n                                var _queue = ReactCurrentActQueue.current;\r\n                                if (_queue !== null) {\r\n                                    flushActQueue(_queue);\r\n                                    ReactCurrentActQueue.current = null;\r\n                                }\r\n                                var _thenable = {\r\n                                    then: function (resolve, reject) {\r\n                                        if (ReactCurrentActQueue.current === null) {\r\n                                            ReactCurrentActQueue.current = [];\r\n                                            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\r\n                                        }\r\n                                        else {\r\n                                            resolve(returnValue);\r\n                                        }\r\n                                    }\r\n                                };\r\n                                return _thenable;\r\n                            }\r\n                            else {\r\n                                var _thenable2 = {\r\n                                    then: function (resolve, reject) {\r\n                                        resolve(returnValue);\r\n                                    }\r\n                                };\r\n                                return _thenable2;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function popActScope(prevActScopeDepth) {\r\n                    {\r\n                        if (prevActScopeDepth !== actScopeDepth - 1) {\r\n                            error(\"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \");\r\n                        }\r\n                        actScopeDepth = prevActScopeDepth;\r\n                    }\r\n                }\r\n                function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\r\n                    {\r\n                        var queue = ReactCurrentActQueue.current;\r\n                        if (queue !== null) {\r\n                            try {\r\n                                flushActQueue(queue);\r\n                                enqueueTask(function () {\r\n                                    if (queue.length === 0) {\r\n                                        ReactCurrentActQueue.current = null;\r\n                                        resolve(returnValue);\r\n                                    }\r\n                                    else {\r\n                                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);\r\n                                    }\r\n                                });\r\n                            }\r\n                            catch (error2) {\r\n                                reject(error2);\r\n                            }\r\n                        }\r\n                        else {\r\n                            resolve(returnValue);\r\n                        }\r\n                    }\r\n                }\r\n                var isFlushing = false;\r\n                function flushActQueue(queue) {\r\n                    {\r\n                        if (!isFlushing) {\r\n                            isFlushing = true;\r\n                            var i2 = 0;\r\n                            try {\r\n                                for (; i2 < queue.length; i2++) {\r\n                                    var callback = queue[i2];\r\n                                    do {\r\n                                        callback = callback(true);\r\n                                    } while (callback !== null);\r\n                                }\r\n                                queue.length = 0;\r\n                            }\r\n                            catch (error2) {\r\n                                queue = queue.slice(i2 + 1);\r\n                                throw error2;\r\n                            }\r\n                            finally {\r\n                                isFlushing = false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var createElement$1 = createElementWithValidation;\r\n                var cloneElement$1 = cloneElementWithValidation;\r\n                var createFactory = createFactoryWithValidation;\r\n                var Children = {\r\n                    map: mapChildren,\r\n                    forEach: forEachChildren,\r\n                    count: countChildren,\r\n                    toArray: toArray,\r\n                    only: onlyChild\r\n                };\r\n                exports.Children = Children;\r\n                exports.Component = Component;\r\n                exports.Fragment = REACT_FRAGMENT_TYPE;\r\n                exports.Profiler = REACT_PROFILER_TYPE;\r\n                exports.PureComponent = PureComponent;\r\n                exports.StrictMode = REACT_STRICT_MODE_TYPE;\r\n                exports.Suspense = REACT_SUSPENSE_TYPE;\r\n                exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\r\n                exports.cloneElement = cloneElement$1;\r\n                exports.createContext = createContext;\r\n                exports.createElement = createElement$1;\r\n                exports.createFactory = createFactory;\r\n                exports.createRef = createRef;\r\n                exports.forwardRef = forwardRef;\r\n                exports.isValidElement = isValidElement;\r\n                exports.lazy = lazy;\r\n                exports.memo = memo;\r\n                exports.startTransition = startTransition;\r\n                exports.unstable_act = act;\r\n                exports.useCallback = useCallback2;\r\n                exports.useContext = useContext5;\r\n                exports.useDebugValue = useDebugValue3;\r\n                exports.useDeferredValue = useDeferredValue;\r\n                exports.useEffect = useEffect6;\r\n                exports.useId = useId;\r\n                exports.useImperativeHandle = useImperativeHandle;\r\n                exports.useInsertionEffect = useInsertionEffect;\r\n                exports.useLayoutEffect = useLayoutEffect3;\r\n                exports.useMemo = useMemo5;\r\n                exports.useReducer = useReducer;\r\n                exports.useRef = useRef5;\r\n                exports.useState = useState2;\r\n                exports.useSyncExternalStore = useSyncExternalStore3;\r\n                exports.useTransition = useTransition;\r\n                exports.version = ReactVersion;\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\r\n                }\r\n            })();\r\n        }\r\n    }\r\n});\r\n// ../../node_modules/react/index.js\r\nvar require_react = __commonJS({\r\n    \"../../node_modules/react/index.js\": function (exports, module) {\r\n        \"use strict\";\r\n        if (false) {\r\n            module.exports = null;\r\n        }\r\n        else {\r\n            module.exports = require_react_development();\r\n        }\r\n    }\r\n});\r\n// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\r\nvar require_use_sync_external_store_shim_development = __commonJS({\r\n    \"../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\": function (exports) {\r\n        \"use strict\";\r\n        if (true) {\r\n            (function () {\r\n                \"use strict\";\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n                }\r\n                var React5 = require_react();\r\n                var ReactSharedInternals = React5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n                function error(format) {\r\n                    {\r\n                        {\r\n                            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n                                args[_key2 - 1] = arguments[_key2];\r\n                            }\r\n                            printWarning(\"error\", format, args);\r\n                        }\r\n                    }\r\n                }\r\n                function printWarning(level, format, args) {\r\n                    {\r\n                        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n                        var stack = ReactDebugCurrentFrame.getStackAddendum();\r\n                        if (stack !== \"\") {\r\n                            format += \"%s\";\r\n                            args = args.concat([stack]);\r\n                        }\r\n                        var argsWithFormat = args.map(function (item) {\r\n                            return String(item);\r\n                        });\r\n                        argsWithFormat.unshift(\"Warning: \" + format);\r\n                        Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n                    }\r\n                }\r\n                function is2(x2, y2) {\r\n                    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;\r\n                }\r\n                var objectIs = typeof Object.is === \"function\" ? Object.is : is2;\r\n                var useState2 = React5.useState, useEffect6 = React5.useEffect, useLayoutEffect3 = React5.useLayoutEffect, useDebugValue3 = React5.useDebugValue;\r\n                var didWarnOld18Alpha = false;\r\n                var didWarnUncachedGetSnapshot = false;\r\n                function useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot) {\r\n                    {\r\n                        if (!didWarnOld18Alpha) {\r\n                            if (React5.startTransition !== void 0) {\r\n                                didWarnOld18Alpha = true;\r\n                                error(\"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\");\r\n                            }\r\n                        }\r\n                    }\r\n                    var value = getSnapshot();\r\n                    {\r\n                        if (!didWarnUncachedGetSnapshot) {\r\n                            var cachedValue = getSnapshot();\r\n                            if (!objectIs(value, cachedValue)) {\r\n                                error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\r\n                                didWarnUncachedGetSnapshot = true;\r\n                            }\r\n                        }\r\n                    }\r\n                    var _useState = useState2({\r\n                        inst: {\r\n                            value: value,\r\n                            getSnapshot: getSnapshot\r\n                        }\r\n                    }), inst = _useState[0].inst, forceUpdate = _useState[1];\r\n                    useLayoutEffect3(function () {\r\n                        inst.value = value;\r\n                        inst.getSnapshot = getSnapshot;\r\n                        if (checkIfSnapshotChanged(inst)) {\r\n                            forceUpdate({\r\n                                inst: inst\r\n                            });\r\n                        }\r\n                    }, [subscribe, value, getSnapshot]);\r\n                    useEffect6(function () {\r\n                        if (checkIfSnapshotChanged(inst)) {\r\n                            forceUpdate({\r\n                                inst: inst\r\n                            });\r\n                        }\r\n                        var handleStoreChange = function () {\r\n                            if (checkIfSnapshotChanged(inst)) {\r\n                                forceUpdate({\r\n                                    inst: inst\r\n                                });\r\n                            }\r\n                        };\r\n                        return subscribe(handleStoreChange);\r\n                    }, [subscribe]);\r\n                    useDebugValue3(value);\r\n                    return value;\r\n                }\r\n                function checkIfSnapshotChanged(inst) {\r\n                    var latestGetSnapshot = inst.getSnapshot;\r\n                    var prevValue = inst.value;\r\n                    try {\r\n                        var nextValue = latestGetSnapshot();\r\n                        return !objectIs(prevValue, nextValue);\r\n                    }\r\n                    catch (error2) {\r\n                        return true;\r\n                    }\r\n                }\r\n                function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\r\n                    return getSnapshot();\r\n                }\r\n                var canUseDOM2 = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\r\n                var isServerEnvironment = !canUseDOM2;\r\n                var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore3;\r\n                var useSyncExternalStore$2 = React5.useSyncExternalStore !== void 0 ? React5.useSyncExternalStore : shim;\r\n                exports.useSyncExternalStore = useSyncExternalStore$2;\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\r\n                }\r\n            })();\r\n        }\r\n    }\r\n});\r\n// ../../node_modules/use-sync-external-store/shim/index.js\r\nvar require_shim = __commonJS({\r\n    \"../../node_modules/use-sync-external-store/shim/index.js\": function (exports, module) {\r\n        \"use strict\";\r\n        if (false) {\r\n            module.exports = null;\r\n        }\r\n        else {\r\n            module.exports = require_use_sync_external_store_shim_development();\r\n        }\r\n    }\r\n});\r\n// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\r\nvar require_with_selector_development = __commonJS({\r\n    \"../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\": function (exports) {\r\n        \"use strict\";\r\n        if (true) {\r\n            (function () {\r\n                \"use strict\";\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n                }\r\n                var React5 = require_react();\r\n                var shim = require_shim();\r\n                function is2(x2, y2) {\r\n                    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;\r\n                }\r\n                var objectIs = typeof Object.is === \"function\" ? Object.is : is2;\r\n                var useSyncExternalStore3 = shim.useSyncExternalStore;\r\n                var useRef5 = React5.useRef, useEffect6 = React5.useEffect, useMemo5 = React5.useMemo, useDebugValue3 = React5.useDebugValue;\r\n                function useSyncExternalStoreWithSelector3(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\r\n                    var instRef = useRef5(null);\r\n                    var inst;\r\n                    if (instRef.current === null) {\r\n                        inst = {\r\n                            hasValue: false,\r\n                            value: null\r\n                        };\r\n                        instRef.current = inst;\r\n                    }\r\n                    else {\r\n                        inst = instRef.current;\r\n                    }\r\n                    var _useMemo = useMemo5(function () {\r\n                        var hasMemo = false;\r\n                        var memoizedSnapshot;\r\n                        var memoizedSelection;\r\n                        var memoizedSelector = function (nextSnapshot) {\r\n                            if (!hasMemo) {\r\n                                hasMemo = true;\r\n                                memoizedSnapshot = nextSnapshot;\r\n                                var _nextSelection = selector(nextSnapshot);\r\n                                if (isEqual !== void 0) {\r\n                                    if (inst.hasValue) {\r\n                                        var currentSelection = inst.value;\r\n                                        if (isEqual(currentSelection, _nextSelection)) {\r\n                                            memoizedSelection = currentSelection;\r\n                                            return currentSelection;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                memoizedSelection = _nextSelection;\r\n                                return _nextSelection;\r\n                            }\r\n                            var prevSnapshot = memoizedSnapshot;\r\n                            var prevSelection = memoizedSelection;\r\n                            if (objectIs(prevSnapshot, nextSnapshot)) {\r\n                                return prevSelection;\r\n                            }\r\n                            var nextSelection = selector(nextSnapshot);\r\n                            if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {\r\n                                return prevSelection;\r\n                            }\r\n                            memoizedSnapshot = nextSnapshot;\r\n                            memoizedSelection = nextSelection;\r\n                            return nextSelection;\r\n                        };\r\n                        var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\r\n                        var getSnapshotWithSelector = function () {\r\n                            return memoizedSelector(getSnapshot());\r\n                        };\r\n                        var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function () {\r\n                            return memoizedSelector(maybeGetServerSnapshot());\r\n                        };\r\n                        return [getSnapshotWithSelector, getServerSnapshotWithSelector];\r\n                    }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\r\n                    var value = useSyncExternalStore3(subscribe, getSelection, getServerSelection);\r\n                    useEffect6(function () {\r\n                        inst.hasValue = true;\r\n                        inst.value = value;\r\n                    }, [value]);\r\n                    useDebugValue3(value);\r\n                    return value;\r\n                }\r\n                exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector3;\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\r\n                }\r\n            })();\r\n        }\r\n    }\r\n});\r\n// ../../node_modules/use-sync-external-store/shim/with-selector.js\r\nvar require_with_selector = __commonJS({\r\n    \"../../node_modules/use-sync-external-store/shim/with-selector.js\": function (exports, module) {\r\n        \"use strict\";\r\n        if (false) {\r\n            module.exports = null;\r\n        }\r\n        else {\r\n            module.exports = require_with_selector_development();\r\n        }\r\n    }\r\n});\r\n// ../../node_modules/scheduler/cjs/scheduler.development.js\r\nvar require_scheduler_development = __commonJS({\r\n    \"../../node_modules/scheduler/cjs/scheduler.development.js\": function (exports) {\r\n        \"use strict\";\r\n        if (true) {\r\n            (function () {\r\n                \"use strict\";\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n                }\r\n                var enableSchedulerDebugging = false;\r\n                var enableProfiling = false;\r\n                var frameYieldMs = 5;\r\n                function push(heap, node) {\r\n                    var index = heap.length;\r\n                    heap.push(node);\r\n                    siftUp(heap, node, index);\r\n                }\r\n                function peek(heap) {\r\n                    return heap.length === 0 ? null : heap[0];\r\n                }\r\n                function pop(heap) {\r\n                    if (heap.length === 0) {\r\n                        return null;\r\n                    }\r\n                    var first = heap[0];\r\n                    var last = heap.pop();\r\n                    if (last !== first) {\r\n                        heap[0] = last;\r\n                        siftDown(heap, last, 0);\r\n                    }\r\n                    return first;\r\n                }\r\n                function siftUp(heap, node, i2) {\r\n                    var index = i2;\r\n                    while (index > 0) {\r\n                        var parentIndex = index - 1 >>> 1;\r\n                        var parent = heap[parentIndex];\r\n                        if (compare(parent, node) > 0) {\r\n                            heap[parentIndex] = node;\r\n                            heap[index] = parent;\r\n                            index = parentIndex;\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                function siftDown(heap, node, i2) {\r\n                    var index = i2;\r\n                    var length = heap.length;\r\n                    var halfLength = length >>> 1;\r\n                    while (index < halfLength) {\r\n                        var leftIndex = (index + 1) * 2 - 1;\r\n                        var left = heap[leftIndex];\r\n                        var rightIndex = leftIndex + 1;\r\n                        var right = heap[rightIndex];\r\n                        if (compare(left, node) < 0) {\r\n                            if (rightIndex < length && compare(right, left) < 0) {\r\n                                heap[index] = right;\r\n                                heap[rightIndex] = node;\r\n                                index = rightIndex;\r\n                            }\r\n                            else {\r\n                                heap[index] = left;\r\n                                heap[leftIndex] = node;\r\n                                index = leftIndex;\r\n                            }\r\n                        }\r\n                        else if (rightIndex < length && compare(right, node) < 0) {\r\n                            heap[index] = right;\r\n                            heap[rightIndex] = node;\r\n                            index = rightIndex;\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                function compare(a2, b2) {\r\n                    var diff = a2.sortIndex - b2.sortIndex;\r\n                    return diff !== 0 ? diff : a2.id - b2.id;\r\n                }\r\n                var ImmediatePriority = 1;\r\n                var UserBlockingPriority = 2;\r\n                var NormalPriority = 3;\r\n                var LowPriority = 4;\r\n                var IdlePriority = 5;\r\n                function markTaskErrored(task, ms) {\r\n                }\r\n                var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\r\n                if (hasPerformanceNow) {\r\n                    var localPerformance = performance;\r\n                    exports.unstable_now = function () {\r\n                        return localPerformance.now();\r\n                    };\r\n                }\r\n                else {\r\n                    var localDate = Date;\r\n                    var initialTime = localDate.now();\r\n                    exports.unstable_now = function () {\r\n                        return localDate.now() - initialTime;\r\n                    };\r\n                }\r\n                var maxSigned31BitInt = 1073741823;\r\n                var IMMEDIATE_PRIORITY_TIMEOUT = -1;\r\n                var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\r\n                var NORMAL_PRIORITY_TIMEOUT = 5e3;\r\n                var LOW_PRIORITY_TIMEOUT = 1e4;\r\n                var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\r\n                var taskQueue = [];\r\n                var timerQueue = [];\r\n                var taskIdCounter = 1;\r\n                var currentTask = null;\r\n                var currentPriorityLevel = NormalPriority;\r\n                var isPerformingWork = false;\r\n                var isHostCallbackScheduled = false;\r\n                var isHostTimeoutScheduled = false;\r\n                var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\r\n                var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\r\n                var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null;\r\n                var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\r\n                function advanceTimers(currentTime) {\r\n                    var timer = peek(timerQueue);\r\n                    while (timer !== null) {\r\n                        if (timer.callback === null) {\r\n                            pop(timerQueue);\r\n                        }\r\n                        else if (timer.startTime <= currentTime) {\r\n                            pop(timerQueue);\r\n                            timer.sortIndex = timer.expirationTime;\r\n                            push(taskQueue, timer);\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                        timer = peek(timerQueue);\r\n                    }\r\n                }\r\n                function handleTimeout(currentTime) {\r\n                    isHostTimeoutScheduled = false;\r\n                    advanceTimers(currentTime);\r\n                    if (!isHostCallbackScheduled) {\r\n                        if (peek(taskQueue) !== null) {\r\n                            isHostCallbackScheduled = true;\r\n                            requestHostCallback(flushWork);\r\n                        }\r\n                        else {\r\n                            var firstTimer = peek(timerQueue);\r\n                            if (firstTimer !== null) {\r\n                                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function flushWork(hasTimeRemaining, initialTime2) {\r\n                    isHostCallbackScheduled = false;\r\n                    if (isHostTimeoutScheduled) {\r\n                        isHostTimeoutScheduled = false;\r\n                        cancelHostTimeout();\r\n                    }\r\n                    isPerformingWork = true;\r\n                    var previousPriorityLevel = currentPriorityLevel;\r\n                    try {\r\n                        if (enableProfiling) {\r\n                            try {\r\n                                return workLoop(hasTimeRemaining, initialTime2);\r\n                            }\r\n                            catch (error) {\r\n                                if (currentTask !== null) {\r\n                                    var currentTime = exports.unstable_now();\r\n                                    markTaskErrored(currentTask, currentTime);\r\n                                    currentTask.isQueued = false;\r\n                                }\r\n                                throw error;\r\n                            }\r\n                        }\r\n                        else {\r\n                            return workLoop(hasTimeRemaining, initialTime2);\r\n                        }\r\n                    }\r\n                    finally {\r\n                        currentTask = null;\r\n                        currentPriorityLevel = previousPriorityLevel;\r\n                        isPerformingWork = false;\r\n                    }\r\n                }\r\n                function workLoop(hasTimeRemaining, initialTime2) {\r\n                    var currentTime = initialTime2;\r\n                    advanceTimers(currentTime);\r\n                    currentTask = peek(taskQueue);\r\n                    while (currentTask !== null && !enableSchedulerDebugging) {\r\n                        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\r\n                            break;\r\n                        }\r\n                        var callback = currentTask.callback;\r\n                        if (typeof callback === \"function\") {\r\n                            currentTask.callback = null;\r\n                            currentPriorityLevel = currentTask.priorityLevel;\r\n                            var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\r\n                            var continuationCallback = callback(didUserCallbackTimeout);\r\n                            currentTime = exports.unstable_now();\r\n                            if (typeof continuationCallback === \"function\") {\r\n                                currentTask.callback = continuationCallback;\r\n                            }\r\n                            else {\r\n                                if (currentTask === peek(taskQueue)) {\r\n                                    pop(taskQueue);\r\n                                }\r\n                            }\r\n                            advanceTimers(currentTime);\r\n                        }\r\n                        else {\r\n                            pop(taskQueue);\r\n                        }\r\n                        currentTask = peek(taskQueue);\r\n                    }\r\n                    if (currentTask !== null) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        var firstTimer = peek(timerQueue);\r\n                        if (firstTimer !== null) {\r\n                            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\r\n                        }\r\n                        return false;\r\n                    }\r\n                }\r\n                function unstable_runWithPriority(priorityLevel, eventHandler) {\r\n                    switch (priorityLevel) {\r\n                        case ImmediatePriority:\r\n                        case UserBlockingPriority:\r\n                        case NormalPriority:\r\n                        case LowPriority:\r\n                        case IdlePriority:\r\n                            break;\r\n                        default:\r\n                            priorityLevel = NormalPriority;\r\n                    }\r\n                    var previousPriorityLevel = currentPriorityLevel;\r\n                    currentPriorityLevel = priorityLevel;\r\n                    try {\r\n                        return eventHandler();\r\n                    }\r\n                    finally {\r\n                        currentPriorityLevel = previousPriorityLevel;\r\n                    }\r\n                }\r\n                function unstable_next(eventHandler) {\r\n                    var priorityLevel;\r\n                    switch (currentPriorityLevel) {\r\n                        case ImmediatePriority:\r\n                        case UserBlockingPriority:\r\n                        case NormalPriority:\r\n                            priorityLevel = NormalPriority;\r\n                            break;\r\n                        default:\r\n                            priorityLevel = currentPriorityLevel;\r\n                            break;\r\n                    }\r\n                    var previousPriorityLevel = currentPriorityLevel;\r\n                    currentPriorityLevel = priorityLevel;\r\n                    try {\r\n                        return eventHandler();\r\n                    }\r\n                    finally {\r\n                        currentPriorityLevel = previousPriorityLevel;\r\n                    }\r\n                }\r\n                function unstable_wrapCallback(callback) {\r\n                    var parentPriorityLevel = currentPriorityLevel;\r\n                    return function () {\r\n                        var previousPriorityLevel = currentPriorityLevel;\r\n                        currentPriorityLevel = parentPriorityLevel;\r\n                        try {\r\n                            return callback.apply(this, arguments);\r\n                        }\r\n                        finally {\r\n                            currentPriorityLevel = previousPriorityLevel;\r\n                        }\r\n                    };\r\n                }\r\n                function unstable_scheduleCallback(priorityLevel, callback, options) {\r\n                    var currentTime = exports.unstable_now();\r\n                    var startTime2;\r\n                    if (typeof options === \"object\" && options !== null) {\r\n                        var delay = options.delay;\r\n                        if (typeof delay === \"number\" && delay > 0) {\r\n                            startTime2 = currentTime + delay;\r\n                        }\r\n                        else {\r\n                            startTime2 = currentTime;\r\n                        }\r\n                    }\r\n                    else {\r\n                        startTime2 = currentTime;\r\n                    }\r\n                    var timeout;\r\n                    switch (priorityLevel) {\r\n                        case ImmediatePriority:\r\n                            timeout = IMMEDIATE_PRIORITY_TIMEOUT;\r\n                            break;\r\n                        case UserBlockingPriority:\r\n                            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\r\n                            break;\r\n                        case IdlePriority:\r\n                            timeout = IDLE_PRIORITY_TIMEOUT;\r\n                            break;\r\n                        case LowPriority:\r\n                            timeout = LOW_PRIORITY_TIMEOUT;\r\n                            break;\r\n                        case NormalPriority:\r\n                        default:\r\n                            timeout = NORMAL_PRIORITY_TIMEOUT;\r\n                            break;\r\n                    }\r\n                    var expirationTime = startTime2 + timeout;\r\n                    var newTask = {\r\n                        id: taskIdCounter++,\r\n                        callback: callback,\r\n                        priorityLevel: priorityLevel,\r\n                        startTime: startTime2,\r\n                        expirationTime: expirationTime,\r\n                        sortIndex: -1\r\n                    };\r\n                    if (startTime2 > currentTime) {\r\n                        newTask.sortIndex = startTime2;\r\n                        push(timerQueue, newTask);\r\n                        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\r\n                            if (isHostTimeoutScheduled) {\r\n                                cancelHostTimeout();\r\n                            }\r\n                            else {\r\n                                isHostTimeoutScheduled = true;\r\n                            }\r\n                            requestHostTimeout(handleTimeout, startTime2 - currentTime);\r\n                        }\r\n                    }\r\n                    else {\r\n                        newTask.sortIndex = expirationTime;\r\n                        push(taskQueue, newTask);\r\n                        if (!isHostCallbackScheduled && !isPerformingWork) {\r\n                            isHostCallbackScheduled = true;\r\n                            requestHostCallback(flushWork);\r\n                        }\r\n                    }\r\n                    return newTask;\r\n                }\r\n                function unstable_pauseExecution() {\r\n                }\r\n                function unstable_continueExecution() {\r\n                    if (!isHostCallbackScheduled && !isPerformingWork) {\r\n                        isHostCallbackScheduled = true;\r\n                        requestHostCallback(flushWork);\r\n                    }\r\n                }\r\n                function unstable_getFirstCallbackNode() {\r\n                    return peek(taskQueue);\r\n                }\r\n                function unstable_cancelCallback(task) {\r\n                    task.callback = null;\r\n                }\r\n                function unstable_getCurrentPriorityLevel() {\r\n                    return currentPriorityLevel;\r\n                }\r\n                var isMessageLoopRunning = false;\r\n                var scheduledHostCallback = null;\r\n                var taskTimeoutID = -1;\r\n                var frameInterval = frameYieldMs;\r\n                var startTime = -1;\r\n                function shouldYieldToHost() {\r\n                    var timeElapsed = exports.unstable_now() - startTime;\r\n                    if (timeElapsed < frameInterval) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n                function requestPaint() {\r\n                }\r\n                function forceFrameRate(fps) {\r\n                    if (fps < 0 || fps > 125) {\r\n                        console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\");\r\n                        return;\r\n                    }\r\n                    if (fps > 0) {\r\n                        frameInterval = Math.floor(1e3 / fps);\r\n                    }\r\n                    else {\r\n                        frameInterval = frameYieldMs;\r\n                    }\r\n                }\r\n                var performWorkUntilDeadline = function () {\r\n                    if (scheduledHostCallback !== null) {\r\n                        var currentTime = exports.unstable_now();\r\n                        startTime = currentTime;\r\n                        var hasTimeRemaining = true;\r\n                        var hasMoreWork = true;\r\n                        try {\r\n                            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\r\n                        }\r\n                        finally {\r\n                            if (hasMoreWork) {\r\n                                schedulePerformWorkUntilDeadline();\r\n                            }\r\n                            else {\r\n                                isMessageLoopRunning = false;\r\n                                scheduledHostCallback = null;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        isMessageLoopRunning = false;\r\n                    }\r\n                };\r\n                var schedulePerformWorkUntilDeadline;\r\n                if (typeof localSetImmediate === \"function\") {\r\n                    schedulePerformWorkUntilDeadline = function () {\r\n                        localSetImmediate(performWorkUntilDeadline);\r\n                    };\r\n                }\r\n                else if (typeof MessageChannel !== \"undefined\") {\r\n                    var channel = new MessageChannel();\r\n                    var port = channel.port2;\r\n                    channel.port1.onmessage = performWorkUntilDeadline;\r\n                    schedulePerformWorkUntilDeadline = function () {\r\n                        port.postMessage(null);\r\n                    };\r\n                }\r\n                else {\r\n                    schedulePerformWorkUntilDeadline = function () {\r\n                        localSetTimeout(performWorkUntilDeadline, 0);\r\n                    };\r\n                }\r\n                function requestHostCallback(callback) {\r\n                    scheduledHostCallback = callback;\r\n                    if (!isMessageLoopRunning) {\r\n                        isMessageLoopRunning = true;\r\n                        schedulePerformWorkUntilDeadline();\r\n                    }\r\n                }\r\n                function requestHostTimeout(callback, ms) {\r\n                    taskTimeoutID = localSetTimeout(function () {\r\n                        callback(exports.unstable_now());\r\n                    }, ms);\r\n                }\r\n                function cancelHostTimeout() {\r\n                    localClearTimeout(taskTimeoutID);\r\n                    taskTimeoutID = -1;\r\n                }\r\n                var unstable_requestPaint = requestPaint;\r\n                var unstable_Profiling = null;\r\n                exports.unstable_IdlePriority = IdlePriority;\r\n                exports.unstable_ImmediatePriority = ImmediatePriority;\r\n                exports.unstable_LowPriority = LowPriority;\r\n                exports.unstable_NormalPriority = NormalPriority;\r\n                exports.unstable_Profiling = unstable_Profiling;\r\n                exports.unstable_UserBlockingPriority = UserBlockingPriority;\r\n                exports.unstable_cancelCallback = unstable_cancelCallback;\r\n                exports.unstable_continueExecution = unstable_continueExecution;\r\n                exports.unstable_forceFrameRate = forceFrameRate;\r\n                exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\r\n                exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\r\n                exports.unstable_next = unstable_next;\r\n                exports.unstable_pauseExecution = unstable_pauseExecution;\r\n                exports.unstable_requestPaint = unstable_requestPaint;\r\n                exports.unstable_runWithPriority = unstable_runWithPriority;\r\n                exports.unstable_scheduleCallback = unstable_scheduleCallback;\r\n                exports.unstable_shouldYield = shouldYieldToHost;\r\n                exports.unstable_wrapCallback = unstable_wrapCallback;\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\r\n                }\r\n            })();\r\n        }\r\n    }\r\n});\r\n// ../../node_modules/scheduler/index.js\r\nvar require_scheduler = __commonJS({\r\n    \"../../node_modules/scheduler/index.js\": function (exports, module) {\r\n        \"use strict\";\r\n        if (false) {\r\n            module.exports = null;\r\n        }\r\n        else {\r\n            module.exports = require_scheduler_development();\r\n        }\r\n    }\r\n});\r\n// ../../node_modules/react-dom/cjs/react-dom.development.js\r\nvar require_react_dom_development = __commonJS({\r\n    \"../../node_modules/react-dom/cjs/react-dom.development.js\": function (exports) {\r\n        \"use strict\";\r\n        if (true) {\r\n            (function () {\r\n                \"use strict\";\r\n                if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\r\n                    __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\r\n                }\r\n                var React5 = require_react();\r\n                var Scheduler = require_scheduler();\r\n                var ReactSharedInternals = React5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\r\n                var suppressWarning = false;\r\n                function setSuppressWarning(newSuppressWarning) {\r\n                    {\r\n                        suppressWarning = newSuppressWarning;\r\n                    }\r\n                }\r\n                function warn(format) {\r\n                    {\r\n                        if (!suppressWarning) {\r\n                            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n                                args[_key - 1] = arguments[_key];\r\n                            }\r\n                            printWarning(\"warn\", format, args);\r\n                        }\r\n                    }\r\n                }\r\n                function error(format) {\r\n                    {\r\n                        if (!suppressWarning) {\r\n                            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n                                args[_key2 - 1] = arguments[_key2];\r\n                            }\r\n                            printWarning(\"error\", format, args);\r\n                        }\r\n                    }\r\n                }\r\n                function printWarning(level, format, args) {\r\n                    {\r\n                        var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\r\n                        var stack = ReactDebugCurrentFrame2.getStackAddendum();\r\n                        if (stack !== \"\") {\r\n                            format += \"%s\";\r\n                            args = args.concat([stack]);\r\n                        }\r\n                        var argsWithFormat = args.map(function (item) {\r\n                            return String(item);\r\n                        });\r\n                        argsWithFormat.unshift(\"Warning: \" + format);\r\n                        Function.prototype.apply.call(console[level], console, argsWithFormat);\r\n                    }\r\n                }\r\n                var FunctionComponent = 0;\r\n                var ClassComponent = 1;\r\n                var IndeterminateComponent = 2;\r\n                var HostRoot = 3;\r\n                var HostPortal = 4;\r\n                var HostComponent = 5;\r\n                var HostText = 6;\r\n                var Fragment = 7;\r\n                var Mode = 8;\r\n                var ContextConsumer = 9;\r\n                var ContextProvider = 10;\r\n                var ForwardRef = 11;\r\n                var Profiler = 12;\r\n                var SuspenseComponent = 13;\r\n                var MemoComponent = 14;\r\n                var SimpleMemoComponent = 15;\r\n                var LazyComponent = 16;\r\n                var IncompleteClassComponent = 17;\r\n                var DehydratedFragment = 18;\r\n                var SuspenseListComponent = 19;\r\n                var ScopeComponent = 21;\r\n                var OffscreenComponent = 22;\r\n                var LegacyHiddenComponent = 23;\r\n                var CacheComponent = 24;\r\n                var TracingMarkerComponent = 25;\r\n                var enableClientRenderFallbackOnTextMismatch = true;\r\n                var enableNewReconciler = false;\r\n                var enableLazyContextPropagation = false;\r\n                var enableLegacyHidden = false;\r\n                var enableSuspenseAvoidThisFallback = false;\r\n                var disableCommentsAsDOMContainers = true;\r\n                var enableCustomElementPropertySupport = false;\r\n                var warnAboutStringRefs = false;\r\n                var enableSchedulingProfiler = true;\r\n                var enableProfilerTimer = true;\r\n                var enableProfilerCommitHooks = true;\r\n                var allNativeEvents = new Set();\r\n                var registrationNameDependencies = {};\r\n                var possibleRegistrationNames = {};\r\n                function registerTwoPhaseEvent(registrationName, dependencies) {\r\n                    registerDirectEvent(registrationName, dependencies);\r\n                    registerDirectEvent(registrationName + \"Capture\", dependencies);\r\n                }\r\n                function registerDirectEvent(registrationName, dependencies) {\r\n                    {\r\n                        if (registrationNameDependencies[registrationName]) {\r\n                            error(\"EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.\", registrationName);\r\n                        }\r\n                    }\r\n                    registrationNameDependencies[registrationName] = dependencies;\r\n                    {\r\n                        var lowerCasedName = registrationName.toLowerCase();\r\n                        possibleRegistrationNames[lowerCasedName] = registrationName;\r\n                        if (registrationName === \"onDoubleClick\") {\r\n                            possibleRegistrationNames.ondblclick = registrationName;\r\n                        }\r\n                    }\r\n                    for (var i2 = 0; i2 < dependencies.length; i2++) {\r\n                        allNativeEvents.add(dependencies[i2]);\r\n                    }\r\n                }\r\n                var canUseDOM2 = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\r\n                var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n                function typeName(value) {\r\n                    {\r\n                        var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\r\n                        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\r\n                        return type;\r\n                    }\r\n                }\r\n                function willCoercionThrow(value) {\r\n                    {\r\n                        try {\r\n                            testStringCoercion(value);\r\n                            return false;\r\n                        }\r\n                        catch (e2) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                function testStringCoercion(value) {\r\n                    return \"\" + value;\r\n                }\r\n                function checkAttributeStringCoercion(value, attributeName) {\r\n                    {\r\n                        if (willCoercionThrow(value)) {\r\n                            error(\"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.\", attributeName, typeName(value));\r\n                            return testStringCoercion(value);\r\n                        }\r\n                    }\r\n                }\r\n                function checkKeyStringCoercion(value) {\r\n                    {\r\n                        if (willCoercionThrow(value)) {\r\n                            error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\r\n                            return testStringCoercion(value);\r\n                        }\r\n                    }\r\n                }\r\n                function checkPropStringCoercion(value, propName) {\r\n                    {\r\n                        if (willCoercionThrow(value)) {\r\n                            error(\"The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.\", propName, typeName(value));\r\n                            return testStringCoercion(value);\r\n                        }\r\n                    }\r\n                }\r\n                function checkCSSPropertyStringCoercion(value, propName) {\r\n                    {\r\n                        if (willCoercionThrow(value)) {\r\n                            error(\"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.\", propName, typeName(value));\r\n                            return testStringCoercion(value);\r\n                        }\r\n                    }\r\n                }\r\n                function checkHtmlStringCoercion(value) {\r\n                    {\r\n                        if (willCoercionThrow(value)) {\r\n                            error(\"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\r\n                            return testStringCoercion(value);\r\n                        }\r\n                    }\r\n                }\r\n                function checkFormFieldValueStringCoercion(value) {\r\n                    {\r\n                        if (willCoercionThrow(value)) {\r\n                            error(\"Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.\", typeName(value));\r\n                            return testStringCoercion(value);\r\n                        }\r\n                    }\r\n                }\r\n                var RESERVED = 0;\r\n                var STRING = 1;\r\n                var BOOLEANISH_STRING = 2;\r\n                var BOOLEAN = 3;\r\n                var OVERLOADED_BOOLEAN = 4;\r\n                var NUMERIC = 5;\r\n                var POSITIVE_NUMERIC = 6;\r\n                var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\r\n                var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\r\n                var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\r\n                var illegalAttributeNameCache = {};\r\n                var validatedAttributeNameCache = {};\r\n                function isAttributeNameSafe(attributeName) {\r\n                    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\r\n                        return true;\r\n                    }\r\n                    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\r\n                        return false;\r\n                    }\r\n                    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\r\n                        validatedAttributeNameCache[attributeName] = true;\r\n                        return true;\r\n                    }\r\n                    illegalAttributeNameCache[attributeName] = true;\r\n                    {\r\n                        error(\"Invalid attribute name: `%s`\", attributeName);\r\n                    }\r\n                    return false;\r\n                }\r\n                function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\r\n                    if (propertyInfo !== null) {\r\n                        return propertyInfo.type === RESERVED;\r\n                    }\r\n                    if (isCustomComponentTag) {\r\n                        return false;\r\n                    }\r\n                    if (name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                }\r\n                function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\r\n                    if (propertyInfo !== null && propertyInfo.type === RESERVED) {\r\n                        return false;\r\n                    }\r\n                    switch (typeof value) {\r\n                        case \"function\":\r\n                        case \"symbol\":\r\n                            return true;\r\n                        case \"boolean\": {\r\n                            if (isCustomComponentTag) {\r\n                                return false;\r\n                            }\r\n                            if (propertyInfo !== null) {\r\n                                return !propertyInfo.acceptsBooleans;\r\n                            }\r\n                            else {\r\n                                var prefix3 = name.toLowerCase().slice(0, 5);\r\n                                return prefix3 !== \"data-\" && prefix3 !== \"aria-\";\r\n                            }\r\n                        }\r\n                        default:\r\n                            return false;\r\n                    }\r\n                }\r\n                function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\r\n                    if (value === null || typeof value === \"undefined\") {\r\n                        return true;\r\n                    }\r\n                    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\r\n                        return true;\r\n                    }\r\n                    if (isCustomComponentTag) {\r\n                        return false;\r\n                    }\r\n                    if (propertyInfo !== null) {\r\n                        switch (propertyInfo.type) {\r\n                            case BOOLEAN:\r\n                                return !value;\r\n                            case OVERLOADED_BOOLEAN:\r\n                                return value === false;\r\n                            case NUMERIC:\r\n                                return isNaN(value);\r\n                            case POSITIVE_NUMERIC:\r\n                                return isNaN(value) || value < 1;\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n                function getPropertyInfo(name) {\r\n                    return properties.hasOwnProperty(name) ? properties[name] : null;\r\n                }\r\n                function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {\r\n                    this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\r\n                    this.attributeName = attributeName;\r\n                    this.attributeNamespace = attributeNamespace;\r\n                    this.mustUseProperty = mustUseProperty;\r\n                    this.propertyName = name;\r\n                    this.type = type;\r\n                    this.sanitizeURL = sanitizeURL2;\r\n                    this.removeEmptyString = removeEmptyString;\r\n                }\r\n                var properties = {};\r\n                var reservedProps = [\r\n                    \"children\",\r\n                    \"dangerouslySetInnerHTML\",\r\n                    \"defaultValue\",\r\n                    \"defaultChecked\",\r\n                    \"innerHTML\",\r\n                    \"suppressContentEditableWarning\",\r\n                    \"suppressHydrationWarning\",\r\n                    \"style\"\r\n                ];\r\n                reservedProps.forEach(function (name) {\r\n                    properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);\r\n                });\r\n                [[\"acceptCharset\", \"accept-charset\"], [\"className\", \"class\"], [\"htmlFor\", \"for\"], [\"httpEquiv\", \"http-equiv\"]].forEach(function (_ref) {\r\n                    var name = _ref[0], attributeName = _ref[1];\r\n                    properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\r\n                });\r\n                [\"contentEditable\", \"draggable\", \"spellCheck\", \"value\"].forEach(function (name) {\r\n                    properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);\r\n                });\r\n                [\"autoReverse\", \"externalResourcesRequired\", \"focusable\", \"preserveAlpha\"].forEach(function (name) {\r\n                    properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);\r\n                });\r\n                [\r\n                    \"allowFullScreen\",\r\n                    \"async\",\r\n                    \"autoFocus\",\r\n                    \"autoPlay\",\r\n                    \"controls\",\r\n                    \"default\",\r\n                    \"defer\",\r\n                    \"disabled\",\r\n                    \"disablePictureInPicture\",\r\n                    \"disableRemotePlayback\",\r\n                    \"formNoValidate\",\r\n                    \"hidden\",\r\n                    \"loop\",\r\n                    \"noModule\",\r\n                    \"noValidate\",\r\n                    \"open\",\r\n                    \"playsInline\",\r\n                    \"readOnly\",\r\n                    \"required\",\r\n                    \"reversed\",\r\n                    \"scoped\",\r\n                    \"seamless\",\r\n                    \"itemScope\"\r\n                ].forEach(function (name) {\r\n                    properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);\r\n                });\r\n                [\r\n                    \"checked\",\r\n                    \"multiple\",\r\n                    \"muted\",\r\n                    \"selected\"\r\n                ].forEach(function (name) {\r\n                    properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);\r\n                });\r\n                [\r\n                    \"capture\",\r\n                    \"download\"\r\n                ].forEach(function (name) {\r\n                    properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);\r\n                });\r\n                [\r\n                    \"cols\",\r\n                    \"rows\",\r\n                    \"size\",\r\n                    \"span\"\r\n                ].forEach(function (name) {\r\n                    properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);\r\n                });\r\n                [\"rowSpan\", \"start\"].forEach(function (name) {\r\n                    properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);\r\n                });\r\n                var CAMELIZE = /[\\-\\:]([a-z])/g;\r\n                var capitalize2 = function (token) {\r\n                    return token[1].toUpperCase();\r\n                };\r\n                [\r\n                    \"accent-height\",\r\n                    \"alignment-baseline\",\r\n                    \"arabic-form\",\r\n                    \"baseline-shift\",\r\n                    \"cap-height\",\r\n                    \"clip-path\",\r\n                    \"clip-rule\",\r\n                    \"color-interpolation\",\r\n                    \"color-interpolation-filters\",\r\n                    \"color-profile\",\r\n                    \"color-rendering\",\r\n                    \"dominant-baseline\",\r\n                    \"enable-background\",\r\n                    \"fill-opacity\",\r\n                    \"fill-rule\",\r\n                    \"flood-color\",\r\n                    \"flood-opacity\",\r\n                    \"font-family\",\r\n                    \"font-size\",\r\n                    \"font-size-adjust\",\r\n                    \"font-stretch\",\r\n                    \"font-style\",\r\n                    \"font-variant\",\r\n                    \"font-weight\",\r\n                    \"glyph-name\",\r\n                    \"glyph-orientation-horizontal\",\r\n                    \"glyph-orientation-vertical\",\r\n                    \"horiz-adv-x\",\r\n                    \"horiz-origin-x\",\r\n                    \"image-rendering\",\r\n                    \"letter-spacing\",\r\n                    \"lighting-color\",\r\n                    \"marker-end\",\r\n                    \"marker-mid\",\r\n                    \"marker-start\",\r\n                    \"overline-position\",\r\n                    \"overline-thickness\",\r\n                    \"paint-order\",\r\n                    \"panose-1\",\r\n                    \"pointer-events\",\r\n                    \"rendering-intent\",\r\n                    \"shape-rendering\",\r\n                    \"stop-color\",\r\n                    \"stop-opacity\",\r\n                    \"strikethrough-position\",\r\n                    \"strikethrough-thickness\",\r\n                    \"stroke-dasharray\",\r\n                    \"stroke-dashoffset\",\r\n                    \"stroke-linecap\",\r\n                    \"stroke-linejoin\",\r\n                    \"stroke-miterlimit\",\r\n                    \"stroke-opacity\",\r\n                    \"stroke-width\",\r\n                    \"text-anchor\",\r\n                    \"text-decoration\",\r\n                    \"text-rendering\",\r\n                    \"underline-position\",\r\n                    \"underline-thickness\",\r\n                    \"unicode-bidi\",\r\n                    \"unicode-range\",\r\n                    \"units-per-em\",\r\n                    \"v-alphabetic\",\r\n                    \"v-hanging\",\r\n                    \"v-ideographic\",\r\n                    \"v-mathematical\",\r\n                    \"vector-effect\",\r\n                    \"vert-adv-y\",\r\n                    \"vert-origin-x\",\r\n                    \"vert-origin-y\",\r\n                    \"word-spacing\",\r\n                    \"writing-mode\",\r\n                    \"xmlns:xlink\",\r\n                    \"x-height\"\r\n                ].forEach(function (attributeName) {\r\n                    var name = attributeName.replace(CAMELIZE, capitalize2);\r\n                    properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\r\n                });\r\n                [\r\n                    \"xlink:actuate\",\r\n                    \"xlink:arcrole\",\r\n                    \"xlink:role\",\r\n                    \"xlink:show\",\r\n                    \"xlink:title\",\r\n                    \"xlink:type\"\r\n                ].forEach(function (attributeName) {\r\n                    var name = attributeName.replace(CAMELIZE, capitalize2);\r\n                    properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/1999/xlink\", false, false);\r\n                });\r\n                [\r\n                    \"xml:base\",\r\n                    \"xml:lang\",\r\n                    \"xml:space\"\r\n                ].forEach(function (attributeName) {\r\n                    var name = attributeName.replace(CAMELIZE, capitalize2);\r\n                    properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/XML/1998/namespace\", false, false);\r\n                });\r\n                [\"tabIndex\", \"crossOrigin\"].forEach(function (attributeName) {\r\n                    properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);\r\n                });\r\n                var xlinkHref = \"xlinkHref\";\r\n                properties[xlinkHref] = new PropertyInfoRecord(\"xlinkHref\", STRING, false, \"xlink:href\", \"http://www.w3.org/1999/xlink\", true, false);\r\n                [\"src\", \"href\", \"action\", \"formAction\"].forEach(function (attributeName) {\r\n                    properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);\r\n                });\r\n                var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\r\n                var didWarn = false;\r\n                function sanitizeURL(url) {\r\n                    {\r\n                        if (!didWarn && isJavaScriptProtocol.test(url)) {\r\n                            didWarn = true;\r\n                            error(\"A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(url));\r\n                        }\r\n                    }\r\n                }\r\n                function getValueForProperty(node, name, expected, propertyInfo) {\r\n                    {\r\n                        if (propertyInfo.mustUseProperty) {\r\n                            var propertyName = propertyInfo.propertyName;\r\n                            return node[propertyName];\r\n                        }\r\n                        else {\r\n                            {\r\n                                checkAttributeStringCoercion(expected, name);\r\n                            }\r\n                            if (propertyInfo.sanitizeURL) {\r\n                                sanitizeURL(\"\" + expected);\r\n                            }\r\n                            var attributeName = propertyInfo.attributeName;\r\n                            var stringValue = null;\r\n                            if (propertyInfo.type === OVERLOADED_BOOLEAN) {\r\n                                if (node.hasAttribute(attributeName)) {\r\n                                    var value = node.getAttribute(attributeName);\r\n                                    if (value === \"\") {\r\n                                        return true;\r\n                                    }\r\n                                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\r\n                                        return value;\r\n                                    }\r\n                                    if (value === \"\" + expected) {\r\n                                        return expected;\r\n                                    }\r\n                                    return value;\r\n                                }\r\n                            }\r\n                            else if (node.hasAttribute(attributeName)) {\r\n                                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\r\n                                    return node.getAttribute(attributeName);\r\n                                }\r\n                                if (propertyInfo.type === BOOLEAN) {\r\n                                    return expected;\r\n                                }\r\n                                stringValue = node.getAttribute(attributeName);\r\n                            }\r\n                            if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\r\n                                return stringValue === null ? expected : stringValue;\r\n                            }\r\n                            else if (stringValue === \"\" + expected) {\r\n                                return expected;\r\n                            }\r\n                            else {\r\n                                return stringValue;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function getValueForAttribute(node, name, expected) {\r\n                    {\r\n                        if (!isAttributeNameSafe(name)) {\r\n                            return;\r\n                        }\r\n                        if (!node.hasAttribute(name)) {\r\n                            return expected === void 0 ? void 0 : null;\r\n                        }\r\n                        var value = node.getAttribute(name);\r\n                        {\r\n                            checkAttributeStringCoercion(expected, name);\r\n                        }\r\n                        if (value === \"\" + expected) {\r\n                            return expected;\r\n                        }\r\n                        return value;\r\n                    }\r\n                }\r\n                function setValueForProperty(node, name, value, isCustomComponentTag) {\r\n                    var propertyInfo = getPropertyInfo(name);\r\n                    if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\r\n                        return;\r\n                    }\r\n                    if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\r\n                        value = null;\r\n                    }\r\n                    if (isCustomComponentTag || propertyInfo === null) {\r\n                        if (isAttributeNameSafe(name)) {\r\n                            var _attributeName = name;\r\n                            if (value === null) {\r\n                                node.removeAttribute(_attributeName);\r\n                            }\r\n                            else {\r\n                                {\r\n                                    checkAttributeStringCoercion(value, name);\r\n                                }\r\n                                node.setAttribute(_attributeName, \"\" + value);\r\n                            }\r\n                        }\r\n                        return;\r\n                    }\r\n                    var mustUseProperty = propertyInfo.mustUseProperty;\r\n                    if (mustUseProperty) {\r\n                        var propertyName = propertyInfo.propertyName;\r\n                        if (value === null) {\r\n                            var type = propertyInfo.type;\r\n                            node[propertyName] = type === BOOLEAN ? false : \"\";\r\n                        }\r\n                        else {\r\n                            node[propertyName] = value;\r\n                        }\r\n                        return;\r\n                    }\r\n                    var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;\r\n                    if (value === null) {\r\n                        node.removeAttribute(attributeName);\r\n                    }\r\n                    else {\r\n                        var _type = propertyInfo.type;\r\n                        var attributeValue;\r\n                        if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\r\n                            attributeValue = \"\";\r\n                        }\r\n                        else {\r\n                            {\r\n                                {\r\n                                    checkAttributeStringCoercion(value, attributeName);\r\n                                }\r\n                                attributeValue = \"\" + value;\r\n                            }\r\n                            if (propertyInfo.sanitizeURL) {\r\n                                sanitizeURL(attributeValue.toString());\r\n                            }\r\n                        }\r\n                        if (attributeNamespace) {\r\n                            node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\r\n                        }\r\n                        else {\r\n                            node.setAttribute(attributeName, attributeValue);\r\n                        }\r\n                    }\r\n                }\r\n                var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\r\n                var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\r\n                var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\r\n                var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\r\n                var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\r\n                var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\r\n                var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\r\n                var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\r\n                var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\r\n                var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\r\n                var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\r\n                var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\r\n                var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\r\n                var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\r\n                var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\r\n                var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\r\n                var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\r\n                var REACT_TRACING_MARKER_TYPE = Symbol.for(\"react.tracing_marker\");\r\n                var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\r\n                var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\r\n                function getIteratorFn(maybeIterable) {\r\n                    if (maybeIterable === null || typeof maybeIterable !== \"object\") {\r\n                        return null;\r\n                    }\r\n                    var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\r\n                    if (typeof maybeIterator === \"function\") {\r\n                        return maybeIterator;\r\n                    }\r\n                    return null;\r\n                }\r\n                var assign = Object.assign;\r\n                var disabledDepth = 0;\r\n                var prevLog;\r\n                var prevInfo;\r\n                var prevWarn;\r\n                var prevError;\r\n                var prevGroup;\r\n                var prevGroupCollapsed;\r\n                var prevGroupEnd;\r\n                function disabledLog() {\r\n                }\r\n                disabledLog.__reactDisabledLog = true;\r\n                function disableLogs() {\r\n                    {\r\n                        if (disabledDepth === 0) {\r\n                            prevLog = console.log;\r\n                            prevInfo = console.info;\r\n                            prevWarn = console.warn;\r\n                            prevError = console.error;\r\n                            prevGroup = console.group;\r\n                            prevGroupCollapsed = console.groupCollapsed;\r\n                            prevGroupEnd = console.groupEnd;\r\n                            var props = {\r\n                                configurable: true,\r\n                                enumerable: true,\r\n                                value: disabledLog,\r\n                                writable: true\r\n                            };\r\n                            Object.defineProperties(console, {\r\n                                info: props,\r\n                                log: props,\r\n                                warn: props,\r\n                                error: props,\r\n                                group: props,\r\n                                groupCollapsed: props,\r\n                                groupEnd: props\r\n                            });\r\n                        }\r\n                        disabledDepth++;\r\n                    }\r\n                }\r\n                function reenableLogs() {\r\n                    {\r\n                        disabledDepth--;\r\n                        if (disabledDepth === 0) {\r\n                            var props = {\r\n                                configurable: true,\r\n                                enumerable: true,\r\n                                writable: true\r\n                            };\r\n                            Object.defineProperties(console, {\r\n                                log: assign({}, props, {\r\n                                    value: prevLog\r\n                                }),\r\n                                info: assign({}, props, {\r\n                                    value: prevInfo\r\n                                }),\r\n                                warn: assign({}, props, {\r\n                                    value: prevWarn\r\n                                }),\r\n                                error: assign({}, props, {\r\n                                    value: prevError\r\n                                }),\r\n                                group: assign({}, props, {\r\n                                    value: prevGroup\r\n                                }),\r\n                                groupCollapsed: assign({}, props, {\r\n                                    value: prevGroupCollapsed\r\n                                }),\r\n                                groupEnd: assign({}, props, {\r\n                                    value: prevGroupEnd\r\n                                })\r\n                            });\r\n                        }\r\n                        if (disabledDepth < 0) {\r\n                            error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n                }\r\n                var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\r\n                var prefix2;\r\n                function describeBuiltInComponentFrame(name, source, ownerFn) {\r\n                    {\r\n                        if (prefix2 === void 0) {\r\n                            try {\r\n                                throw Error();\r\n                            }\r\n                            catch (x2) {\r\n                                var match = x2.stack.trim().match(/\\n( *(at )?)/);\r\n                                prefix2 = match && match[1] || \"\";\r\n                            }\r\n                        }\r\n                        return \"\\n\" + prefix2 + name;\r\n                    }\r\n                }\r\n                var reentry = false;\r\n                var componentFrameCache;\r\n                {\r\n                    var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\r\n                    componentFrameCache = new PossiblyWeakMap();\r\n                }\r\n                function describeNativeComponentFrame(fn2, construct) {\r\n                    if (!fn2 || reentry) {\r\n                        return \"\";\r\n                    }\r\n                    {\r\n                        var frame = componentFrameCache.get(fn2);\r\n                        if (frame !== void 0) {\r\n                            return frame;\r\n                        }\r\n                    }\r\n                    var control;\r\n                    reentry = true;\r\n                    var previousPrepareStackTrace = Error.prepareStackTrace;\r\n                    Error.prepareStackTrace = void 0;\r\n                    var previousDispatcher;\r\n                    {\r\n                        previousDispatcher = ReactCurrentDispatcher.current;\r\n                        ReactCurrentDispatcher.current = null;\r\n                        disableLogs();\r\n                    }\r\n                    try {\r\n                        if (construct) {\r\n                            var Fake_2 = function () {\r\n                                throw Error();\r\n                            };\r\n                            Object.defineProperty(Fake_2.prototype, \"props\", {\r\n                                set: function () {\r\n                                    throw Error();\r\n                                }\r\n                            });\r\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\r\n                                try {\r\n                                    Reflect.construct(Fake_2, []);\r\n                                }\r\n                                catch (x2) {\r\n                                    control = x2;\r\n                                }\r\n                                Reflect.construct(fn2, [], Fake_2);\r\n                            }\r\n                            else {\r\n                                try {\r\n                                    Fake_2.call();\r\n                                }\r\n                                catch (x2) {\r\n                                    control = x2;\r\n                                }\r\n                                fn2.call(Fake_2.prototype);\r\n                            }\r\n                        }\r\n                        else {\r\n                            try {\r\n                                throw Error();\r\n                            }\r\n                            catch (x2) {\r\n                                control = x2;\r\n                            }\r\n                            fn2();\r\n                        }\r\n                    }\r\n                    catch (sample) {\r\n                        if (sample && control && typeof sample.stack === \"string\") {\r\n                            var sampleLines = sample.stack.split(\"\\n\");\r\n                            var controlLines = control.stack.split(\"\\n\");\r\n                            var s2 = sampleLines.length - 1;\r\n                            var c2 = controlLines.length - 1;\r\n                            while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {\r\n                                c2--;\r\n                            }\r\n                            for (; s2 >= 1 && c2 >= 0; s2--, c2--) {\r\n                                if (sampleLines[s2] !== controlLines[c2]) {\r\n                                    if (s2 !== 1 || c2 !== 1) {\r\n                                        do {\r\n                                            s2--;\r\n                                            c2--;\r\n                                            if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {\r\n                                                var _frame = \"\\n\" + sampleLines[s2].replace(\" at new \", \" at \");\r\n                                                if (fn2.displayName && _frame.includes(\"<anonymous>\")) {\r\n                                                    _frame = _frame.replace(\"<anonymous>\", fn2.displayName);\r\n                                                }\r\n                                                {\r\n                                                    if (typeof fn2 === \"function\") {\r\n                                                        componentFrameCache.set(fn2, _frame);\r\n                                                    }\r\n                                                }\r\n                                                return _frame;\r\n                                            }\r\n                                        } while (s2 >= 1 && c2 >= 0);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    finally {\r\n                        reentry = false;\r\n                        {\r\n                            ReactCurrentDispatcher.current = previousDispatcher;\r\n                            reenableLogs();\r\n                        }\r\n                        Error.prepareStackTrace = previousPrepareStackTrace;\r\n                    }\r\n                    var name = fn2 ? fn2.displayName || fn2.name : \"\";\r\n                    var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\r\n                    {\r\n                        if (typeof fn2 === \"function\") {\r\n                            componentFrameCache.set(fn2, syntheticFrame);\r\n                        }\r\n                    }\r\n                    return syntheticFrame;\r\n                }\r\n                function describeClassComponentFrame(ctor, source, ownerFn) {\r\n                    {\r\n                        return describeNativeComponentFrame(ctor, true);\r\n                    }\r\n                }\r\n                function describeFunctionComponentFrame(fn2, source, ownerFn) {\r\n                    {\r\n                        return describeNativeComponentFrame(fn2, false);\r\n                    }\r\n                }\r\n                function shouldConstruct(Component) {\r\n                    var prototype = Component.prototype;\r\n                    return !!(prototype && prototype.isReactComponent);\r\n                }\r\n                function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\r\n                    if (type == null) {\r\n                        return \"\";\r\n                    }\r\n                    if (typeof type === \"function\") {\r\n                        {\r\n                            return describeNativeComponentFrame(type, shouldConstruct(type));\r\n                        }\r\n                    }\r\n                    if (typeof type === \"string\") {\r\n                        return describeBuiltInComponentFrame(type);\r\n                    }\r\n                    switch (type) {\r\n                        case REACT_SUSPENSE_TYPE:\r\n                            return describeBuiltInComponentFrame(\"Suspense\");\r\n                        case REACT_SUSPENSE_LIST_TYPE:\r\n                            return describeBuiltInComponentFrame(\"SuspenseList\");\r\n                    }\r\n                    if (typeof type === \"object\") {\r\n                        switch (type.$$typeof) {\r\n                            case REACT_FORWARD_REF_TYPE:\r\n                                return describeFunctionComponentFrame(type.render);\r\n                            case REACT_MEMO_TYPE:\r\n                                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\r\n                            case REACT_LAZY_TYPE: {\r\n                                var lazyComponent = type;\r\n                                var payload = lazyComponent._payload;\r\n                                var init = lazyComponent._init;\r\n                                try {\r\n                                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\r\n                                }\r\n                                catch (x2) {\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    return \"\";\r\n                }\r\n                function describeFiber(fiber) {\r\n                    var owner = fiber._debugOwner ? fiber._debugOwner.type : null;\r\n                    var source = fiber._debugSource;\r\n                    switch (fiber.tag) {\r\n                        case HostComponent:\r\n                            return describeBuiltInComponentFrame(fiber.type);\r\n                        case LazyComponent:\r\n                            return describeBuiltInComponentFrame(\"Lazy\");\r\n                        case SuspenseComponent:\r\n                            return describeBuiltInComponentFrame(\"Suspense\");\r\n                        case SuspenseListComponent:\r\n                            return describeBuiltInComponentFrame(\"SuspenseList\");\r\n                        case FunctionComponent:\r\n                        case IndeterminateComponent:\r\n                        case SimpleMemoComponent:\r\n                            return describeFunctionComponentFrame(fiber.type);\r\n                        case ForwardRef:\r\n                            return describeFunctionComponentFrame(fiber.type.render);\r\n                        case ClassComponent:\r\n                            return describeClassComponentFrame(fiber.type);\r\n                        default:\r\n                            return \"\";\r\n                    }\r\n                }\r\n                function getStackByFiberInDevAndProd(workInProgress2) {\r\n                    try {\r\n                        var info = \"\";\r\n                        var node = workInProgress2;\r\n                        do {\r\n                            info += describeFiber(node);\r\n                            node = node.return;\r\n                        } while (node);\r\n                        return info;\r\n                    }\r\n                    catch (x2) {\r\n                        return \"\\nError generating stack: \" + x2.message + \"\\n\" + x2.stack;\r\n                    }\r\n                }\r\n                function getWrappedName(outerType, innerType, wrapperName) {\r\n                    var displayName = outerType.displayName;\r\n                    if (displayName) {\r\n                        return displayName;\r\n                    }\r\n                    var functionName = innerType.displayName || innerType.name || \"\";\r\n                    return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\r\n                }\r\n                function getContextName(type) {\r\n                    return type.displayName || \"Context\";\r\n                }\r\n                function getComponentNameFromType(type) {\r\n                    if (type == null) {\r\n                        return null;\r\n                    }\r\n                    {\r\n                        if (typeof type.tag === \"number\") {\r\n                            error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n                    if (typeof type === \"function\") {\r\n                        return type.displayName || type.name || null;\r\n                    }\r\n                    if (typeof type === \"string\") {\r\n                        return type;\r\n                    }\r\n                    switch (type) {\r\n                        case REACT_FRAGMENT_TYPE:\r\n                            return \"Fragment\";\r\n                        case REACT_PORTAL_TYPE:\r\n                            return \"Portal\";\r\n                        case REACT_PROFILER_TYPE:\r\n                            return \"Profiler\";\r\n                        case REACT_STRICT_MODE_TYPE:\r\n                            return \"StrictMode\";\r\n                        case REACT_SUSPENSE_TYPE:\r\n                            return \"Suspense\";\r\n                        case REACT_SUSPENSE_LIST_TYPE:\r\n                            return \"SuspenseList\";\r\n                    }\r\n                    if (typeof type === \"object\") {\r\n                        switch (type.$$typeof) {\r\n                            case REACT_CONTEXT_TYPE:\r\n                                var context = type;\r\n                                return getContextName(context) + \".Consumer\";\r\n                            case REACT_PROVIDER_TYPE:\r\n                                var provider = type;\r\n                                return getContextName(provider._context) + \".Provider\";\r\n                            case REACT_FORWARD_REF_TYPE:\r\n                                return getWrappedName(type, type.render, \"ForwardRef\");\r\n                            case REACT_MEMO_TYPE:\r\n                                var outerName = type.displayName || null;\r\n                                if (outerName !== null) {\r\n                                    return outerName;\r\n                                }\r\n                                return getComponentNameFromType(type.type) || \"Memo\";\r\n                            case REACT_LAZY_TYPE: {\r\n                                var lazyComponent = type;\r\n                                var payload = lazyComponent._payload;\r\n                                var init = lazyComponent._init;\r\n                                try {\r\n                                    return getComponentNameFromType(init(payload));\r\n                                }\r\n                                catch (x2) {\r\n                                    return null;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n                function getWrappedName$1(outerType, innerType, wrapperName) {\r\n                    var functionName = innerType.displayName || innerType.name || \"\";\r\n                    return outerType.displayName || (functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\r\n                }\r\n                function getContextName$1(type) {\r\n                    return type.displayName || \"Context\";\r\n                }\r\n                function getComponentNameFromFiber(fiber) {\r\n                    var tag = fiber.tag, type = fiber.type;\r\n                    switch (tag) {\r\n                        case CacheComponent:\r\n                            return \"Cache\";\r\n                        case ContextConsumer:\r\n                            var context = type;\r\n                            return getContextName$1(context) + \".Consumer\";\r\n                        case ContextProvider:\r\n                            var provider = type;\r\n                            return getContextName$1(provider._context) + \".Provider\";\r\n                        case DehydratedFragment:\r\n                            return \"DehydratedFragment\";\r\n                        case ForwardRef:\r\n                            return getWrappedName$1(type, type.render, \"ForwardRef\");\r\n                        case Fragment:\r\n                            return \"Fragment\";\r\n                        case HostComponent:\r\n                            return type;\r\n                        case HostPortal:\r\n                            return \"Portal\";\r\n                        case HostRoot:\r\n                            return \"Root\";\r\n                        case HostText:\r\n                            return \"Text\";\r\n                        case LazyComponent:\r\n                            return getComponentNameFromType(type);\r\n                        case Mode:\r\n                            if (type === REACT_STRICT_MODE_TYPE) {\r\n                                return \"StrictMode\";\r\n                            }\r\n                            return \"Mode\";\r\n                        case OffscreenComponent:\r\n                            return \"Offscreen\";\r\n                        case Profiler:\r\n                            return \"Profiler\";\r\n                        case ScopeComponent:\r\n                            return \"Scope\";\r\n                        case SuspenseComponent:\r\n                            return \"Suspense\";\r\n                        case SuspenseListComponent:\r\n                            return \"SuspenseList\";\r\n                        case TracingMarkerComponent:\r\n                            return \"TracingMarker\";\r\n                        case ClassComponent:\r\n                        case FunctionComponent:\r\n                        case IncompleteClassComponent:\r\n                        case IndeterminateComponent:\r\n                        case MemoComponent:\r\n                        case SimpleMemoComponent:\r\n                            if (typeof type === \"function\") {\r\n                                return type.displayName || type.name || null;\r\n                            }\r\n                            if (typeof type === \"string\") {\r\n                                return type;\r\n                            }\r\n                            break;\r\n                    }\r\n                    return null;\r\n                }\r\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\r\n                var current = null;\r\n                var isRendering = false;\r\n                function getCurrentFiberOwnerNameInDevOrNull() {\r\n                    {\r\n                        if (current === null) {\r\n                            return null;\r\n                        }\r\n                        var owner = current._debugOwner;\r\n                        if (owner !== null && typeof owner !== \"undefined\") {\r\n                            return getComponentNameFromFiber(owner);\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n                function getCurrentFiberStackInDev() {\r\n                    {\r\n                        if (current === null) {\r\n                            return \"\";\r\n                        }\r\n                        return getStackByFiberInDevAndProd(current);\r\n                    }\r\n                }\r\n                function resetCurrentFiber() {\r\n                    {\r\n                        ReactDebugCurrentFrame.getCurrentStack = null;\r\n                        current = null;\r\n                        isRendering = false;\r\n                    }\r\n                }\r\n                function setCurrentFiber(fiber) {\r\n                    {\r\n                        ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\r\n                        current = fiber;\r\n                        isRendering = false;\r\n                    }\r\n                }\r\n                function getCurrentFiber() {\r\n                    {\r\n                        return current;\r\n                    }\r\n                }\r\n                function setIsRendering(rendering) {\r\n                    {\r\n                        isRendering = rendering;\r\n                    }\r\n                }\r\n                function toString(value) {\r\n                    return \"\" + value;\r\n                }\r\n                function getToStringValue(value) {\r\n                    switch (typeof value) {\r\n                        case \"boolean\":\r\n                        case \"number\":\r\n                        case \"string\":\r\n                        case \"undefined\":\r\n                            return value;\r\n                        case \"object\":\r\n                            {\r\n                                checkFormFieldValueStringCoercion(value);\r\n                            }\r\n                            return value;\r\n                        default:\r\n                            return \"\";\r\n                    }\r\n                }\r\n                var hasReadOnlyValue = {\r\n                    button: true,\r\n                    checkbox: true,\r\n                    image: true,\r\n                    hidden: true,\r\n                    radio: true,\r\n                    reset: true,\r\n                    submit: true\r\n                };\r\n                function checkControlledValueProps(tagName, props) {\r\n                    {\r\n                        if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\r\n                            error(\"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\");\r\n                        }\r\n                        if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\r\n                            error(\"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\");\r\n                        }\r\n                    }\r\n                }\r\n                function isCheckable(elem) {\r\n                    var type = elem.type;\r\n                    var nodeName = elem.nodeName;\r\n                    return nodeName && nodeName.toLowerCase() === \"input\" && (type === \"checkbox\" || type === \"radio\");\r\n                }\r\n                function getTracker(node) {\r\n                    return node._valueTracker;\r\n                }\r\n                function detachTracker(node) {\r\n                    node._valueTracker = null;\r\n                }\r\n                function getValueFromNode(node) {\r\n                    var value = \"\";\r\n                    if (!node) {\r\n                        return value;\r\n                    }\r\n                    if (isCheckable(node)) {\r\n                        value = node.checked ? \"true\" : \"false\";\r\n                    }\r\n                    else {\r\n                        value = node.value;\r\n                    }\r\n                    return value;\r\n                }\r\n                function trackValueOnNode(node) {\r\n                    var valueField = isCheckable(node) ? \"checked\" : \"value\";\r\n                    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\r\n                    {\r\n                        checkFormFieldValueStringCoercion(node[valueField]);\r\n                    }\r\n                    var currentValue = \"\" + node[valueField];\r\n                    if (node.hasOwnProperty(valueField) || typeof descriptor === \"undefined\" || typeof descriptor.get !== \"function\" || typeof descriptor.set !== \"function\") {\r\n                        return;\r\n                    }\r\n                    var get2 = descriptor.get, set2 = descriptor.set;\r\n                    Object.defineProperty(node, valueField, {\r\n                        configurable: true,\r\n                        get: function () {\r\n                            return get2.call(this);\r\n                        },\r\n                        set: function (value) {\r\n                            {\r\n                                checkFormFieldValueStringCoercion(value);\r\n                            }\r\n                            currentValue = \"\" + value;\r\n                            set2.call(this, value);\r\n                        }\r\n                    });\r\n                    Object.defineProperty(node, valueField, {\r\n                        enumerable: descriptor.enumerable\r\n                    });\r\n                    var tracker = {\r\n                        getValue: function () {\r\n                            return currentValue;\r\n                        },\r\n                        setValue: function (value) {\r\n                            {\r\n                                checkFormFieldValueStringCoercion(value);\r\n                            }\r\n                            currentValue = \"\" + value;\r\n                        },\r\n                        stopTracking: function () {\r\n                            detachTracker(node);\r\n                            delete node[valueField];\r\n                        }\r\n                    };\r\n                    return tracker;\r\n                }\r\n                function track(node) {\r\n                    if (getTracker(node)) {\r\n                        return;\r\n                    }\r\n                    node._valueTracker = trackValueOnNode(node);\r\n                }\r\n                function updateValueIfChanged(node) {\r\n                    if (!node) {\r\n                        return false;\r\n                    }\r\n                    var tracker = getTracker(node);\r\n                    if (!tracker) {\r\n                        return true;\r\n                    }\r\n                    var lastValue = tracker.getValue();\r\n                    var nextValue = getValueFromNode(node);\r\n                    if (nextValue !== lastValue) {\r\n                        tracker.setValue(nextValue);\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                }\r\n                function getActiveElement(doc) {\r\n                    doc = doc || (typeof document !== \"undefined\" ? document : void 0);\r\n                    if (typeof doc === \"undefined\") {\r\n                        return null;\r\n                    }\r\n                    try {\r\n                        return doc.activeElement || doc.body;\r\n                    }\r\n                    catch (e2) {\r\n                        return doc.body;\r\n                    }\r\n                }\r\n                var didWarnValueDefaultValue = false;\r\n                var didWarnCheckedDefaultChecked = false;\r\n                var didWarnControlledToUncontrolled = false;\r\n                var didWarnUncontrolledToControlled = false;\r\n                function isControlled(props) {\r\n                    var usesChecked = props.type === \"checkbox\" || props.type === \"radio\";\r\n                    return usesChecked ? props.checked != null : props.value != null;\r\n                }\r\n                function getHostProps(element, props) {\r\n                    var node = element;\r\n                    var checked = props.checked;\r\n                    var hostProps = assign({}, props, {\r\n                        defaultChecked: void 0,\r\n                        defaultValue: void 0,\r\n                        value: void 0,\r\n                        checked: checked != null ? checked : node._wrapperState.initialChecked\r\n                    });\r\n                    return hostProps;\r\n                }\r\n                function initWrapperState(element, props) {\r\n                    {\r\n                        checkControlledValueProps(\"input\", props);\r\n                        if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {\r\n                            error(\"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type);\r\n                            didWarnCheckedDefaultChecked = true;\r\n                        }\r\n                        if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {\r\n                            error(\"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type);\r\n                            didWarnValueDefaultValue = true;\r\n                        }\r\n                    }\r\n                    var node = element;\r\n                    var defaultValue = props.defaultValue == null ? \"\" : props.defaultValue;\r\n                    node._wrapperState = {\r\n                        initialChecked: props.checked != null ? props.checked : props.defaultChecked,\r\n                        initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\r\n                        controlled: isControlled(props)\r\n                    };\r\n                }\r\n                function updateChecked(element, props) {\r\n                    var node = element;\r\n                    var checked = props.checked;\r\n                    if (checked != null) {\r\n                        setValueForProperty(node, \"checked\", checked, false);\r\n                    }\r\n                }\r\n                function updateWrapper(element, props) {\r\n                    var node = element;\r\n                    {\r\n                        var controlled = isControlled(props);\r\n                        if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\r\n                            error(\"A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components\");\r\n                            didWarnUncontrolledToControlled = true;\r\n                        }\r\n                        if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\r\n                            error(\"A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components\");\r\n                            didWarnControlledToUncontrolled = true;\r\n                        }\r\n                    }\r\n                    updateChecked(element, props);\r\n                    var value = getToStringValue(props.value);\r\n                    var type = props.type;\r\n                    if (value != null) {\r\n                        if (type === \"number\") {\r\n                            if (value === 0 && node.value === \"\" || node.value != value) {\r\n                                node.value = toString(value);\r\n                            }\r\n                        }\r\n                        else if (node.value !== toString(value)) {\r\n                            node.value = toString(value);\r\n                        }\r\n                    }\r\n                    else if (type === \"submit\" || type === \"reset\") {\r\n                        node.removeAttribute(\"value\");\r\n                        return;\r\n                    }\r\n                    {\r\n                        if (props.hasOwnProperty(\"value\")) {\r\n                            setDefaultValue(node, props.type, value);\r\n                        }\r\n                        else if (props.hasOwnProperty(\"defaultValue\")) {\r\n                            setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\r\n                        }\r\n                    }\r\n                    {\r\n                        if (props.checked == null && props.defaultChecked != null) {\r\n                            node.defaultChecked = !!props.defaultChecked;\r\n                        }\r\n                    }\r\n                }\r\n                function postMountWrapper(element, props, isHydrating2) {\r\n                    var node = element;\r\n                    if (props.hasOwnProperty(\"value\") || props.hasOwnProperty(\"defaultValue\")) {\r\n                        var type = props.type;\r\n                        var isButton = type === \"submit\" || type === \"reset\";\r\n                        if (isButton && (props.value === void 0 || props.value === null)) {\r\n                            return;\r\n                        }\r\n                        var initialValue = toString(node._wrapperState.initialValue);\r\n                        if (!isHydrating2) {\r\n                            {\r\n                                if (initialValue !== node.value) {\r\n                                    node.value = initialValue;\r\n                                }\r\n                            }\r\n                        }\r\n                        {\r\n                            node.defaultValue = initialValue;\r\n                        }\r\n                    }\r\n                    var name = node.name;\r\n                    if (name !== \"\") {\r\n                        node.name = \"\";\r\n                    }\r\n                    {\r\n                        node.defaultChecked = !node.defaultChecked;\r\n                        node.defaultChecked = !!node._wrapperState.initialChecked;\r\n                    }\r\n                    if (name !== \"\") {\r\n                        node.name = name;\r\n                    }\r\n                }\r\n                function restoreControlledState(element, props) {\r\n                    var node = element;\r\n                    updateWrapper(node, props);\r\n                    updateNamedCousins(node, props);\r\n                }\r\n                function updateNamedCousins(rootNode, props) {\r\n                    var name = props.name;\r\n                    if (props.type === \"radio\" && name != null) {\r\n                        var queryRoot = rootNode;\r\n                        while (queryRoot.parentNode) {\r\n                            queryRoot = queryRoot.parentNode;\r\n                        }\r\n                        {\r\n                            checkAttributeStringCoercion(name, \"name\");\r\n                        }\r\n                        var group = queryRoot.querySelectorAll(\"input[name=\" + JSON.stringify(\"\" + name) + '][type=\"radio\"]');\r\n                        for (var i2 = 0; i2 < group.length; i2++) {\r\n                            var otherNode = group[i2];\r\n                            if (otherNode === rootNode || otherNode.form !== rootNode.form) {\r\n                                continue;\r\n                            }\r\n                            var otherProps = getFiberCurrentPropsFromNode(otherNode);\r\n                            if (!otherProps) {\r\n                                throw new Error(\"ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.\");\r\n                            }\r\n                            updateValueIfChanged(otherNode);\r\n                            updateWrapper(otherNode, otherProps);\r\n                        }\r\n                    }\r\n                }\r\n                function setDefaultValue(node, type, value) {\r\n                    if (type !== \"number\" || getActiveElement(node.ownerDocument) !== node) {\r\n                        if (value == null) {\r\n                            node.defaultValue = toString(node._wrapperState.initialValue);\r\n                        }\r\n                        else if (node.defaultValue !== toString(value)) {\r\n                            node.defaultValue = toString(value);\r\n                        }\r\n                    }\r\n                }\r\n                var didWarnSelectedSetOnOption = false;\r\n                var didWarnInvalidChild = false;\r\n                var didWarnInvalidInnerHTML = false;\r\n                function validateProps(element, props) {\r\n                    {\r\n                        if (props.value == null) {\r\n                            if (typeof props.children === \"object\" && props.children !== null) {\r\n                                React5.Children.forEach(props.children, function (child) {\r\n                                    if (child == null) {\r\n                                        return;\r\n                                    }\r\n                                    if (typeof child === \"string\" || typeof child === \"number\") {\r\n                                        return;\r\n                                    }\r\n                                    if (!didWarnInvalidChild) {\r\n                                        didWarnInvalidChild = true;\r\n                                        error(\"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\");\r\n                                    }\r\n                                });\r\n                            }\r\n                            else if (props.dangerouslySetInnerHTML != null) {\r\n                                if (!didWarnInvalidInnerHTML) {\r\n                                    didWarnInvalidInnerHTML = true;\r\n                                    error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\");\r\n                                }\r\n                            }\r\n                        }\r\n                        if (props.selected != null && !didWarnSelectedSetOnOption) {\r\n                            error(\"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\");\r\n                            didWarnSelectedSetOnOption = true;\r\n                        }\r\n                    }\r\n                }\r\n                function postMountWrapper$1(element, props) {\r\n                    if (props.value != null) {\r\n                        element.setAttribute(\"value\", toString(getToStringValue(props.value)));\r\n                    }\r\n                }\r\n                var isArrayImpl = Array.isArray;\r\n                function isArray(a2) {\r\n                    return isArrayImpl(a2);\r\n                }\r\n                var didWarnValueDefaultValue$1;\r\n                {\r\n                    didWarnValueDefaultValue$1 = false;\r\n                }\r\n                function getDeclarationErrorAddendum() {\r\n                    var ownerName = getCurrentFiberOwnerNameInDevOrNull();\r\n                    if (ownerName) {\r\n                        return \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\r\n                    }\r\n                    return \"\";\r\n                }\r\n                var valuePropNames = [\"value\", \"defaultValue\"];\r\n                function checkSelectPropTypes(props) {\r\n                    {\r\n                        checkControlledValueProps(\"select\", props);\r\n                        for (var i2 = 0; i2 < valuePropNames.length; i2++) {\r\n                            var propName = valuePropNames[i2];\r\n                            if (props[propName] == null) {\r\n                                continue;\r\n                            }\r\n                            var propNameIsArray = isArray(props[propName]);\r\n                            if (props.multiple && !propNameIsArray) {\r\n                                error(\"The `%s` prop supplied to <select> must be an array if `multiple` is true.%s\", propName, getDeclarationErrorAddendum());\r\n                            }\r\n                            else if (!props.multiple && propNameIsArray) {\r\n                                error(\"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s\", propName, getDeclarationErrorAddendum());\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function updateOptions(node, multiple, propValue, setDefaultSelected) {\r\n                    var options2 = node.options;\r\n                    if (multiple) {\r\n                        var selectedValues = propValue;\r\n                        var selectedValue = {};\r\n                        for (var i2 = 0; i2 < selectedValues.length; i2++) {\r\n                            selectedValue[\"$\" + selectedValues[i2]] = true;\r\n                        }\r\n                        for (var _i = 0; _i < options2.length; _i++) {\r\n                            var selected = selectedValue.hasOwnProperty(\"$\" + options2[_i].value);\r\n                            if (options2[_i].selected !== selected) {\r\n                                options2[_i].selected = selected;\r\n                            }\r\n                            if (selected && setDefaultSelected) {\r\n                                options2[_i].defaultSelected = true;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        var _selectedValue = toString(getToStringValue(propValue));\r\n                        var defaultSelected = null;\r\n                        for (var _i2 = 0; _i2 < options2.length; _i2++) {\r\n                            if (options2[_i2].value === _selectedValue) {\r\n                                options2[_i2].selected = true;\r\n                                if (setDefaultSelected) {\r\n                                    options2[_i2].defaultSelected = true;\r\n                                }\r\n                                return;\r\n                            }\r\n                            if (defaultSelected === null && !options2[_i2].disabled) {\r\n                                defaultSelected = options2[_i2];\r\n                            }\r\n                        }\r\n                        if (defaultSelected !== null) {\r\n                            defaultSelected.selected = true;\r\n                        }\r\n                    }\r\n                }\r\n                function getHostProps$1(element, props) {\r\n                    return assign({}, props, {\r\n                        value: void 0\r\n                    });\r\n                }\r\n                function initWrapperState$1(element, props) {\r\n                    var node = element;\r\n                    {\r\n                        checkSelectPropTypes(props);\r\n                    }\r\n                    node._wrapperState = {\r\n                        wasMultiple: !!props.multiple\r\n                    };\r\n                    {\r\n                        if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {\r\n                            error(\"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components\");\r\n                            didWarnValueDefaultValue$1 = true;\r\n                        }\r\n                    }\r\n                }\r\n                function postMountWrapper$2(element, props) {\r\n                    var node = element;\r\n                    node.multiple = !!props.multiple;\r\n                    var value = props.value;\r\n                    if (value != null) {\r\n                        updateOptions(node, !!props.multiple, value, false);\r\n                    }\r\n                    else if (props.defaultValue != null) {\r\n                        updateOptions(node, !!props.multiple, props.defaultValue, true);\r\n                    }\r\n                }\r\n                function postUpdateWrapper(element, props) {\r\n                    var node = element;\r\n                    var wasMultiple = node._wrapperState.wasMultiple;\r\n                    node._wrapperState.wasMultiple = !!props.multiple;\r\n                    var value = props.value;\r\n                    if (value != null) {\r\n                        updateOptions(node, !!props.multiple, value, false);\r\n                    }\r\n                    else if (wasMultiple !== !!props.multiple) {\r\n                        if (props.defaultValue != null) {\r\n                            updateOptions(node, !!props.multiple, props.defaultValue, true);\r\n                        }\r\n                        else {\r\n                            updateOptions(node, !!props.multiple, props.multiple ? [] : \"\", false);\r\n                        }\r\n                    }\r\n                }\r\n                function restoreControlledState$1(element, props) {\r\n                    var node = element;\r\n                    var value = props.value;\r\n                    if (value != null) {\r\n                        updateOptions(node, !!props.multiple, value, false);\r\n                    }\r\n                }\r\n                var didWarnValDefaultVal = false;\r\n                function getHostProps$2(element, props) {\r\n                    var node = element;\r\n                    if (props.dangerouslySetInnerHTML != null) {\r\n                        throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\r\n                    }\r\n                    var hostProps = assign({}, props, {\r\n                        value: void 0,\r\n                        defaultValue: void 0,\r\n                        children: toString(node._wrapperState.initialValue)\r\n                    });\r\n                    return hostProps;\r\n                }\r\n                function initWrapperState$2(element, props) {\r\n                    var node = element;\r\n                    {\r\n                        checkControlledValueProps(\"textarea\", props);\r\n                        if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {\r\n                            error(\"%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\");\r\n                            didWarnValDefaultVal = true;\r\n                        }\r\n                    }\r\n                    var initialValue = props.value;\r\n                    if (initialValue == null) {\r\n                        var children = props.children, defaultValue = props.defaultValue;\r\n                        if (children != null) {\r\n                            {\r\n                                error(\"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\");\r\n                            }\r\n                            {\r\n                                if (defaultValue != null) {\r\n                                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\r\n                                }\r\n                                if (isArray(children)) {\r\n                                    if (children.length > 1) {\r\n                                        throw new Error(\"<textarea> can only have at most one child.\");\r\n                                    }\r\n                                    children = children[0];\r\n                                }\r\n                                defaultValue = children;\r\n                            }\r\n                        }\r\n                        if (defaultValue == null) {\r\n                            defaultValue = \"\";\r\n                        }\r\n                        initialValue = defaultValue;\r\n                    }\r\n                    node._wrapperState = {\r\n                        initialValue: getToStringValue(initialValue)\r\n                    };\r\n                }\r\n                function updateWrapper$1(element, props) {\r\n                    var node = element;\r\n                    var value = getToStringValue(props.value);\r\n                    var defaultValue = getToStringValue(props.defaultValue);\r\n                    if (value != null) {\r\n                        var newValue = toString(value);\r\n                        if (newValue !== node.value) {\r\n                            node.value = newValue;\r\n                        }\r\n                        if (props.defaultValue == null && node.defaultValue !== newValue) {\r\n                            node.defaultValue = newValue;\r\n                        }\r\n                    }\r\n                    if (defaultValue != null) {\r\n                        node.defaultValue = toString(defaultValue);\r\n                    }\r\n                }\r\n                function postMountWrapper$3(element, props) {\r\n                    var node = element;\r\n                    var textContent = node.textContent;\r\n                    if (textContent === node._wrapperState.initialValue) {\r\n                        if (textContent !== \"\" && textContent !== null) {\r\n                            node.value = textContent;\r\n                        }\r\n                    }\r\n                }\r\n                function restoreControlledState$2(element, props) {\r\n                    updateWrapper$1(element, props);\r\n                }\r\n                var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\r\n                var MATH_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\r\n                var SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\r\n                function getIntrinsicNamespace(type) {\r\n                    switch (type) {\r\n                        case \"svg\":\r\n                            return SVG_NAMESPACE;\r\n                        case \"math\":\r\n                            return MATH_NAMESPACE;\r\n                        default:\r\n                            return HTML_NAMESPACE;\r\n                    }\r\n                }\r\n                function getChildNamespace(parentNamespace, type) {\r\n                    if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {\r\n                        return getIntrinsicNamespace(type);\r\n                    }\r\n                    if (parentNamespace === SVG_NAMESPACE && type === \"foreignObject\") {\r\n                        return HTML_NAMESPACE;\r\n                    }\r\n                    return parentNamespace;\r\n                }\r\n                var createMicrosoftUnsafeLocalFunction = function (func) {\r\n                    if (typeof MSApp !== \"undefined\" && MSApp.execUnsafeLocalFunction) {\r\n                        return function (arg0, arg1, arg2, arg3) {\r\n                            MSApp.execUnsafeLocalFunction(function () {\r\n                                return func(arg0, arg1, arg2, arg3);\r\n                            });\r\n                        };\r\n                    }\r\n                    else {\r\n                        return func;\r\n                    }\r\n                };\r\n                var reusableSVGContainer;\r\n                var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\r\n                    if (node.namespaceURI === SVG_NAMESPACE) {\r\n                        if (!(\"innerHTML\" in node)) {\r\n                            reusableSVGContainer = reusableSVGContainer || document.createElement(\"div\");\r\n                            reusableSVGContainer.innerHTML = \"<svg>\" + html.valueOf().toString() + \"</svg>\";\r\n                            var svgNode = reusableSVGContainer.firstChild;\r\n                            while (node.firstChild) {\r\n                                node.removeChild(node.firstChild);\r\n                            }\r\n                            while (svgNode.firstChild) {\r\n                                node.appendChild(svgNode.firstChild);\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                    node.innerHTML = html;\r\n                });\r\n                var ELEMENT_NODE = 1;\r\n                var TEXT_NODE = 3;\r\n                var COMMENT_NODE = 8;\r\n                var DOCUMENT_NODE = 9;\r\n                var DOCUMENT_FRAGMENT_NODE = 11;\r\n                var setTextContent = function (node, text) {\r\n                    if (text) {\r\n                        var firstChild = node.firstChild;\r\n                        if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\r\n                            firstChild.nodeValue = text;\r\n                            return;\r\n                        }\r\n                    }\r\n                    node.textContent = text;\r\n                };\r\n                var shorthandToLonghand = {\r\n                    animation: [\"animationDelay\", \"animationDirection\", \"animationDuration\", \"animationFillMode\", \"animationIterationCount\", \"animationName\", \"animationPlayState\", \"animationTimingFunction\"],\r\n                    background: [\"backgroundAttachment\", \"backgroundClip\", \"backgroundColor\", \"backgroundImage\", \"backgroundOrigin\", \"backgroundPositionX\", \"backgroundPositionY\", \"backgroundRepeat\", \"backgroundSize\"],\r\n                    backgroundPosition: [\"backgroundPositionX\", \"backgroundPositionY\"],\r\n                    border: [\"borderBottomColor\", \"borderBottomStyle\", \"borderBottomWidth\", \"borderImageOutset\", \"borderImageRepeat\", \"borderImageSlice\", \"borderImageSource\", \"borderImageWidth\", \"borderLeftColor\", \"borderLeftStyle\", \"borderLeftWidth\", \"borderRightColor\", \"borderRightStyle\", \"borderRightWidth\", \"borderTopColor\", \"borderTopStyle\", \"borderTopWidth\"],\r\n                    borderBlockEnd: [\"borderBlockEndColor\", \"borderBlockEndStyle\", \"borderBlockEndWidth\"],\r\n                    borderBlockStart: [\"borderBlockStartColor\", \"borderBlockStartStyle\", \"borderBlockStartWidth\"],\r\n                    borderBottom: [\"borderBottomColor\", \"borderBottomStyle\", \"borderBottomWidth\"],\r\n                    borderColor: [\"borderBottomColor\", \"borderLeftColor\", \"borderRightColor\", \"borderTopColor\"],\r\n                    borderImage: [\"borderImageOutset\", \"borderImageRepeat\", \"borderImageSlice\", \"borderImageSource\", \"borderImageWidth\"],\r\n                    borderInlineEnd: [\"borderInlineEndColor\", \"borderInlineEndStyle\", \"borderInlineEndWidth\"],\r\n                    borderInlineStart: [\"borderInlineStartColor\", \"borderInlineStartStyle\", \"borderInlineStartWidth\"],\r\n                    borderLeft: [\"borderLeftColor\", \"borderLeftStyle\", \"borderLeftWidth\"],\r\n                    borderRadius: [\"borderBottomLeftRadius\", \"borderBottomRightRadius\", \"borderTopLeftRadius\", \"borderTopRightRadius\"],\r\n                    borderRight: [\"borderRightColor\", \"borderRightStyle\", \"borderRightWidth\"],\r\n                    borderStyle: [\"borderBottomStyle\", \"borderLeftStyle\", \"borderRightStyle\", \"borderTopStyle\"],\r\n                    borderTop: [\"borderTopColor\", \"borderTopStyle\", \"borderTopWidth\"],\r\n                    borderWidth: [\"borderBottomWidth\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\"],\r\n                    columnRule: [\"columnRuleColor\", \"columnRuleStyle\", \"columnRuleWidth\"],\r\n                    columns: [\"columnCount\", \"columnWidth\"],\r\n                    flex: [\"flexBasis\", \"flexGrow\", \"flexShrink\"],\r\n                    flexFlow: [\"flexDirection\", \"flexWrap\"],\r\n                    font: [\"fontFamily\", \"fontFeatureSettings\", \"fontKerning\", \"fontLanguageOverride\", \"fontSize\", \"fontSizeAdjust\", \"fontStretch\", \"fontStyle\", \"fontVariant\", \"fontVariantAlternates\", \"fontVariantCaps\", \"fontVariantEastAsian\", \"fontVariantLigatures\", \"fontVariantNumeric\", \"fontVariantPosition\", \"fontWeight\", \"lineHeight\"],\r\n                    fontVariant: [\"fontVariantAlternates\", \"fontVariantCaps\", \"fontVariantEastAsian\", \"fontVariantLigatures\", \"fontVariantNumeric\", \"fontVariantPosition\"],\r\n                    gap: [\"columnGap\", \"rowGap\"],\r\n                    grid: [\"gridAutoColumns\", \"gridAutoFlow\", \"gridAutoRows\", \"gridTemplateAreas\", \"gridTemplateColumns\", \"gridTemplateRows\"],\r\n                    gridArea: [\"gridColumnEnd\", \"gridColumnStart\", \"gridRowEnd\", \"gridRowStart\"],\r\n                    gridColumn: [\"gridColumnEnd\", \"gridColumnStart\"],\r\n                    gridColumnGap: [\"columnGap\"],\r\n                    gridGap: [\"columnGap\", \"rowGap\"],\r\n                    gridRow: [\"gridRowEnd\", \"gridRowStart\"],\r\n                    gridRowGap: [\"rowGap\"],\r\n                    gridTemplate: [\"gridTemplateAreas\", \"gridTemplateColumns\", \"gridTemplateRows\"],\r\n                    listStyle: [\"listStyleImage\", \"listStylePosition\", \"listStyleType\"],\r\n                    margin: [\"marginBottom\", \"marginLeft\", \"marginRight\", \"marginTop\"],\r\n                    marker: [\"markerEnd\", \"markerMid\", \"markerStart\"],\r\n                    mask: [\"maskClip\", \"maskComposite\", \"maskImage\", \"maskMode\", \"maskOrigin\", \"maskPositionX\", \"maskPositionY\", \"maskRepeat\", \"maskSize\"],\r\n                    maskPosition: [\"maskPositionX\", \"maskPositionY\"],\r\n                    outline: [\"outlineColor\", \"outlineStyle\", \"outlineWidth\"],\r\n                    overflow: [\"overflowX\", \"overflowY\"],\r\n                    padding: [\"paddingBottom\", \"paddingLeft\", \"paddingRight\", \"paddingTop\"],\r\n                    placeContent: [\"alignContent\", \"justifyContent\"],\r\n                    placeItems: [\"alignItems\", \"justifyItems\"],\r\n                    placeSelf: [\"alignSelf\", \"justifySelf\"],\r\n                    textDecoration: [\"textDecorationColor\", \"textDecorationLine\", \"textDecorationStyle\"],\r\n                    textEmphasis: [\"textEmphasisColor\", \"textEmphasisStyle\"],\r\n                    transition: [\"transitionDelay\", \"transitionDuration\", \"transitionProperty\", \"transitionTimingFunction\"],\r\n                    wordWrap: [\"overflowWrap\"]\r\n                };\r\n                var isUnitlessNumber = {\r\n                    animationIterationCount: true,\r\n                    aspectRatio: true,\r\n                    borderImageOutset: true,\r\n                    borderImageSlice: true,\r\n                    borderImageWidth: true,\r\n                    boxFlex: true,\r\n                    boxFlexGroup: true,\r\n                    boxOrdinalGroup: true,\r\n                    columnCount: true,\r\n                    columns: true,\r\n                    flex: true,\r\n                    flexGrow: true,\r\n                    flexPositive: true,\r\n                    flexShrink: true,\r\n                    flexNegative: true,\r\n                    flexOrder: true,\r\n                    gridArea: true,\r\n                    gridRow: true,\r\n                    gridRowEnd: true,\r\n                    gridRowSpan: true,\r\n                    gridRowStart: true,\r\n                    gridColumn: true,\r\n                    gridColumnEnd: true,\r\n                    gridColumnSpan: true,\r\n                    gridColumnStart: true,\r\n                    fontWeight: true,\r\n                    lineClamp: true,\r\n                    lineHeight: true,\r\n                    opacity: true,\r\n                    order: true,\r\n                    orphans: true,\r\n                    tabSize: true,\r\n                    widows: true,\r\n                    zIndex: true,\r\n                    zoom: true,\r\n                    fillOpacity: true,\r\n                    floodOpacity: true,\r\n                    stopOpacity: true,\r\n                    strokeDasharray: true,\r\n                    strokeDashoffset: true,\r\n                    strokeMiterlimit: true,\r\n                    strokeOpacity: true,\r\n                    strokeWidth: true\r\n                };\r\n                function prefixKey(prefix3, key) {\r\n                    return prefix3 + key.charAt(0).toUpperCase() + key.substring(1);\r\n                }\r\n                var prefixes = [\"Webkit\", \"ms\", \"Moz\", \"O\"];\r\n                Object.keys(isUnitlessNumber).forEach(function (prop) {\r\n                    prefixes.forEach(function (prefix3) {\r\n                        isUnitlessNumber[prefixKey(prefix3, prop)] = isUnitlessNumber[prop];\r\n                    });\r\n                });\r\n                function dangerousStyleValue(name, value, isCustomProperty) {\r\n                    var isEmpty = value == null || typeof value === \"boolean\" || value === \"\";\r\n                    if (isEmpty) {\r\n                        return \"\";\r\n                    }\r\n                    if (!isCustomProperty && typeof value === \"number\" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\r\n                        return value + \"px\";\r\n                    }\r\n                    {\r\n                        checkCSSPropertyStringCoercion(value, name);\r\n                    }\r\n                    return (\"\" + value).trim();\r\n                }\r\n                var uppercasePattern = /([A-Z])/g;\r\n                var msPattern = /^ms-/;\r\n                function hyphenateStyleName(name) {\r\n                    return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\r\n                }\r\n                var warnValidStyle = function () {\r\n                };\r\n                {\r\n                    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\r\n                    var msPattern$1 = /^-ms-/;\r\n                    var hyphenPattern = /-(.)/g;\r\n                    var badStyleValueWithSemicolonPattern = /;\\s*$/;\r\n                    var warnedStyleNames = {};\r\n                    var warnedStyleValues = {};\r\n                    var warnedForNaNValue = false;\r\n                    var warnedForInfinityValue = false;\r\n                    var camelize = function (string) {\r\n                        return string.replace(hyphenPattern, function (_2, character) {\r\n                            return character.toUpperCase();\r\n                        });\r\n                    };\r\n                    var warnHyphenatedStyleName = function (name) {\r\n                        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\r\n                            return;\r\n                        }\r\n                        warnedStyleNames[name] = true;\r\n                        error(\"Unsupported style property %s. Did you mean %s?\", name, camelize(name.replace(msPattern$1, \"ms-\")));\r\n                    };\r\n                    var warnBadVendoredStyleName = function (name) {\r\n                        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\r\n                            return;\r\n                        }\r\n                        warnedStyleNames[name] = true;\r\n                        error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\r\n                    };\r\n                    var warnStyleValueWithSemicolon = function (name, value) {\r\n                        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\r\n                            return;\r\n                        }\r\n                        warnedStyleValues[value] = true;\r\n                        error(\"Style property values shouldn't contain a semicolon. Try \\\"%s: %s\\\" instead.\", name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\r\n                    };\r\n                    var warnStyleValueIsNaN = function (name, value) {\r\n                        if (warnedForNaNValue) {\r\n                            return;\r\n                        }\r\n                        warnedForNaNValue = true;\r\n                        error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\r\n                    };\r\n                    var warnStyleValueIsInfinity = function (name, value) {\r\n                        if (warnedForInfinityValue) {\r\n                            return;\r\n                        }\r\n                        warnedForInfinityValue = true;\r\n                        error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\r\n                    };\r\n                    warnValidStyle = function (name, value) {\r\n                        if (name.indexOf(\"-\") > -1) {\r\n                            warnHyphenatedStyleName(name);\r\n                        }\r\n                        else if (badVendoredStyleNamePattern.test(name)) {\r\n                            warnBadVendoredStyleName(name);\r\n                        }\r\n                        else if (badStyleValueWithSemicolonPattern.test(value)) {\r\n                            warnStyleValueWithSemicolon(name, value);\r\n                        }\r\n                        if (typeof value === \"number\") {\r\n                            if (isNaN(value)) {\r\n                                warnStyleValueIsNaN(name, value);\r\n                            }\r\n                            else if (!isFinite(value)) {\r\n                                warnStyleValueIsInfinity(name, value);\r\n                            }\r\n                        }\r\n                    };\r\n                }\r\n                var warnValidStyle$1 = warnValidStyle;\r\n                function createDangerousStringForStyles(styles) {\r\n                    {\r\n                        var serialized = \"\";\r\n                        var delimiter = \"\";\r\n                        for (var styleName in styles) {\r\n                            if (!styles.hasOwnProperty(styleName)) {\r\n                                continue;\r\n                            }\r\n                            var styleValue = styles[styleName];\r\n                            if (styleValue != null) {\r\n                                var isCustomProperty = styleName.indexOf(\"--\") === 0;\r\n                                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + \":\";\r\n                                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\r\n                                delimiter = \";\";\r\n                            }\r\n                        }\r\n                        return serialized || null;\r\n                    }\r\n                }\r\n                function setValueForStyles(node, styles) {\r\n                    var style2 = node.style;\r\n                    for (var styleName in styles) {\r\n                        if (!styles.hasOwnProperty(styleName)) {\r\n                            continue;\r\n                        }\r\n                        var isCustomProperty = styleName.indexOf(\"--\") === 0;\r\n                        {\r\n                            if (!isCustomProperty) {\r\n                                warnValidStyle$1(styleName, styles[styleName]);\r\n                            }\r\n                        }\r\n                        var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\r\n                        if (styleName === \"float\") {\r\n                            styleName = \"cssFloat\";\r\n                        }\r\n                        if (isCustomProperty) {\r\n                            style2.setProperty(styleName, styleValue);\r\n                        }\r\n                        else {\r\n                            style2[styleName] = styleValue;\r\n                        }\r\n                    }\r\n                }\r\n                function isValueEmpty(value) {\r\n                    return value == null || typeof value === \"boolean\" || value === \"\";\r\n                }\r\n                function expandShorthandMap(styles) {\r\n                    var expanded = {};\r\n                    for (var key in styles) {\r\n                        var longhands = shorthandToLonghand[key] || [key];\r\n                        for (var i2 = 0; i2 < longhands.length; i2++) {\r\n                            expanded[longhands[i2]] = key;\r\n                        }\r\n                    }\r\n                    return expanded;\r\n                }\r\n                function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {\r\n                    {\r\n                        if (!nextStyles) {\r\n                            return;\r\n                        }\r\n                        var expandedUpdates = expandShorthandMap(styleUpdates);\r\n                        var expandedStyles = expandShorthandMap(nextStyles);\r\n                        var warnedAbout = {};\r\n                        for (var key in expandedUpdates) {\r\n                            var originalKey = expandedUpdates[key];\r\n                            var correctOriginalKey = expandedStyles[key];\r\n                            if (correctOriginalKey && originalKey !== correctOriginalKey) {\r\n                                var warningKey = originalKey + \",\" + correctOriginalKey;\r\n                                if (warnedAbout[warningKey]) {\r\n                                    continue;\r\n                                }\r\n                                warnedAbout[warningKey] = true;\r\n                                error(\"%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.\", isValueEmpty(styleUpdates[originalKey]) ? \"Removing\" : \"Updating\", originalKey, correctOriginalKey);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var omittedCloseTags = {\r\n                    area: true,\r\n                    base: true,\r\n                    br: true,\r\n                    col: true,\r\n                    embed: true,\r\n                    hr: true,\r\n                    img: true,\r\n                    input: true,\r\n                    keygen: true,\r\n                    link: true,\r\n                    meta: true,\r\n                    param: true,\r\n                    source: true,\r\n                    track: true,\r\n                    wbr: true\r\n                };\r\n                var voidElementTags = assign({\r\n                    menuitem: true\r\n                }, omittedCloseTags);\r\n                var HTML = \"__html\";\r\n                function assertValidProps(tag, props) {\r\n                    if (!props) {\r\n                        return;\r\n                    }\r\n                    if (voidElementTags[tag]) {\r\n                        if (props.children != null || props.dangerouslySetInnerHTML != null) {\r\n                            throw new Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\r\n                        }\r\n                    }\r\n                    if (props.dangerouslySetInnerHTML != null) {\r\n                        if (props.children != null) {\r\n                            throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\r\n                        }\r\n                        if (typeof props.dangerouslySetInnerHTML !== \"object\" || !(HTML in props.dangerouslySetInnerHTML)) {\r\n                            throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.\");\r\n                        }\r\n                    }\r\n                    {\r\n                        if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\r\n                            error(\"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\");\r\n                        }\r\n                    }\r\n                    if (props.style != null && typeof props.style !== \"object\") {\r\n                        throw new Error(\"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\");\r\n                    }\r\n                }\r\n                function isCustomComponent(tagName, props) {\r\n                    if (tagName.indexOf(\"-\") === -1) {\r\n                        return typeof props.is === \"string\";\r\n                    }\r\n                    switch (tagName) {\r\n                        case \"annotation-xml\":\r\n                        case \"color-profile\":\r\n                        case \"font-face\":\r\n                        case \"font-face-src\":\r\n                        case \"font-face-uri\":\r\n                        case \"font-face-format\":\r\n                        case \"font-face-name\":\r\n                        case \"missing-glyph\":\r\n                            return false;\r\n                        default:\r\n                            return true;\r\n                    }\r\n                }\r\n                var possibleStandardNames = {\r\n                    accept: \"accept\",\r\n                    acceptcharset: \"acceptCharset\",\r\n                    \"accept-charset\": \"acceptCharset\",\r\n                    accesskey: \"accessKey\",\r\n                    action: \"action\",\r\n                    allowfullscreen: \"allowFullScreen\",\r\n                    alt: \"alt\",\r\n                    as: \"as\",\r\n                    async: \"async\",\r\n                    autocapitalize: \"autoCapitalize\",\r\n                    autocomplete: \"autoComplete\",\r\n                    autocorrect: \"autoCorrect\",\r\n                    autofocus: \"autoFocus\",\r\n                    autoplay: \"autoPlay\",\r\n                    autosave: \"autoSave\",\r\n                    capture: \"capture\",\r\n                    cellpadding: \"cellPadding\",\r\n                    cellspacing: \"cellSpacing\",\r\n                    challenge: \"challenge\",\r\n                    charset: \"charSet\",\r\n                    checked: \"checked\",\r\n                    children: \"children\",\r\n                    cite: \"cite\",\r\n                    class: \"className\",\r\n                    classid: \"classID\",\r\n                    classname: \"className\",\r\n                    cols: \"cols\",\r\n                    colspan: \"colSpan\",\r\n                    content: \"content\",\r\n                    contenteditable: \"contentEditable\",\r\n                    contextmenu: \"contextMenu\",\r\n                    controls: \"controls\",\r\n                    controlslist: \"controlsList\",\r\n                    coords: \"coords\",\r\n                    crossorigin: \"crossOrigin\",\r\n                    dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\r\n                    data: \"data\",\r\n                    datetime: \"dateTime\",\r\n                    default: \"default\",\r\n                    defaultchecked: \"defaultChecked\",\r\n                    defaultvalue: \"defaultValue\",\r\n                    defer: \"defer\",\r\n                    dir: \"dir\",\r\n                    disabled: \"disabled\",\r\n                    disablepictureinpicture: \"disablePictureInPicture\",\r\n                    disableremoteplayback: \"disableRemotePlayback\",\r\n                    download: \"download\",\r\n                    draggable: \"draggable\",\r\n                    enctype: \"encType\",\r\n                    enterkeyhint: \"enterKeyHint\",\r\n                    for: \"htmlFor\",\r\n                    form: \"form\",\r\n                    formmethod: \"formMethod\",\r\n                    formaction: \"formAction\",\r\n                    formenctype: \"formEncType\",\r\n                    formnovalidate: \"formNoValidate\",\r\n                    formtarget: \"formTarget\",\r\n                    frameborder: \"frameBorder\",\r\n                    headers: \"headers\",\r\n                    height: \"height\",\r\n                    hidden: \"hidden\",\r\n                    high: \"high\",\r\n                    href: \"href\",\r\n                    hreflang: \"hrefLang\",\r\n                    htmlfor: \"htmlFor\",\r\n                    httpequiv: \"httpEquiv\",\r\n                    \"http-equiv\": \"httpEquiv\",\r\n                    icon: \"icon\",\r\n                    id: \"id\",\r\n                    imagesizes: \"imageSizes\",\r\n                    imagesrcset: \"imageSrcSet\",\r\n                    innerhtml: \"innerHTML\",\r\n                    inputmode: \"inputMode\",\r\n                    integrity: \"integrity\",\r\n                    is: \"is\",\r\n                    itemid: \"itemID\",\r\n                    itemprop: \"itemProp\",\r\n                    itemref: \"itemRef\",\r\n                    itemscope: \"itemScope\",\r\n                    itemtype: \"itemType\",\r\n                    keyparams: \"keyParams\",\r\n                    keytype: \"keyType\",\r\n                    kind: \"kind\",\r\n                    label: \"label\",\r\n                    lang: \"lang\",\r\n                    list: \"list\",\r\n                    loop: \"loop\",\r\n                    low: \"low\",\r\n                    manifest: \"manifest\",\r\n                    marginwidth: \"marginWidth\",\r\n                    marginheight: \"marginHeight\",\r\n                    max: \"max\",\r\n                    maxlength: \"maxLength\",\r\n                    media: \"media\",\r\n                    mediagroup: \"mediaGroup\",\r\n                    method: \"method\",\r\n                    min: \"min\",\r\n                    minlength: \"minLength\",\r\n                    multiple: \"multiple\",\r\n                    muted: \"muted\",\r\n                    name: \"name\",\r\n                    nomodule: \"noModule\",\r\n                    nonce: \"nonce\",\r\n                    novalidate: \"noValidate\",\r\n                    open: \"open\",\r\n                    optimum: \"optimum\",\r\n                    pattern: \"pattern\",\r\n                    placeholder: \"placeholder\",\r\n                    playsinline: \"playsInline\",\r\n                    poster: \"poster\",\r\n                    preload: \"preload\",\r\n                    profile: \"profile\",\r\n                    radiogroup: \"radioGroup\",\r\n                    readonly: \"readOnly\",\r\n                    referrerpolicy: \"referrerPolicy\",\r\n                    rel: \"rel\",\r\n                    required: \"required\",\r\n                    reversed: \"reversed\",\r\n                    role: \"role\",\r\n                    rows: \"rows\",\r\n                    rowspan: \"rowSpan\",\r\n                    sandbox: \"sandbox\",\r\n                    scope: \"scope\",\r\n                    scoped: \"scoped\",\r\n                    scrolling: \"scrolling\",\r\n                    seamless: \"seamless\",\r\n                    selected: \"selected\",\r\n                    shape: \"shape\",\r\n                    size: \"size\",\r\n                    sizes: \"sizes\",\r\n                    span: \"span\",\r\n                    spellcheck: \"spellCheck\",\r\n                    src: \"src\",\r\n                    srcdoc: \"srcDoc\",\r\n                    srclang: \"srcLang\",\r\n                    srcset: \"srcSet\",\r\n                    start: \"start\",\r\n                    step: \"step\",\r\n                    style: \"style\",\r\n                    summary: \"summary\",\r\n                    tabindex: \"tabIndex\",\r\n                    target: \"target\",\r\n                    title: \"title\",\r\n                    type: \"type\",\r\n                    usemap: \"useMap\",\r\n                    value: \"value\",\r\n                    width: \"width\",\r\n                    wmode: \"wmode\",\r\n                    wrap: \"wrap\",\r\n                    about: \"about\",\r\n                    accentheight: \"accentHeight\",\r\n                    \"accent-height\": \"accentHeight\",\r\n                    accumulate: \"accumulate\",\r\n                    additive: \"additive\",\r\n                    alignmentbaseline: \"alignmentBaseline\",\r\n                    \"alignment-baseline\": \"alignmentBaseline\",\r\n                    allowreorder: \"allowReorder\",\r\n                    alphabetic: \"alphabetic\",\r\n                    amplitude: \"amplitude\",\r\n                    arabicform: \"arabicForm\",\r\n                    \"arabic-form\": \"arabicForm\",\r\n                    ascent: \"ascent\",\r\n                    attributename: \"attributeName\",\r\n                    attributetype: \"attributeType\",\r\n                    autoreverse: \"autoReverse\",\r\n                    azimuth: \"azimuth\",\r\n                    basefrequency: \"baseFrequency\",\r\n                    baselineshift: \"baselineShift\",\r\n                    \"baseline-shift\": \"baselineShift\",\r\n                    baseprofile: \"baseProfile\",\r\n                    bbox: \"bbox\",\r\n                    begin: \"begin\",\r\n                    bias: \"bias\",\r\n                    by: \"by\",\r\n                    calcmode: \"calcMode\",\r\n                    capheight: \"capHeight\",\r\n                    \"cap-height\": \"capHeight\",\r\n                    clip: \"clip\",\r\n                    clippath: \"clipPath\",\r\n                    \"clip-path\": \"clipPath\",\r\n                    clippathunits: \"clipPathUnits\",\r\n                    cliprule: \"clipRule\",\r\n                    \"clip-rule\": \"clipRule\",\r\n                    color: \"color\",\r\n                    colorinterpolation: \"colorInterpolation\",\r\n                    \"color-interpolation\": \"colorInterpolation\",\r\n                    colorinterpolationfilters: \"colorInterpolationFilters\",\r\n                    \"color-interpolation-filters\": \"colorInterpolationFilters\",\r\n                    colorprofile: \"colorProfile\",\r\n                    \"color-profile\": \"colorProfile\",\r\n                    colorrendering: \"colorRendering\",\r\n                    \"color-rendering\": \"colorRendering\",\r\n                    contentscripttype: \"contentScriptType\",\r\n                    contentstyletype: \"contentStyleType\",\r\n                    cursor: \"cursor\",\r\n                    cx: \"cx\",\r\n                    cy: \"cy\",\r\n                    d: \"d\",\r\n                    datatype: \"datatype\",\r\n                    decelerate: \"decelerate\",\r\n                    descent: \"descent\",\r\n                    diffuseconstant: \"diffuseConstant\",\r\n                    direction: \"direction\",\r\n                    display: \"display\",\r\n                    divisor: \"divisor\",\r\n                    dominantbaseline: \"dominantBaseline\",\r\n                    \"dominant-baseline\": \"dominantBaseline\",\r\n                    dur: \"dur\",\r\n                    dx: \"dx\",\r\n                    dy: \"dy\",\r\n                    edgemode: \"edgeMode\",\r\n                    elevation: \"elevation\",\r\n                    enablebackground: \"enableBackground\",\r\n                    \"enable-background\": \"enableBackground\",\r\n                    end: \"end\",\r\n                    exponent: \"exponent\",\r\n                    externalresourcesrequired: \"externalResourcesRequired\",\r\n                    fill: \"fill\",\r\n                    fillopacity: \"fillOpacity\",\r\n                    \"fill-opacity\": \"fillOpacity\",\r\n                    fillrule: \"fillRule\",\r\n                    \"fill-rule\": \"fillRule\",\r\n                    filter: \"filter\",\r\n                    filterres: \"filterRes\",\r\n                    filterunits: \"filterUnits\",\r\n                    floodopacity: \"floodOpacity\",\r\n                    \"flood-opacity\": \"floodOpacity\",\r\n                    floodcolor: \"floodColor\",\r\n                    \"flood-color\": \"floodColor\",\r\n                    focusable: \"focusable\",\r\n                    fontfamily: \"fontFamily\",\r\n                    \"font-family\": \"fontFamily\",\r\n                    fontsize: \"fontSize\",\r\n                    \"font-size\": \"fontSize\",\r\n                    fontsizeadjust: \"fontSizeAdjust\",\r\n                    \"font-size-adjust\": \"fontSizeAdjust\",\r\n                    fontstretch: \"fontStretch\",\r\n                    \"font-stretch\": \"fontStretch\",\r\n                    fontstyle: \"fontStyle\",\r\n                    \"font-style\": \"fontStyle\",\r\n                    fontvariant: \"fontVariant\",\r\n                    \"font-variant\": \"fontVariant\",\r\n                    fontweight: \"fontWeight\",\r\n                    \"font-weight\": \"fontWeight\",\r\n                    format: \"format\",\r\n                    from: \"from\",\r\n                    fx: \"fx\",\r\n                    fy: \"fy\",\r\n                    g1: \"g1\",\r\n                    g2: \"g2\",\r\n                    glyphname: \"glyphName\",\r\n                    \"glyph-name\": \"glyphName\",\r\n                    glyphorientationhorizontal: \"glyphOrientationHorizontal\",\r\n                    \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\r\n                    glyphorientationvertical: \"glyphOrientationVertical\",\r\n                    \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\r\n                    glyphref: \"glyphRef\",\r\n                    gradienttransform: \"gradientTransform\",\r\n                    gradientunits: \"gradientUnits\",\r\n                    hanging: \"hanging\",\r\n                    horizadvx: \"horizAdvX\",\r\n                    \"horiz-adv-x\": \"horizAdvX\",\r\n                    horizoriginx: \"horizOriginX\",\r\n                    \"horiz-origin-x\": \"horizOriginX\",\r\n                    ideographic: \"ideographic\",\r\n                    imagerendering: \"imageRendering\",\r\n                    \"image-rendering\": \"imageRendering\",\r\n                    in2: \"in2\",\r\n                    in: \"in\",\r\n                    inlist: \"inlist\",\r\n                    intercept: \"intercept\",\r\n                    k1: \"k1\",\r\n                    k2: \"k2\",\r\n                    k3: \"k3\",\r\n                    k4: \"k4\",\r\n                    k: \"k\",\r\n                    kernelmatrix: \"kernelMatrix\",\r\n                    kernelunitlength: \"kernelUnitLength\",\r\n                    kerning: \"kerning\",\r\n                    keypoints: \"keyPoints\",\r\n                    keysplines: \"keySplines\",\r\n                    keytimes: \"keyTimes\",\r\n                    lengthadjust: \"lengthAdjust\",\r\n                    letterspacing: \"letterSpacing\",\r\n                    \"letter-spacing\": \"letterSpacing\",\r\n                    lightingcolor: \"lightingColor\",\r\n                    \"lighting-color\": \"lightingColor\",\r\n                    limitingconeangle: \"limitingConeAngle\",\r\n                    local: \"local\",\r\n                    markerend: \"markerEnd\",\r\n                    \"marker-end\": \"markerEnd\",\r\n                    markerheight: \"markerHeight\",\r\n                    markermid: \"markerMid\",\r\n                    \"marker-mid\": \"markerMid\",\r\n                    markerstart: \"markerStart\",\r\n                    \"marker-start\": \"markerStart\",\r\n                    markerunits: \"markerUnits\",\r\n                    markerwidth: \"markerWidth\",\r\n                    mask: \"mask\",\r\n                    maskcontentunits: \"maskContentUnits\",\r\n                    maskunits: \"maskUnits\",\r\n                    mathematical: \"mathematical\",\r\n                    mode: \"mode\",\r\n                    numoctaves: \"numOctaves\",\r\n                    offset: \"offset\",\r\n                    opacity: \"opacity\",\r\n                    operator: \"operator\",\r\n                    order: \"order\",\r\n                    orient: \"orient\",\r\n                    orientation: \"orientation\",\r\n                    origin: \"origin\",\r\n                    overflow: \"overflow\",\r\n                    overlineposition: \"overlinePosition\",\r\n                    \"overline-position\": \"overlinePosition\",\r\n                    overlinethickness: \"overlineThickness\",\r\n                    \"overline-thickness\": \"overlineThickness\",\r\n                    paintorder: \"paintOrder\",\r\n                    \"paint-order\": \"paintOrder\",\r\n                    panose1: \"panose1\",\r\n                    \"panose-1\": \"panose1\",\r\n                    pathlength: \"pathLength\",\r\n                    patterncontentunits: \"patternContentUnits\",\r\n                    patterntransform: \"patternTransform\",\r\n                    patternunits: \"patternUnits\",\r\n                    pointerevents: \"pointerEvents\",\r\n                    \"pointer-events\": \"pointerEvents\",\r\n                    points: \"points\",\r\n                    pointsatx: \"pointsAtX\",\r\n                    pointsaty: \"pointsAtY\",\r\n                    pointsatz: \"pointsAtZ\",\r\n                    prefix: \"prefix\",\r\n                    preservealpha: \"preserveAlpha\",\r\n                    preserveaspectratio: \"preserveAspectRatio\",\r\n                    primitiveunits: \"primitiveUnits\",\r\n                    property: \"property\",\r\n                    r: \"r\",\r\n                    radius: \"radius\",\r\n                    refx: \"refX\",\r\n                    refy: \"refY\",\r\n                    renderingintent: \"renderingIntent\",\r\n                    \"rendering-intent\": \"renderingIntent\",\r\n                    repeatcount: \"repeatCount\",\r\n                    repeatdur: \"repeatDur\",\r\n                    requiredextensions: \"requiredExtensions\",\r\n                    requiredfeatures: \"requiredFeatures\",\r\n                    resource: \"resource\",\r\n                    restart: \"restart\",\r\n                    result: \"result\",\r\n                    results: \"results\",\r\n                    rotate: \"rotate\",\r\n                    rx: \"rx\",\r\n                    ry: \"ry\",\r\n                    scale: \"scale\",\r\n                    security: \"security\",\r\n                    seed: \"seed\",\r\n                    shaperendering: \"shapeRendering\",\r\n                    \"shape-rendering\": \"shapeRendering\",\r\n                    slope: \"slope\",\r\n                    spacing: \"spacing\",\r\n                    specularconstant: \"specularConstant\",\r\n                    specularexponent: \"specularExponent\",\r\n                    speed: \"speed\",\r\n                    spreadmethod: \"spreadMethod\",\r\n                    startoffset: \"startOffset\",\r\n                    stddeviation: \"stdDeviation\",\r\n                    stemh: \"stemh\",\r\n                    stemv: \"stemv\",\r\n                    stitchtiles: \"stitchTiles\",\r\n                    stopcolor: \"stopColor\",\r\n                    \"stop-color\": \"stopColor\",\r\n                    stopopacity: \"stopOpacity\",\r\n                    \"stop-opacity\": \"stopOpacity\",\r\n                    strikethroughposition: \"strikethroughPosition\",\r\n                    \"strikethrough-position\": \"strikethroughPosition\",\r\n                    strikethroughthickness: \"strikethroughThickness\",\r\n                    \"strikethrough-thickness\": \"strikethroughThickness\",\r\n                    string: \"string\",\r\n                    stroke: \"stroke\",\r\n                    strokedasharray: \"strokeDasharray\",\r\n                    \"stroke-dasharray\": \"strokeDasharray\",\r\n                    strokedashoffset: \"strokeDashoffset\",\r\n                    \"stroke-dashoffset\": \"strokeDashoffset\",\r\n                    strokelinecap: \"strokeLinecap\",\r\n                    \"stroke-linecap\": \"strokeLinecap\",\r\n                    strokelinejoin: \"strokeLinejoin\",\r\n                    \"stroke-linejoin\": \"strokeLinejoin\",\r\n                    strokemiterlimit: \"strokeMiterlimit\",\r\n                    \"stroke-miterlimit\": \"strokeMiterlimit\",\r\n                    strokewidth: \"strokeWidth\",\r\n                    \"stroke-width\": \"strokeWidth\",\r\n                    strokeopacity: \"strokeOpacity\",\r\n                    \"stroke-opacity\": \"strokeOpacity\",\r\n                    suppresscontenteditablewarning: \"suppressContentEditableWarning\",\r\n                    suppresshydrationwarning: \"suppressHydrationWarning\",\r\n                    surfacescale: \"surfaceScale\",\r\n                    systemlanguage: \"systemLanguage\",\r\n                    tablevalues: \"tableValues\",\r\n                    targetx: \"targetX\",\r\n                    targety: \"targetY\",\r\n                    textanchor: \"textAnchor\",\r\n                    \"text-anchor\": \"textAnchor\",\r\n                    textdecoration: \"textDecoration\",\r\n                    \"text-decoration\": \"textDecoration\",\r\n                    textlength: \"textLength\",\r\n                    textrendering: \"textRendering\",\r\n                    \"text-rendering\": \"textRendering\",\r\n                    to: \"to\",\r\n                    transform: \"transform\",\r\n                    typeof: \"typeof\",\r\n                    u1: \"u1\",\r\n                    u2: \"u2\",\r\n                    underlineposition: \"underlinePosition\",\r\n                    \"underline-position\": \"underlinePosition\",\r\n                    underlinethickness: \"underlineThickness\",\r\n                    \"underline-thickness\": \"underlineThickness\",\r\n                    unicode: \"unicode\",\r\n                    unicodebidi: \"unicodeBidi\",\r\n                    \"unicode-bidi\": \"unicodeBidi\",\r\n                    unicoderange: \"unicodeRange\",\r\n                    \"unicode-range\": \"unicodeRange\",\r\n                    unitsperem: \"unitsPerEm\",\r\n                    \"units-per-em\": \"unitsPerEm\",\r\n                    unselectable: \"unselectable\",\r\n                    valphabetic: \"vAlphabetic\",\r\n                    \"v-alphabetic\": \"vAlphabetic\",\r\n                    values: \"values\",\r\n                    vectoreffect: \"vectorEffect\",\r\n                    \"vector-effect\": \"vectorEffect\",\r\n                    version: \"version\",\r\n                    vertadvy: \"vertAdvY\",\r\n                    \"vert-adv-y\": \"vertAdvY\",\r\n                    vertoriginx: \"vertOriginX\",\r\n                    \"vert-origin-x\": \"vertOriginX\",\r\n                    vertoriginy: \"vertOriginY\",\r\n                    \"vert-origin-y\": \"vertOriginY\",\r\n                    vhanging: \"vHanging\",\r\n                    \"v-hanging\": \"vHanging\",\r\n                    videographic: \"vIdeographic\",\r\n                    \"v-ideographic\": \"vIdeographic\",\r\n                    viewbox: \"viewBox\",\r\n                    viewtarget: \"viewTarget\",\r\n                    visibility: \"visibility\",\r\n                    vmathematical: \"vMathematical\",\r\n                    \"v-mathematical\": \"vMathematical\",\r\n                    vocab: \"vocab\",\r\n                    widths: \"widths\",\r\n                    wordspacing: \"wordSpacing\",\r\n                    \"word-spacing\": \"wordSpacing\",\r\n                    writingmode: \"writingMode\",\r\n                    \"writing-mode\": \"writingMode\",\r\n                    x1: \"x1\",\r\n                    x2: \"x2\",\r\n                    x: \"x\",\r\n                    xchannelselector: \"xChannelSelector\",\r\n                    xheight: \"xHeight\",\r\n                    \"x-height\": \"xHeight\",\r\n                    xlinkactuate: \"xlinkActuate\",\r\n                    \"xlink:actuate\": \"xlinkActuate\",\r\n                    xlinkarcrole: \"xlinkArcrole\",\r\n                    \"xlink:arcrole\": \"xlinkArcrole\",\r\n                    xlinkhref: \"xlinkHref\",\r\n                    \"xlink:href\": \"xlinkHref\",\r\n                    xlinkrole: \"xlinkRole\",\r\n                    \"xlink:role\": \"xlinkRole\",\r\n                    xlinkshow: \"xlinkShow\",\r\n                    \"xlink:show\": \"xlinkShow\",\r\n                    xlinktitle: \"xlinkTitle\",\r\n                    \"xlink:title\": \"xlinkTitle\",\r\n                    xlinktype: \"xlinkType\",\r\n                    \"xlink:type\": \"xlinkType\",\r\n                    xmlbase: \"xmlBase\",\r\n                    \"xml:base\": \"xmlBase\",\r\n                    xmllang: \"xmlLang\",\r\n                    \"xml:lang\": \"xmlLang\",\r\n                    xmlns: \"xmlns\",\r\n                    \"xml:space\": \"xmlSpace\",\r\n                    xmlnsxlink: \"xmlnsXlink\",\r\n                    \"xmlns:xlink\": \"xmlnsXlink\",\r\n                    xmlspace: \"xmlSpace\",\r\n                    y1: \"y1\",\r\n                    y2: \"y2\",\r\n                    y: \"y\",\r\n                    ychannelselector: \"yChannelSelector\",\r\n                    z: \"z\",\r\n                    zoomandpan: \"zoomAndPan\"\r\n                };\r\n                var ariaProperties = {\r\n                    \"aria-current\": 0,\r\n                    \"aria-description\": 0,\r\n                    \"aria-details\": 0,\r\n                    \"aria-disabled\": 0,\r\n                    \"aria-hidden\": 0,\r\n                    \"aria-invalid\": 0,\r\n                    \"aria-keyshortcuts\": 0,\r\n                    \"aria-label\": 0,\r\n                    \"aria-roledescription\": 0,\r\n                    \"aria-autocomplete\": 0,\r\n                    \"aria-checked\": 0,\r\n                    \"aria-expanded\": 0,\r\n                    \"aria-haspopup\": 0,\r\n                    \"aria-level\": 0,\r\n                    \"aria-modal\": 0,\r\n                    \"aria-multiline\": 0,\r\n                    \"aria-multiselectable\": 0,\r\n                    \"aria-orientation\": 0,\r\n                    \"aria-placeholder\": 0,\r\n                    \"aria-pressed\": 0,\r\n                    \"aria-readonly\": 0,\r\n                    \"aria-required\": 0,\r\n                    \"aria-selected\": 0,\r\n                    \"aria-sort\": 0,\r\n                    \"aria-valuemax\": 0,\r\n                    \"aria-valuemin\": 0,\r\n                    \"aria-valuenow\": 0,\r\n                    \"aria-valuetext\": 0,\r\n                    \"aria-atomic\": 0,\r\n                    \"aria-busy\": 0,\r\n                    \"aria-live\": 0,\r\n                    \"aria-relevant\": 0,\r\n                    \"aria-dropeffect\": 0,\r\n                    \"aria-grabbed\": 0,\r\n                    \"aria-activedescendant\": 0,\r\n                    \"aria-colcount\": 0,\r\n                    \"aria-colindex\": 0,\r\n                    \"aria-colspan\": 0,\r\n                    \"aria-controls\": 0,\r\n                    \"aria-describedby\": 0,\r\n                    \"aria-errormessage\": 0,\r\n                    \"aria-flowto\": 0,\r\n                    \"aria-labelledby\": 0,\r\n                    \"aria-owns\": 0,\r\n                    \"aria-posinset\": 0,\r\n                    \"aria-rowcount\": 0,\r\n                    \"aria-rowindex\": 0,\r\n                    \"aria-rowspan\": 0,\r\n                    \"aria-setsize\": 0\r\n                };\r\n                var warnedProperties = {};\r\n                var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\r\n                var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\r\n                function validateProperty(tagName, name) {\r\n                    {\r\n                        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\r\n                            return true;\r\n                        }\r\n                        if (rARIACamel.test(name)) {\r\n                            var ariaName = \"aria-\" + name.slice(4).toLowerCase();\r\n                            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\r\n                            if (correctName == null) {\r\n                                error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\r\n                                warnedProperties[name] = true;\r\n                                return true;\r\n                            }\r\n                            if (name !== correctName) {\r\n                                error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\r\n                                warnedProperties[name] = true;\r\n                                return true;\r\n                            }\r\n                        }\r\n                        if (rARIA.test(name)) {\r\n                            var lowerCasedName = name.toLowerCase();\r\n                            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\r\n                            if (standardName == null) {\r\n                                warnedProperties[name] = true;\r\n                                return false;\r\n                            }\r\n                            if (name !== standardName) {\r\n                                error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\r\n                                warnedProperties[name] = true;\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n                function warnInvalidARIAProps(type, props) {\r\n                    {\r\n                        var invalidProps = [];\r\n                        for (var key in props) {\r\n                            var isValid = validateProperty(type, key);\r\n                            if (!isValid) {\r\n                                invalidProps.push(key);\r\n                            }\r\n                        }\r\n                        var unknownPropString = invalidProps.map(function (prop) {\r\n                            return \"`\" + prop + \"`\";\r\n                        }).join(\", \");\r\n                        if (invalidProps.length === 1) {\r\n                            error(\"Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\r\n                        }\r\n                        else if (invalidProps.length > 1) {\r\n                            error(\"Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\r\n                        }\r\n                    }\r\n                }\r\n                function validateProperties(type, props) {\r\n                    if (isCustomComponent(type, props)) {\r\n                        return;\r\n                    }\r\n                    warnInvalidARIAProps(type, props);\r\n                }\r\n                var didWarnValueNull = false;\r\n                function validateProperties$1(type, props) {\r\n                    {\r\n                        if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\r\n                            return;\r\n                        }\r\n                        if (props != null && props.value === null && !didWarnValueNull) {\r\n                            didWarnValueNull = true;\r\n                            if (type === \"select\" && props.multiple) {\r\n                                error(\"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\", type);\r\n                            }\r\n                            else {\r\n                                error(\"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\", type);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var validateProperty$1 = function () {\r\n                };\r\n                {\r\n                    var warnedProperties$1 = {};\r\n                    var EVENT_NAME_REGEX = /^on./;\r\n                    var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\r\n                    var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\r\n                    var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\r\n                    validateProperty$1 = function (tagName, name, value, eventRegistry) {\r\n                        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\r\n                            return true;\r\n                        }\r\n                        var lowerCasedName = name.toLowerCase();\r\n                        if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\r\n                            error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\");\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        if (eventRegistry != null) {\r\n                            var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;\r\n                            if (registrationNameDependencies2.hasOwnProperty(name)) {\r\n                                return true;\r\n                            }\r\n                            var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;\r\n                            if (registrationName != null) {\r\n                                error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\r\n                                warnedProperties$1[name] = true;\r\n                                return true;\r\n                            }\r\n                            if (EVENT_NAME_REGEX.test(name)) {\r\n                                error(\"Unknown event handler property `%s`. It will be ignored.\", name);\r\n                                warnedProperties$1[name] = true;\r\n                                return true;\r\n                            }\r\n                        }\r\n                        else if (EVENT_NAME_REGEX.test(name)) {\r\n                            if (INVALID_EVENT_NAME_REGEX.test(name)) {\r\n                                error(\"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\", name);\r\n                            }\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\r\n                            return true;\r\n                        }\r\n                        if (lowerCasedName === \"innerhtml\") {\r\n                            error(\"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        if (lowerCasedName === \"aria\") {\r\n                            error(\"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\");\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        if (lowerCasedName === \"is\" && value !== null && value !== void 0 && typeof value !== \"string\") {\r\n                            error(\"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\", typeof value);\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        if (typeof value === \"number\" && isNaN(value)) {\r\n                            error(\"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\", name);\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        var propertyInfo = getPropertyInfo(name);\r\n                        var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\r\n                        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\r\n                            var standardName = possibleStandardNames[lowerCasedName];\r\n                            if (standardName !== name) {\r\n                                error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\r\n                                warnedProperties$1[name] = true;\r\n                                return true;\r\n                            }\r\n                        }\r\n                        else if (!isReserved && name !== lowerCasedName) {\r\n                            error(\"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\", name, lowerCasedName);\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        if (typeof value === \"boolean\" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\r\n                            if (value) {\r\n                                error('Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\r\n                            }\r\n                            else {\r\n                                error('Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);\r\n                            }\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        if (isReserved) {\r\n                            return true;\r\n                        }\r\n                        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\r\n                            warnedProperties$1[name] = true;\r\n                            return false;\r\n                        }\r\n                        if ((value === \"false\" || value === \"true\") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\r\n                            error(\"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\r\n                            warnedProperties$1[name] = true;\r\n                            return true;\r\n                        }\r\n                        return true;\r\n                    };\r\n                }\r\n                var warnUnknownProperties = function (type, props, eventRegistry) {\r\n                    {\r\n                        var unknownProps = [];\r\n                        for (var key in props) {\r\n                            var isValid = validateProperty$1(type, key, props[key], eventRegistry);\r\n                            if (!isValid) {\r\n                                unknownProps.push(key);\r\n                            }\r\n                        }\r\n                        var unknownPropString = unknownProps.map(function (prop) {\r\n                            return \"`\" + prop + \"`\";\r\n                        }).join(\", \");\r\n                        if (unknownProps.length === 1) {\r\n                            error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\r\n                        }\r\n                        else if (unknownProps.length > 1) {\r\n                            error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\r\n                        }\r\n                    }\r\n                };\r\n                function validateProperties$2(type, props, eventRegistry) {\r\n                    if (isCustomComponent(type, props)) {\r\n                        return;\r\n                    }\r\n                    warnUnknownProperties(type, props, eventRegistry);\r\n                }\r\n                var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;\r\n                var IS_NON_DELEGATED = 1 << 1;\r\n                var IS_CAPTURE_PHASE = 1 << 2;\r\n                var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;\r\n                var currentReplayingEvent = null;\r\n                function setReplayingEvent(event) {\r\n                    {\r\n                        if (currentReplayingEvent !== null) {\r\n                            error(\"Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n                    currentReplayingEvent = event;\r\n                }\r\n                function resetReplayingEvent() {\r\n                    {\r\n                        if (currentReplayingEvent === null) {\r\n                            error(\"Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n                    currentReplayingEvent = null;\r\n                }\r\n                function isReplayingEvent(event) {\r\n                    return event === currentReplayingEvent;\r\n                }\r\n                function getEventTarget(nativeEvent) {\r\n                    var target = nativeEvent.target || nativeEvent.srcElement || window;\r\n                    if (target.correspondingUseElement) {\r\n                        target = target.correspondingUseElement;\r\n                    }\r\n                    return target.nodeType === TEXT_NODE ? target.parentNode : target;\r\n                }\r\n                var restoreImpl = null;\r\n                var restoreTarget = null;\r\n                var restoreQueue = null;\r\n                function restoreStateOfTarget(target) {\r\n                    var internalInstance = getInstanceFromNode(target);\r\n                    if (!internalInstance) {\r\n                        return;\r\n                    }\r\n                    if (typeof restoreImpl !== \"function\") {\r\n                        throw new Error(\"setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                    var stateNode = internalInstance.stateNode;\r\n                    if (stateNode) {\r\n                        var _props = getFiberCurrentPropsFromNode(stateNode);\r\n                        restoreImpl(internalInstance.stateNode, internalInstance.type, _props);\r\n                    }\r\n                }\r\n                function setRestoreImplementation(impl) {\r\n                    restoreImpl = impl;\r\n                }\r\n                function enqueueStateRestore(target) {\r\n                    if (restoreTarget) {\r\n                        if (restoreQueue) {\r\n                            restoreQueue.push(target);\r\n                        }\r\n                        else {\r\n                            restoreQueue = [target];\r\n                        }\r\n                    }\r\n                    else {\r\n                        restoreTarget = target;\r\n                    }\r\n                }\r\n                function needsStateRestore() {\r\n                    return restoreTarget !== null || restoreQueue !== null;\r\n                }\r\n                function restoreStateIfNeeded() {\r\n                    if (!restoreTarget) {\r\n                        return;\r\n                    }\r\n                    var target = restoreTarget;\r\n                    var queuedTargets = restoreQueue;\r\n                    restoreTarget = null;\r\n                    restoreQueue = null;\r\n                    restoreStateOfTarget(target);\r\n                    if (queuedTargets) {\r\n                        for (var i2 = 0; i2 < queuedTargets.length; i2++) {\r\n                            restoreStateOfTarget(queuedTargets[i2]);\r\n                        }\r\n                    }\r\n                }\r\n                var batchedUpdatesImpl = function (fn2, bookkeeping) {\r\n                    return fn2(bookkeeping);\r\n                };\r\n                var flushSyncImpl = function () {\r\n                };\r\n                var isInsideEventHandler = false;\r\n                function finishEventHandler() {\r\n                    var controlledComponentsHavePendingUpdates = needsStateRestore();\r\n                    if (controlledComponentsHavePendingUpdates) {\r\n                        flushSyncImpl();\r\n                        restoreStateIfNeeded();\r\n                    }\r\n                }\r\n                function batchedUpdates(fn2, a2, b2) {\r\n                    if (isInsideEventHandler) {\r\n                        return fn2(a2, b2);\r\n                    }\r\n                    isInsideEventHandler = true;\r\n                    try {\r\n                        return batchedUpdatesImpl(fn2, a2, b2);\r\n                    }\r\n                    finally {\r\n                        isInsideEventHandler = false;\r\n                        finishEventHandler();\r\n                    }\r\n                }\r\n                function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {\r\n                    batchedUpdatesImpl = _batchedUpdatesImpl;\r\n                    flushSyncImpl = _flushSyncImpl;\r\n                }\r\n                function isInteractive(tag) {\r\n                    return tag === \"button\" || tag === \"input\" || tag === \"select\" || tag === \"textarea\";\r\n                }\r\n                function shouldPreventMouseEvent(name, type, props) {\r\n                    switch (name) {\r\n                        case \"onClick\":\r\n                        case \"onClickCapture\":\r\n                        case \"onDoubleClick\":\r\n                        case \"onDoubleClickCapture\":\r\n                        case \"onMouseDown\":\r\n                        case \"onMouseDownCapture\":\r\n                        case \"onMouseMove\":\r\n                        case \"onMouseMoveCapture\":\r\n                        case \"onMouseUp\":\r\n                        case \"onMouseUpCapture\":\r\n                        case \"onMouseEnter\":\r\n                            return !!(props.disabled && isInteractive(type));\r\n                        default:\r\n                            return false;\r\n                    }\r\n                }\r\n                function getListener(inst, registrationName) {\r\n                    var stateNode = inst.stateNode;\r\n                    if (stateNode === null) {\r\n                        return null;\r\n                    }\r\n                    var props = getFiberCurrentPropsFromNode(stateNode);\r\n                    if (props === null) {\r\n                        return null;\r\n                    }\r\n                    var listener = props[registrationName];\r\n                    if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\r\n                        return null;\r\n                    }\r\n                    if (listener && typeof listener !== \"function\") {\r\n                        throw new Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\r\n                    }\r\n                    return listener;\r\n                }\r\n                var passiveBrowserEventsSupported = false;\r\n                if (canUseDOM2) {\r\n                    try {\r\n                        var options = {};\r\n                        Object.defineProperty(options, \"passive\", {\r\n                            get: function () {\r\n                                passiveBrowserEventsSupported = true;\r\n                            }\r\n                        });\r\n                        window.addEventListener(\"test\", options, options);\r\n                        window.removeEventListener(\"test\", options, options);\r\n                    }\r\n                    catch (e2) {\r\n                        passiveBrowserEventsSupported = false;\r\n                    }\r\n                }\r\n                function invokeGuardedCallbackProd(name, func, context, a2, b2, c2, d2, e2, f2) {\r\n                    var funcArgs = Array.prototype.slice.call(arguments, 3);\r\n                    try {\r\n                        func.apply(context, funcArgs);\r\n                    }\r\n                    catch (error2) {\r\n                        this.onError(error2);\r\n                    }\r\n                }\r\n                var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\r\n                {\r\n                    if (typeof window !== \"undefined\" && typeof window.dispatchEvent === \"function\" && typeof document !== \"undefined\" && typeof document.createEvent === \"function\") {\r\n                        var fakeNode = document.createElement(\"react\");\r\n                        invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a2, b2, c2, d2, e2, f2) {\r\n                            if (typeof document === \"undefined\" || document === null) {\r\n                                throw new Error(\"The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.\");\r\n                            }\r\n                            var evt = document.createEvent(\"Event\");\r\n                            var didCall = false;\r\n                            var didError = true;\r\n                            var windowEvent = window.event;\r\n                            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, \"event\");\r\n                            function restoreAfterDispatch() {\r\n                                fakeNode.removeEventListener(evtType, callCallback2, false);\r\n                                if (typeof window.event !== \"undefined\" && window.hasOwnProperty(\"event\")) {\r\n                                    window.event = windowEvent;\r\n                                }\r\n                            }\r\n                            var funcArgs = Array.prototype.slice.call(arguments, 3);\r\n                            function callCallback2() {\r\n                                didCall = true;\r\n                                restoreAfterDispatch();\r\n                                func.apply(context, funcArgs);\r\n                                didError = false;\r\n                            }\r\n                            var error2;\r\n                            var didSetError = false;\r\n                            var isCrossOriginError = false;\r\n                            function handleWindowError(event) {\r\n                                error2 = event.error;\r\n                                didSetError = true;\r\n                                if (error2 === null && event.colno === 0 && event.lineno === 0) {\r\n                                    isCrossOriginError = true;\r\n                                }\r\n                                if (event.defaultPrevented) {\r\n                                    if (error2 != null && typeof error2 === \"object\") {\r\n                                        try {\r\n                                            error2._suppressLogging = true;\r\n                                        }\r\n                                        catch (inner) {\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\r\n                            window.addEventListener(\"error\", handleWindowError);\r\n                            fakeNode.addEventListener(evtType, callCallback2, false);\r\n                            evt.initEvent(evtType, false, false);\r\n                            fakeNode.dispatchEvent(evt);\r\n                            if (windowEventDescriptor) {\r\n                                Object.defineProperty(window, \"event\", windowEventDescriptor);\r\n                            }\r\n                            if (didCall && didError) {\r\n                                if (!didSetError) {\r\n                                    error2 = new Error(\"An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the \\\"Pause on exceptions\\\" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.\");\r\n                                }\r\n                                else if (isCrossOriginError) {\r\n                                    error2 = new Error(\"A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.\");\r\n                                }\r\n                                this.onError(error2);\r\n                            }\r\n                            window.removeEventListener(\"error\", handleWindowError);\r\n                            if (!didCall) {\r\n                                restoreAfterDispatch();\r\n                                return invokeGuardedCallbackProd.apply(this, arguments);\r\n                            }\r\n                        };\r\n                    }\r\n                }\r\n                var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\r\n                var hasError = false;\r\n                var caughtError = null;\r\n                var hasRethrowError = false;\r\n                var rethrowError = null;\r\n                var reporter = {\r\n                    onError: function (error2) {\r\n                        hasError = true;\r\n                        caughtError = error2;\r\n                    }\r\n                };\r\n                function invokeGuardedCallback(name, func, context, a2, b2, c2, d2, e2, f2) {\r\n                    hasError = false;\r\n                    caughtError = null;\r\n                    invokeGuardedCallbackImpl$1.apply(reporter, arguments);\r\n                }\r\n                function invokeGuardedCallbackAndCatchFirstError(name, func, context, a2, b2, c2, d2, e2, f2) {\r\n                    invokeGuardedCallback.apply(this, arguments);\r\n                    if (hasError) {\r\n                        var error2 = clearCaughtError();\r\n                        if (!hasRethrowError) {\r\n                            hasRethrowError = true;\r\n                            rethrowError = error2;\r\n                        }\r\n                    }\r\n                }\r\n                function rethrowCaughtError() {\r\n                    if (hasRethrowError) {\r\n                        var error2 = rethrowError;\r\n                        hasRethrowError = false;\r\n                        rethrowError = null;\r\n                        throw error2;\r\n                    }\r\n                }\r\n                function hasCaughtError() {\r\n                    return hasError;\r\n                }\r\n                function clearCaughtError() {\r\n                    if (hasError) {\r\n                        var error2 = caughtError;\r\n                        hasError = false;\r\n                        caughtError = null;\r\n                        return error2;\r\n                    }\r\n                    else {\r\n                        throw new Error(\"clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.\");\r\n                    }\r\n                }\r\n                function get(key) {\r\n                    return key._reactInternals;\r\n                }\r\n                function has(key) {\r\n                    return key._reactInternals !== void 0;\r\n                }\r\n                function set(key, value) {\r\n                    key._reactInternals = value;\r\n                }\r\n                var NoFlags = 0;\r\n                var PerformedWork = 1;\r\n                var Placement = 2;\r\n                var Update = 4;\r\n                var ChildDeletion = 16;\r\n                var ContentReset = 32;\r\n                var Callback = 64;\r\n                var DidCapture = 128;\r\n                var ForceClientRender = 256;\r\n                var Ref = 512;\r\n                var Snapshot = 1024;\r\n                var Passive = 2048;\r\n                var Hydrating = 4096;\r\n                var Visibility = 8192;\r\n                var StoreConsistency = 16384;\r\n                var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;\r\n                var HostEffectMask = 32767;\r\n                var Incomplete = 32768;\r\n                var ShouldCapture = 65536;\r\n                var ForceUpdateForLegacySuspense = 131072;\r\n                var Forked = 1048576;\r\n                var RefStatic = 2097152;\r\n                var LayoutStatic = 4194304;\r\n                var PassiveStatic = 8388608;\r\n                var MountLayoutDev = 16777216;\r\n                var MountPassiveDev = 33554432;\r\n                var BeforeMutationMask = Update | Snapshot | 0;\r\n                var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\r\n                var LayoutMask = Update | Callback | Ref | Visibility;\r\n                var PassiveMask = Passive | ChildDeletion;\r\n                var StaticMask = LayoutStatic | PassiveStatic | RefStatic;\r\n                var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\r\n                function getNearestMountedFiber(fiber) {\r\n                    var node = fiber;\r\n                    var nearestMounted = fiber;\r\n                    if (!fiber.alternate) {\r\n                        var nextNode = node;\r\n                        do {\r\n                            node = nextNode;\r\n                            if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\r\n                                nearestMounted = node.return;\r\n                            }\r\n                            nextNode = node.return;\r\n                        } while (nextNode);\r\n                    }\r\n                    else {\r\n                        while (node.return) {\r\n                            node = node.return;\r\n                        }\r\n                    }\r\n                    if (node.tag === HostRoot) {\r\n                        return nearestMounted;\r\n                    }\r\n                    return null;\r\n                }\r\n                function getSuspenseInstanceFromFiber(fiber) {\r\n                    if (fiber.tag === SuspenseComponent) {\r\n                        var suspenseState = fiber.memoizedState;\r\n                        if (suspenseState === null) {\r\n                            var current2 = fiber.alternate;\r\n                            if (current2 !== null) {\r\n                                suspenseState = current2.memoizedState;\r\n                            }\r\n                        }\r\n                        if (suspenseState !== null) {\r\n                            return suspenseState.dehydrated;\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n                function getContainerFromFiber(fiber) {\r\n                    return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;\r\n                }\r\n                function isFiberMounted(fiber) {\r\n                    return getNearestMountedFiber(fiber) === fiber;\r\n                }\r\n                function isMounted(component) {\r\n                    {\r\n                        var owner = ReactCurrentOwner.current;\r\n                        if (owner !== null && owner.tag === ClassComponent) {\r\n                            var ownerFiber = owner;\r\n                            var instance = ownerFiber.stateNode;\r\n                            if (!instance._warnedAboutRefsInRender) {\r\n                                error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(ownerFiber) || \"A component\");\r\n                            }\r\n                            instance._warnedAboutRefsInRender = true;\r\n                        }\r\n                    }\r\n                    var fiber = get(component);\r\n                    if (!fiber) {\r\n                        return false;\r\n                    }\r\n                    return getNearestMountedFiber(fiber) === fiber;\r\n                }\r\n                function assertIsMounted(fiber) {\r\n                    if (getNearestMountedFiber(fiber) !== fiber) {\r\n                        throw new Error(\"Unable to find node on an unmounted component.\");\r\n                    }\r\n                }\r\n                function findCurrentFiberUsingSlowPath(fiber) {\r\n                    var alternate = fiber.alternate;\r\n                    if (!alternate) {\r\n                        var nearestMounted = getNearestMountedFiber(fiber);\r\n                        if (nearestMounted === null) {\r\n                            throw new Error(\"Unable to find node on an unmounted component.\");\r\n                        }\r\n                        if (nearestMounted !== fiber) {\r\n                            return null;\r\n                        }\r\n                        return fiber;\r\n                    }\r\n                    var a2 = fiber;\r\n                    var b2 = alternate;\r\n                    while (true) {\r\n                        var parentA = a2.return;\r\n                        if (parentA === null) {\r\n                            break;\r\n                        }\r\n                        var parentB = parentA.alternate;\r\n                        if (parentB === null) {\r\n                            var nextParent = parentA.return;\r\n                            if (nextParent !== null) {\r\n                                a2 = b2 = nextParent;\r\n                                continue;\r\n                            }\r\n                            break;\r\n                        }\r\n                        if (parentA.child === parentB.child) {\r\n                            var child = parentA.child;\r\n                            while (child) {\r\n                                if (child === a2) {\r\n                                    assertIsMounted(parentA);\r\n                                    return fiber;\r\n                                }\r\n                                if (child === b2) {\r\n                                    assertIsMounted(parentA);\r\n                                    return alternate;\r\n                                }\r\n                                child = child.sibling;\r\n                            }\r\n                            throw new Error(\"Unable to find node on an unmounted component.\");\r\n                        }\r\n                        if (a2.return !== b2.return) {\r\n                            a2 = parentA;\r\n                            b2 = parentB;\r\n                        }\r\n                        else {\r\n                            var didFindChild = false;\r\n                            var _child = parentA.child;\r\n                            while (_child) {\r\n                                if (_child === a2) {\r\n                                    didFindChild = true;\r\n                                    a2 = parentA;\r\n                                    b2 = parentB;\r\n                                    break;\r\n                                }\r\n                                if (_child === b2) {\r\n                                    didFindChild = true;\r\n                                    b2 = parentA;\r\n                                    a2 = parentB;\r\n                                    break;\r\n                                }\r\n                                _child = _child.sibling;\r\n                            }\r\n                            if (!didFindChild) {\r\n                                _child = parentB.child;\r\n                                while (_child) {\r\n                                    if (_child === a2) {\r\n                                        didFindChild = true;\r\n                                        a2 = parentB;\r\n                                        b2 = parentA;\r\n                                        break;\r\n                                    }\r\n                                    if (_child === b2) {\r\n                                        didFindChild = true;\r\n                                        b2 = parentB;\r\n                                        a2 = parentA;\r\n                                        break;\r\n                                    }\r\n                                    _child = _child.sibling;\r\n                                }\r\n                                if (!didFindChild) {\r\n                                    throw new Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\r\n                                }\r\n                            }\r\n                        }\r\n                        if (a2.alternate !== b2) {\r\n                            throw new Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\r\n                        }\r\n                    }\r\n                    if (a2.tag !== HostRoot) {\r\n                        throw new Error(\"Unable to find node on an unmounted component.\");\r\n                    }\r\n                    if (a2.stateNode.current === a2) {\r\n                        return fiber;\r\n                    }\r\n                    return alternate;\r\n                }\r\n                function findCurrentHostFiber(parent) {\r\n                    var currentParent = findCurrentFiberUsingSlowPath(parent);\r\n                    return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\r\n                }\r\n                function findCurrentHostFiberImpl(node) {\r\n                    if (node.tag === HostComponent || node.tag === HostText) {\r\n                        return node;\r\n                    }\r\n                    var child = node.child;\r\n                    while (child !== null) {\r\n                        var match = findCurrentHostFiberImpl(child);\r\n                        if (match !== null) {\r\n                            return match;\r\n                        }\r\n                        child = child.sibling;\r\n                    }\r\n                    return null;\r\n                }\r\n                function findCurrentHostFiberWithNoPortals(parent) {\r\n                    var currentParent = findCurrentFiberUsingSlowPath(parent);\r\n                    return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\r\n                }\r\n                function findCurrentHostFiberWithNoPortalsImpl(node) {\r\n                    if (node.tag === HostComponent || node.tag === HostText) {\r\n                        return node;\r\n                    }\r\n                    var child = node.child;\r\n                    while (child !== null) {\r\n                        if (child.tag !== HostPortal) {\r\n                            var match = findCurrentHostFiberWithNoPortalsImpl(child);\r\n                            if (match !== null) {\r\n                                return match;\r\n                            }\r\n                        }\r\n                        child = child.sibling;\r\n                    }\r\n                    return null;\r\n                }\r\n                var scheduleCallback = Scheduler.unstable_scheduleCallback;\r\n                var cancelCallback = Scheduler.unstable_cancelCallback;\r\n                var shouldYield = Scheduler.unstable_shouldYield;\r\n                var requestPaint = Scheduler.unstable_requestPaint;\r\n                var now = Scheduler.unstable_now;\r\n                var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;\r\n                var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\r\n                var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\r\n                var NormalPriority = Scheduler.unstable_NormalPriority;\r\n                var LowPriority = Scheduler.unstable_LowPriority;\r\n                var IdlePriority = Scheduler.unstable_IdlePriority;\r\n                var unstable_yieldValue = Scheduler.unstable_yieldValue;\r\n                var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\r\n                var rendererID = null;\r\n                var injectedHook = null;\r\n                var injectedProfilingHooks = null;\r\n                var hasLoggedError = false;\r\n                var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\r\n                function injectInternals(internals) {\r\n                    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\r\n                        return false;\r\n                    }\r\n                    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\r\n                    if (hook.isDisabled) {\r\n                        return true;\r\n                    }\r\n                    if (!hook.supportsFiber) {\r\n                        {\r\n                            error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools\");\r\n                        }\r\n                        return true;\r\n                    }\r\n                    try {\r\n                        if (enableSchedulingProfiler) {\r\n                            internals = assign({}, internals, {\r\n                                getLaneLabelMap: getLaneLabelMap,\r\n                                injectProfilingHooks: injectProfilingHooks\r\n                            });\r\n                        }\r\n                        rendererID = hook.inject(internals);\r\n                        injectedHook = hook;\r\n                    }\r\n                    catch (err) {\r\n                        {\r\n                            error(\"React instrumentation encountered an error: %s.\", err);\r\n                        }\r\n                    }\r\n                    if (hook.checkDCE) {\r\n                        return true;\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n                function onScheduleRoot(root2, children) {\r\n                    {\r\n                        if (injectedHook && typeof injectedHook.onScheduleFiberRoot === \"function\") {\r\n                            try {\r\n                                injectedHook.onScheduleFiberRoot(rendererID, root2, children);\r\n                            }\r\n                            catch (err) {\r\n                                if (!hasLoggedError) {\r\n                                    hasLoggedError = true;\r\n                                    error(\"React instrumentation encountered an error: %s\", err);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function onCommitRoot(root2, eventPriority) {\r\n                    if (injectedHook && typeof injectedHook.onCommitFiberRoot === \"function\") {\r\n                        try {\r\n                            var didError = (root2.current.flags & DidCapture) === DidCapture;\r\n                            if (enableProfilerTimer) {\r\n                                var schedulerPriority;\r\n                                switch (eventPriority) {\r\n                                    case DiscreteEventPriority:\r\n                                        schedulerPriority = ImmediatePriority;\r\n                                        break;\r\n                                    case ContinuousEventPriority:\r\n                                        schedulerPriority = UserBlockingPriority;\r\n                                        break;\r\n                                    case DefaultEventPriority:\r\n                                        schedulerPriority = NormalPriority;\r\n                                        break;\r\n                                    case IdleEventPriority:\r\n                                        schedulerPriority = IdlePriority;\r\n                                        break;\r\n                                    default:\r\n                                        schedulerPriority = NormalPriority;\r\n                                        break;\r\n                                }\r\n                                injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);\r\n                            }\r\n                            else {\r\n                                injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);\r\n                            }\r\n                        }\r\n                        catch (err) {\r\n                            {\r\n                                if (!hasLoggedError) {\r\n                                    hasLoggedError = true;\r\n                                    error(\"React instrumentation encountered an error: %s\", err);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function onPostCommitRoot(root2) {\r\n                    if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === \"function\") {\r\n                        try {\r\n                            injectedHook.onPostCommitFiberRoot(rendererID, root2);\r\n                        }\r\n                        catch (err) {\r\n                            {\r\n                                if (!hasLoggedError) {\r\n                                    hasLoggedError = true;\r\n                                    error(\"React instrumentation encountered an error: %s\", err);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function onCommitUnmount(fiber) {\r\n                    if (injectedHook && typeof injectedHook.onCommitFiberUnmount === \"function\") {\r\n                        try {\r\n                            injectedHook.onCommitFiberUnmount(rendererID, fiber);\r\n                        }\r\n                        catch (err) {\r\n                            {\r\n                                if (!hasLoggedError) {\r\n                                    hasLoggedError = true;\r\n                                    error(\"React instrumentation encountered an error: %s\", err);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function setIsStrictModeForDevtools(newIsStrictMode) {\r\n                    {\r\n                        if (typeof unstable_yieldValue === \"function\") {\r\n                            unstable_setDisableYieldValue(newIsStrictMode);\r\n                            setSuppressWarning(newIsStrictMode);\r\n                        }\r\n                        if (injectedHook && typeof injectedHook.setStrictMode === \"function\") {\r\n                            try {\r\n                                injectedHook.setStrictMode(rendererID, newIsStrictMode);\r\n                            }\r\n                            catch (err) {\r\n                                {\r\n                                    if (!hasLoggedError) {\r\n                                        hasLoggedError = true;\r\n                                        error(\"React instrumentation encountered an error: %s\", err);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function injectProfilingHooks(profilingHooks) {\r\n                    injectedProfilingHooks = profilingHooks;\r\n                }\r\n                function getLaneLabelMap() {\r\n                    {\r\n                        var map = new Map();\r\n                        var lane = 1;\r\n                        for (var index2 = 0; index2 < TotalLanes; index2++) {\r\n                            var label = getLabelForLane(lane);\r\n                            map.set(lane, label);\r\n                            lane *= 2;\r\n                        }\r\n                        return map;\r\n                    }\r\n                }\r\n                function markCommitStarted(lanes) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === \"function\") {\r\n                            injectedProfilingHooks.markCommitStarted(lanes);\r\n                        }\r\n                    }\r\n                }\r\n                function markCommitStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === \"function\") {\r\n                            injectedProfilingHooks.markCommitStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentRenderStarted(fiber) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === \"function\") {\r\n                            injectedProfilingHooks.markComponentRenderStarted(fiber);\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentRenderStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === \"function\") {\r\n                            injectedProfilingHooks.markComponentRenderStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentPassiveEffectMountStarted(fiber) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === \"function\") {\r\n                            injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentPassiveEffectMountStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === \"function\") {\r\n                            injectedProfilingHooks.markComponentPassiveEffectMountStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentPassiveEffectUnmountStarted(fiber) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === \"function\") {\r\n                            injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentPassiveEffectUnmountStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === \"function\") {\r\n                            injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentLayoutEffectMountStarted(fiber) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === \"function\") {\r\n                            injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentLayoutEffectMountStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === \"function\") {\r\n                            injectedProfilingHooks.markComponentLayoutEffectMountStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentLayoutEffectUnmountStarted(fiber) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === \"function\") {\r\n                            injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentLayoutEffectUnmountStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === \"function\") {\r\n                            injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentErrored(fiber, thrownValue, lanes) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === \"function\") {\r\n                            injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\r\n                        }\r\n                    }\r\n                }\r\n                function markComponentSuspended(fiber, wakeable, lanes) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === \"function\") {\r\n                            injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\r\n                        }\r\n                    }\r\n                }\r\n                function markLayoutEffectsStarted(lanes) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === \"function\") {\r\n                            injectedProfilingHooks.markLayoutEffectsStarted(lanes);\r\n                        }\r\n                    }\r\n                }\r\n                function markLayoutEffectsStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === \"function\") {\r\n                            injectedProfilingHooks.markLayoutEffectsStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markPassiveEffectsStarted(lanes) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === \"function\") {\r\n                            injectedProfilingHooks.markPassiveEffectsStarted(lanes);\r\n                        }\r\n                    }\r\n                }\r\n                function markPassiveEffectsStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === \"function\") {\r\n                            injectedProfilingHooks.markPassiveEffectsStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markRenderStarted(lanes) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === \"function\") {\r\n                            injectedProfilingHooks.markRenderStarted(lanes);\r\n                        }\r\n                    }\r\n                }\r\n                function markRenderYielded() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === \"function\") {\r\n                            injectedProfilingHooks.markRenderYielded();\r\n                        }\r\n                    }\r\n                }\r\n                function markRenderStopped() {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === \"function\") {\r\n                            injectedProfilingHooks.markRenderStopped();\r\n                        }\r\n                    }\r\n                }\r\n                function markRenderScheduled(lane) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === \"function\") {\r\n                            injectedProfilingHooks.markRenderScheduled(lane);\r\n                        }\r\n                    }\r\n                }\r\n                function markForceUpdateScheduled(fiber, lane) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === \"function\") {\r\n                            injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\r\n                        }\r\n                    }\r\n                }\r\n                function markStateUpdateScheduled(fiber, lane) {\r\n                    {\r\n                        if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === \"function\") {\r\n                            injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\r\n                        }\r\n                    }\r\n                }\r\n                var NoMode = 0;\r\n                var ConcurrentMode = 1;\r\n                var ProfileMode = 2;\r\n                var StrictLegacyMode = 8;\r\n                var StrictEffectsMode = 16;\r\n                var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;\r\n                var log = Math.log;\r\n                var LN2 = Math.LN2;\r\n                function clz32Fallback(x2) {\r\n                    var asUint = x2 >>> 0;\r\n                    if (asUint === 0) {\r\n                        return 32;\r\n                    }\r\n                    return 31 - (log(asUint) / LN2 | 0) | 0;\r\n                }\r\n                var TotalLanes = 31;\r\n                var NoLanes = 0;\r\n                var NoLane = 0;\r\n                var SyncLane = 1;\r\n                var InputContinuousHydrationLane = 2;\r\n                var InputContinuousLane = 4;\r\n                var DefaultHydrationLane = 8;\r\n                var DefaultLane = 16;\r\n                var TransitionHydrationLane = 32;\r\n                var TransitionLanes = 4194240;\r\n                var TransitionLane1 = 64;\r\n                var TransitionLane2 = 128;\r\n                var TransitionLane3 = 256;\r\n                var TransitionLane4 = 512;\r\n                var TransitionLane5 = 1024;\r\n                var TransitionLane6 = 2048;\r\n                var TransitionLane7 = 4096;\r\n                var TransitionLane8 = 8192;\r\n                var TransitionLane9 = 16384;\r\n                var TransitionLane10 = 32768;\r\n                var TransitionLane11 = 65536;\r\n                var TransitionLane12 = 131072;\r\n                var TransitionLane13 = 262144;\r\n                var TransitionLane14 = 524288;\r\n                var TransitionLane15 = 1048576;\r\n                var TransitionLane16 = 2097152;\r\n                var RetryLanes = 130023424;\r\n                var RetryLane1 = 4194304;\r\n                var RetryLane2 = 8388608;\r\n                var RetryLane3 = 16777216;\r\n                var RetryLane4 = 33554432;\r\n                var RetryLane5 = 67108864;\r\n                var SomeRetryLane = RetryLane1;\r\n                var SelectiveHydrationLane = 134217728;\r\n                var NonIdleLanes = 268435455;\r\n                var IdleHydrationLane = 268435456;\r\n                var IdleLane = 536870912;\r\n                var OffscreenLane = 1073741824;\r\n                function getLabelForLane(lane) {\r\n                    {\r\n                        if (lane & SyncLane) {\r\n                            return \"Sync\";\r\n                        }\r\n                        if (lane & InputContinuousHydrationLane) {\r\n                            return \"InputContinuousHydration\";\r\n                        }\r\n                        if (lane & InputContinuousLane) {\r\n                            return \"InputContinuous\";\r\n                        }\r\n                        if (lane & DefaultHydrationLane) {\r\n                            return \"DefaultHydration\";\r\n                        }\r\n                        if (lane & DefaultLane) {\r\n                            return \"Default\";\r\n                        }\r\n                        if (lane & TransitionHydrationLane) {\r\n                            return \"TransitionHydration\";\r\n                        }\r\n                        if (lane & TransitionLanes) {\r\n                            return \"Transition\";\r\n                        }\r\n                        if (lane & RetryLanes) {\r\n                            return \"Retry\";\r\n                        }\r\n                        if (lane & SelectiveHydrationLane) {\r\n                            return \"SelectiveHydration\";\r\n                        }\r\n                        if (lane & IdleHydrationLane) {\r\n                            return \"IdleHydration\";\r\n                        }\r\n                        if (lane & IdleLane) {\r\n                            return \"Idle\";\r\n                        }\r\n                        if (lane & OffscreenLane) {\r\n                            return \"Offscreen\";\r\n                        }\r\n                    }\r\n                }\r\n                var NoTimestamp = -1;\r\n                var nextTransitionLane = TransitionLane1;\r\n                var nextRetryLane = RetryLane1;\r\n                function getHighestPriorityLanes(lanes) {\r\n                    switch (getHighestPriorityLane(lanes)) {\r\n                        case SyncLane:\r\n                            return SyncLane;\r\n                        case InputContinuousHydrationLane:\r\n                            return InputContinuousHydrationLane;\r\n                        case InputContinuousLane:\r\n                            return InputContinuousLane;\r\n                        case DefaultHydrationLane:\r\n                            return DefaultHydrationLane;\r\n                        case DefaultLane:\r\n                            return DefaultLane;\r\n                        case TransitionHydrationLane:\r\n                            return TransitionHydrationLane;\r\n                        case TransitionLane1:\r\n                        case TransitionLane2:\r\n                        case TransitionLane3:\r\n                        case TransitionLane4:\r\n                        case TransitionLane5:\r\n                        case TransitionLane6:\r\n                        case TransitionLane7:\r\n                        case TransitionLane8:\r\n                        case TransitionLane9:\r\n                        case TransitionLane10:\r\n                        case TransitionLane11:\r\n                        case TransitionLane12:\r\n                        case TransitionLane13:\r\n                        case TransitionLane14:\r\n                        case TransitionLane15:\r\n                        case TransitionLane16:\r\n                            return lanes & TransitionLanes;\r\n                        case RetryLane1:\r\n                        case RetryLane2:\r\n                        case RetryLane3:\r\n                        case RetryLane4:\r\n                        case RetryLane5:\r\n                            return lanes & RetryLanes;\r\n                        case SelectiveHydrationLane:\r\n                            return SelectiveHydrationLane;\r\n                        case IdleHydrationLane:\r\n                            return IdleHydrationLane;\r\n                        case IdleLane:\r\n                            return IdleLane;\r\n                        case OffscreenLane:\r\n                            return OffscreenLane;\r\n                        default:\r\n                            {\r\n                                error(\"Should have found matching lanes. This is a bug in React.\");\r\n                            }\r\n                            return lanes;\r\n                    }\r\n                }\r\n                function getNextLanes(root2, wipLanes) {\r\n                    var pendingLanes = root2.pendingLanes;\r\n                    if (pendingLanes === NoLanes) {\r\n                        return NoLanes;\r\n                    }\r\n                    var nextLanes = NoLanes;\r\n                    var suspendedLanes = root2.suspendedLanes;\r\n                    var pingedLanes = root2.pingedLanes;\r\n                    var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\r\n                    if (nonIdlePendingLanes !== NoLanes) {\r\n                        var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\r\n                        if (nonIdleUnblockedLanes !== NoLanes) {\r\n                            nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\r\n                        }\r\n                        else {\r\n                            var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\r\n                            if (nonIdlePingedLanes !== NoLanes) {\r\n                                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        var unblockedLanes = pendingLanes & ~suspendedLanes;\r\n                        if (unblockedLanes !== NoLanes) {\r\n                            nextLanes = getHighestPriorityLanes(unblockedLanes);\r\n                        }\r\n                        else {\r\n                            if (pingedLanes !== NoLanes) {\r\n                                nextLanes = getHighestPriorityLanes(pingedLanes);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (nextLanes === NoLanes) {\r\n                        return NoLanes;\r\n                    }\r\n                    if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {\r\n                        var nextLane = getHighestPriorityLane(nextLanes);\r\n                        var wipLane = getHighestPriorityLane(wipLanes);\r\n                        if (nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\r\n                            return wipLanes;\r\n                        }\r\n                    }\r\n                    if ((nextLanes & InputContinuousLane) !== NoLanes) {\r\n                        nextLanes |= pendingLanes & DefaultLane;\r\n                    }\r\n                    var entangledLanes = root2.entangledLanes;\r\n                    if (entangledLanes !== NoLanes) {\r\n                        var entanglements = root2.entanglements;\r\n                        var lanes = nextLanes & entangledLanes;\r\n                        while (lanes > 0) {\r\n                            var index2 = pickArbitraryLaneIndex(lanes);\r\n                            var lane = 1 << index2;\r\n                            nextLanes |= entanglements[index2];\r\n                            lanes &= ~lane;\r\n                        }\r\n                    }\r\n                    return nextLanes;\r\n                }\r\n                function getMostRecentEventTime(root2, lanes) {\r\n                    var eventTimes = root2.eventTimes;\r\n                    var mostRecentEventTime = NoTimestamp;\r\n                    while (lanes > 0) {\r\n                        var index2 = pickArbitraryLaneIndex(lanes);\r\n                        var lane = 1 << index2;\r\n                        var eventTime = eventTimes[index2];\r\n                        if (eventTime > mostRecentEventTime) {\r\n                            mostRecentEventTime = eventTime;\r\n                        }\r\n                        lanes &= ~lane;\r\n                    }\r\n                    return mostRecentEventTime;\r\n                }\r\n                function computeExpirationTime(lane, currentTime) {\r\n                    switch (lane) {\r\n                        case SyncLane:\r\n                        case InputContinuousHydrationLane:\r\n                        case InputContinuousLane:\r\n                            return currentTime + 250;\r\n                        case DefaultHydrationLane:\r\n                        case DefaultLane:\r\n                        case TransitionHydrationLane:\r\n                        case TransitionLane1:\r\n                        case TransitionLane2:\r\n                        case TransitionLane3:\r\n                        case TransitionLane4:\r\n                        case TransitionLane5:\r\n                        case TransitionLane6:\r\n                        case TransitionLane7:\r\n                        case TransitionLane8:\r\n                        case TransitionLane9:\r\n                        case TransitionLane10:\r\n                        case TransitionLane11:\r\n                        case TransitionLane12:\r\n                        case TransitionLane13:\r\n                        case TransitionLane14:\r\n                        case TransitionLane15:\r\n                        case TransitionLane16:\r\n                            return currentTime + 5e3;\r\n                        case RetryLane1:\r\n                        case RetryLane2:\r\n                        case RetryLane3:\r\n                        case RetryLane4:\r\n                        case RetryLane5:\r\n                            return NoTimestamp;\r\n                        case SelectiveHydrationLane:\r\n                        case IdleHydrationLane:\r\n                        case IdleLane:\r\n                        case OffscreenLane:\r\n                            return NoTimestamp;\r\n                        default:\r\n                            {\r\n                                error(\"Should have found matching lanes. This is a bug in React.\");\r\n                            }\r\n                            return NoTimestamp;\r\n                    }\r\n                }\r\n                function markStarvedLanesAsExpired(root2, currentTime) {\r\n                    var pendingLanes = root2.pendingLanes;\r\n                    var suspendedLanes = root2.suspendedLanes;\r\n                    var pingedLanes = root2.pingedLanes;\r\n                    var expirationTimes = root2.expirationTimes;\r\n                    var lanes = pendingLanes;\r\n                    while (lanes > 0) {\r\n                        var index2 = pickArbitraryLaneIndex(lanes);\r\n                        var lane = 1 << index2;\r\n                        var expirationTime = expirationTimes[index2];\r\n                        if (expirationTime === NoTimestamp) {\r\n                            if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\r\n                                expirationTimes[index2] = computeExpirationTime(lane, currentTime);\r\n                            }\r\n                        }\r\n                        else if (expirationTime <= currentTime) {\r\n                            root2.expiredLanes |= lane;\r\n                        }\r\n                        lanes &= ~lane;\r\n                    }\r\n                }\r\n                function getHighestPriorityPendingLanes(root2) {\r\n                    return getHighestPriorityLanes(root2.pendingLanes);\r\n                }\r\n                function getLanesToRetrySynchronouslyOnError(root2) {\r\n                    var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;\r\n                    if (everythingButOffscreen !== NoLanes) {\r\n                        return everythingButOffscreen;\r\n                    }\r\n                    if (everythingButOffscreen & OffscreenLane) {\r\n                        return OffscreenLane;\r\n                    }\r\n                    return NoLanes;\r\n                }\r\n                function includesSyncLane(lanes) {\r\n                    return (lanes & SyncLane) !== NoLanes;\r\n                }\r\n                function includesNonIdleWork(lanes) {\r\n                    return (lanes & NonIdleLanes) !== NoLanes;\r\n                }\r\n                function includesOnlyRetries(lanes) {\r\n                    return (lanes & RetryLanes) === lanes;\r\n                }\r\n                function includesOnlyNonUrgentLanes(lanes) {\r\n                    var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\r\n                    return (lanes & UrgentLanes) === NoLanes;\r\n                }\r\n                function includesOnlyTransitions(lanes) {\r\n                    return (lanes & TransitionLanes) === lanes;\r\n                }\r\n                function includesBlockingLane(root2, lanes) {\r\n                    var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\r\n                    return (lanes & SyncDefaultLanes) !== NoLanes;\r\n                }\r\n                function includesExpiredLane(root2, lanes) {\r\n                    return (lanes & root2.expiredLanes) !== NoLanes;\r\n                }\r\n                function isTransitionLane(lane) {\r\n                    return (lane & TransitionLanes) !== NoLanes;\r\n                }\r\n                function claimNextTransitionLane() {\r\n                    var lane = nextTransitionLane;\r\n                    nextTransitionLane <<= 1;\r\n                    if ((nextTransitionLane & TransitionLanes) === NoLanes) {\r\n                        nextTransitionLane = TransitionLane1;\r\n                    }\r\n                    return lane;\r\n                }\r\n                function claimNextRetryLane() {\r\n                    var lane = nextRetryLane;\r\n                    nextRetryLane <<= 1;\r\n                    if ((nextRetryLane & RetryLanes) === NoLanes) {\r\n                        nextRetryLane = RetryLane1;\r\n                    }\r\n                    return lane;\r\n                }\r\n                function getHighestPriorityLane(lanes) {\r\n                    return lanes & -lanes;\r\n                }\r\n                function pickArbitraryLane(lanes) {\r\n                    return getHighestPriorityLane(lanes);\r\n                }\r\n                function pickArbitraryLaneIndex(lanes) {\r\n                    return 31 - clz32(lanes);\r\n                }\r\n                function laneToIndex(lane) {\r\n                    return pickArbitraryLaneIndex(lane);\r\n                }\r\n                function includesSomeLane(a2, b2) {\r\n                    return (a2 & b2) !== NoLanes;\r\n                }\r\n                function isSubsetOfLanes(set2, subset) {\r\n                    return (set2 & subset) === subset;\r\n                }\r\n                function mergeLanes(a2, b2) {\r\n                    return a2 | b2;\r\n                }\r\n                function removeLanes(set2, subset) {\r\n                    return set2 & ~subset;\r\n                }\r\n                function intersectLanes(a2, b2) {\r\n                    return a2 & b2;\r\n                }\r\n                function laneToLanes(lane) {\r\n                    return lane;\r\n                }\r\n                function higherPriorityLane(a2, b2) {\r\n                    return a2 !== NoLane && a2 < b2 ? a2 : b2;\r\n                }\r\n                function createLaneMap(initial) {\r\n                    var laneMap = [];\r\n                    for (var i2 = 0; i2 < TotalLanes; i2++) {\r\n                        laneMap.push(initial);\r\n                    }\r\n                    return laneMap;\r\n                }\r\n                function markRootUpdated(root2, updateLane, eventTime) {\r\n                    root2.pendingLanes |= updateLane;\r\n                    if (updateLane !== IdleLane) {\r\n                        root2.suspendedLanes = NoLanes;\r\n                        root2.pingedLanes = NoLanes;\r\n                    }\r\n                    var eventTimes = root2.eventTimes;\r\n                    var index2 = laneToIndex(updateLane);\r\n                    eventTimes[index2] = eventTime;\r\n                }\r\n                function markRootSuspended(root2, suspendedLanes) {\r\n                    root2.suspendedLanes |= suspendedLanes;\r\n                    root2.pingedLanes &= ~suspendedLanes;\r\n                    var expirationTimes = root2.expirationTimes;\r\n                    var lanes = suspendedLanes;\r\n                    while (lanes > 0) {\r\n                        var index2 = pickArbitraryLaneIndex(lanes);\r\n                        var lane = 1 << index2;\r\n                        expirationTimes[index2] = NoTimestamp;\r\n                        lanes &= ~lane;\r\n                    }\r\n                }\r\n                function markRootPinged(root2, pingedLanes, eventTime) {\r\n                    root2.pingedLanes |= root2.suspendedLanes & pingedLanes;\r\n                }\r\n                function markRootFinished(root2, remainingLanes) {\r\n                    var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;\r\n                    root2.pendingLanes = remainingLanes;\r\n                    root2.suspendedLanes = NoLanes;\r\n                    root2.pingedLanes = NoLanes;\r\n                    root2.expiredLanes &= remainingLanes;\r\n                    root2.mutableReadLanes &= remainingLanes;\r\n                    root2.entangledLanes &= remainingLanes;\r\n                    var entanglements = root2.entanglements;\r\n                    var eventTimes = root2.eventTimes;\r\n                    var expirationTimes = root2.expirationTimes;\r\n                    var lanes = noLongerPendingLanes;\r\n                    while (lanes > 0) {\r\n                        var index2 = pickArbitraryLaneIndex(lanes);\r\n                        var lane = 1 << index2;\r\n                        entanglements[index2] = NoLanes;\r\n                        eventTimes[index2] = NoTimestamp;\r\n                        expirationTimes[index2] = NoTimestamp;\r\n                        lanes &= ~lane;\r\n                    }\r\n                }\r\n                function markRootEntangled(root2, entangledLanes) {\r\n                    var rootEntangledLanes = root2.entangledLanes |= entangledLanes;\r\n                    var entanglements = root2.entanglements;\r\n                    var lanes = rootEntangledLanes;\r\n                    while (lanes) {\r\n                        var index2 = pickArbitraryLaneIndex(lanes);\r\n                        var lane = 1 << index2;\r\n                        if (lane & entangledLanes | entanglements[index2] & entangledLanes) {\r\n                            entanglements[index2] |= entangledLanes;\r\n                        }\r\n                        lanes &= ~lane;\r\n                    }\r\n                }\r\n                function getBumpedLaneForHydration(root2, renderLanes2) {\r\n                    var renderLane = getHighestPriorityLane(renderLanes2);\r\n                    var lane;\r\n                    switch (renderLane) {\r\n                        case InputContinuousLane:\r\n                            lane = InputContinuousHydrationLane;\r\n                            break;\r\n                        case DefaultLane:\r\n                            lane = DefaultHydrationLane;\r\n                            break;\r\n                        case TransitionLane1:\r\n                        case TransitionLane2:\r\n                        case TransitionLane3:\r\n                        case TransitionLane4:\r\n                        case TransitionLane5:\r\n                        case TransitionLane6:\r\n                        case TransitionLane7:\r\n                        case TransitionLane8:\r\n                        case TransitionLane9:\r\n                        case TransitionLane10:\r\n                        case TransitionLane11:\r\n                        case TransitionLane12:\r\n                        case TransitionLane13:\r\n                        case TransitionLane14:\r\n                        case TransitionLane15:\r\n                        case TransitionLane16:\r\n                        case RetryLane1:\r\n                        case RetryLane2:\r\n                        case RetryLane3:\r\n                        case RetryLane4:\r\n                        case RetryLane5:\r\n                            lane = TransitionHydrationLane;\r\n                            break;\r\n                        case IdleLane:\r\n                            lane = IdleHydrationLane;\r\n                            break;\r\n                        default:\r\n                            lane = NoLane;\r\n                            break;\r\n                    }\r\n                    if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {\r\n                        return NoLane;\r\n                    }\r\n                    return lane;\r\n                }\r\n                function addFiberToLanesMap(root2, fiber, lanes) {\r\n                    if (!isDevToolsPresent) {\r\n                        return;\r\n                    }\r\n                    var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;\r\n                    while (lanes > 0) {\r\n                        var index2 = laneToIndex(lanes);\r\n                        var lane = 1 << index2;\r\n                        var updaters = pendingUpdatersLaneMap[index2];\r\n                        updaters.add(fiber);\r\n                        lanes &= ~lane;\r\n                    }\r\n                }\r\n                function movePendingFibersToMemoized(root2, lanes) {\r\n                    if (!isDevToolsPresent) {\r\n                        return;\r\n                    }\r\n                    var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;\r\n                    var memoizedUpdaters = root2.memoizedUpdaters;\r\n                    while (lanes > 0) {\r\n                        var index2 = laneToIndex(lanes);\r\n                        var lane = 1 << index2;\r\n                        var updaters = pendingUpdatersLaneMap[index2];\r\n                        if (updaters.size > 0) {\r\n                            updaters.forEach(function (fiber) {\r\n                                var alternate = fiber.alternate;\r\n                                if (alternate === null || !memoizedUpdaters.has(alternate)) {\r\n                                    memoizedUpdaters.add(fiber);\r\n                                }\r\n                            });\r\n                            updaters.clear();\r\n                        }\r\n                        lanes &= ~lane;\r\n                    }\r\n                }\r\n                function getTransitionsForLanes(root2, lanes) {\r\n                    {\r\n                        return null;\r\n                    }\r\n                }\r\n                var DiscreteEventPriority = SyncLane;\r\n                var ContinuousEventPriority = InputContinuousLane;\r\n                var DefaultEventPriority = DefaultLane;\r\n                var IdleEventPriority = IdleLane;\r\n                var currentUpdatePriority = NoLane;\r\n                function getCurrentUpdatePriority() {\r\n                    return currentUpdatePriority;\r\n                }\r\n                function setCurrentUpdatePriority(newPriority) {\r\n                    currentUpdatePriority = newPriority;\r\n                }\r\n                function runWithPriority(priority, fn2) {\r\n                    var previousPriority = currentUpdatePriority;\r\n                    try {\r\n                        currentUpdatePriority = priority;\r\n                        return fn2();\r\n                    }\r\n                    finally {\r\n                        currentUpdatePriority = previousPriority;\r\n                    }\r\n                }\r\n                function higherEventPriority(a2, b2) {\r\n                    return a2 !== 0 && a2 < b2 ? a2 : b2;\r\n                }\r\n                function lowerEventPriority(a2, b2) {\r\n                    return a2 === 0 || a2 > b2 ? a2 : b2;\r\n                }\r\n                function isHigherEventPriority(a2, b2) {\r\n                    return a2 !== 0 && a2 < b2;\r\n                }\r\n                function lanesToEventPriority(lanes) {\r\n                    var lane = getHighestPriorityLane(lanes);\r\n                    if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\r\n                        return DiscreteEventPriority;\r\n                    }\r\n                    if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\r\n                        return ContinuousEventPriority;\r\n                    }\r\n                    if (includesNonIdleWork(lane)) {\r\n                        return DefaultEventPriority;\r\n                    }\r\n                    return IdleEventPriority;\r\n                }\r\n                function isRootDehydrated(root2) {\r\n                    var currentState = root2.current.memoizedState;\r\n                    return currentState.isDehydrated;\r\n                }\r\n                var _attemptSynchronousHydration;\r\n                function setAttemptSynchronousHydration(fn2) {\r\n                    _attemptSynchronousHydration = fn2;\r\n                }\r\n                function attemptSynchronousHydration(fiber) {\r\n                    _attemptSynchronousHydration(fiber);\r\n                }\r\n                var attemptContinuousHydration;\r\n                function setAttemptContinuousHydration(fn2) {\r\n                    attemptContinuousHydration = fn2;\r\n                }\r\n                var attemptHydrationAtCurrentPriority;\r\n                function setAttemptHydrationAtCurrentPriority(fn2) {\r\n                    attemptHydrationAtCurrentPriority = fn2;\r\n                }\r\n                var getCurrentUpdatePriority$1;\r\n                function setGetCurrentUpdatePriority(fn2) {\r\n                    getCurrentUpdatePriority$1 = fn2;\r\n                }\r\n                var attemptHydrationAtPriority;\r\n                function setAttemptHydrationAtPriority(fn2) {\r\n                    attemptHydrationAtPriority = fn2;\r\n                }\r\n                var hasScheduledReplayAttempt = false;\r\n                var queuedDiscreteEvents = [];\r\n                var queuedFocus = null;\r\n                var queuedDrag = null;\r\n                var queuedMouse = null;\r\n                var queuedPointers = new Map();\r\n                var queuedPointerCaptures = new Map();\r\n                var queuedExplicitHydrationTargets = [];\r\n                var discreteReplayableEvents = [\r\n                    \"mousedown\",\r\n                    \"mouseup\",\r\n                    \"touchcancel\",\r\n                    \"touchend\",\r\n                    \"touchstart\",\r\n                    \"auxclick\",\r\n                    \"dblclick\",\r\n                    \"pointercancel\",\r\n                    \"pointerdown\",\r\n                    \"pointerup\",\r\n                    \"dragend\",\r\n                    \"dragstart\",\r\n                    \"drop\",\r\n                    \"compositionend\",\r\n                    \"compositionstart\",\r\n                    \"keydown\",\r\n                    \"keypress\",\r\n                    \"keyup\",\r\n                    \"input\",\r\n                    \"textInput\",\r\n                    \"copy\",\r\n                    \"cut\",\r\n                    \"paste\",\r\n                    \"click\",\r\n                    \"change\",\r\n                    \"contextmenu\",\r\n                    \"reset\",\r\n                    \"submit\"\r\n                ];\r\n                function isDiscreteEventThatRequiresHydration(eventType) {\r\n                    return discreteReplayableEvents.indexOf(eventType) > -1;\r\n                }\r\n                function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n                    return {\r\n                        blockedOn: blockedOn,\r\n                        domEventName: domEventName,\r\n                        eventSystemFlags: eventSystemFlags,\r\n                        nativeEvent: nativeEvent,\r\n                        targetContainers: [targetContainer]\r\n                    };\r\n                }\r\n                function clearIfContinuousEvent(domEventName, nativeEvent) {\r\n                    switch (domEventName) {\r\n                        case \"focusin\":\r\n                        case \"focusout\":\r\n                            queuedFocus = null;\r\n                            break;\r\n                        case \"dragenter\":\r\n                        case \"dragleave\":\r\n                            queuedDrag = null;\r\n                            break;\r\n                        case \"mouseover\":\r\n                        case \"mouseout\":\r\n                            queuedMouse = null;\r\n                            break;\r\n                        case \"pointerover\":\r\n                        case \"pointerout\": {\r\n                            var pointerId = nativeEvent.pointerId;\r\n                            queuedPointers.delete(pointerId);\r\n                            break;\r\n                        }\r\n                        case \"gotpointercapture\":\r\n                        case \"lostpointercapture\": {\r\n                            var _pointerId = nativeEvent.pointerId;\r\n                            queuedPointerCaptures.delete(_pointerId);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n                    if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\r\n                        var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n                        if (blockedOn !== null) {\r\n                            var _fiber2 = getInstanceFromNode(blockedOn);\r\n                            if (_fiber2 !== null) {\r\n                                attemptContinuousHydration(_fiber2);\r\n                            }\r\n                        }\r\n                        return queuedEvent;\r\n                    }\r\n                    existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\r\n                    var targetContainers = existingQueuedEvent.targetContainers;\r\n                    if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {\r\n                        targetContainers.push(targetContainer);\r\n                    }\r\n                    return existingQueuedEvent;\r\n                }\r\n                function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n                    switch (domEventName) {\r\n                        case \"focusin\": {\r\n                            var focusEvent = nativeEvent;\r\n                            queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);\r\n                            return true;\r\n                        }\r\n                        case \"dragenter\": {\r\n                            var dragEvent = nativeEvent;\r\n                            queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);\r\n                            return true;\r\n                        }\r\n                        case \"mouseover\": {\r\n                            var mouseEvent = nativeEvent;\r\n                            queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);\r\n                            return true;\r\n                        }\r\n                        case \"pointerover\": {\r\n                            var pointerEvent = nativeEvent;\r\n                            var pointerId = pointerEvent.pointerId;\r\n                            queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\r\n                            return true;\r\n                        }\r\n                        case \"gotpointercapture\": {\r\n                            var _pointerEvent = nativeEvent;\r\n                            var _pointerId2 = _pointerEvent.pointerId;\r\n                            queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n                function attemptExplicitHydrationTarget(queuedTarget) {\r\n                    var targetInst = getClosestInstanceFromNode(queuedTarget.target);\r\n                    if (targetInst !== null) {\r\n                        var nearestMounted = getNearestMountedFiber(targetInst);\r\n                        if (nearestMounted !== null) {\r\n                            var tag = nearestMounted.tag;\r\n                            if (tag === SuspenseComponent) {\r\n                                var instance = getSuspenseInstanceFromFiber(nearestMounted);\r\n                                if (instance !== null) {\r\n                                    queuedTarget.blockedOn = instance;\r\n                                    attemptHydrationAtPriority(queuedTarget.priority, function () {\r\n                                        attemptHydrationAtCurrentPriority(nearestMounted);\r\n                                    });\r\n                                    return;\r\n                                }\r\n                            }\r\n                            else if (tag === HostRoot) {\r\n                                var root2 = nearestMounted.stateNode;\r\n                                if (isRootDehydrated(root2)) {\r\n                                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    queuedTarget.blockedOn = null;\r\n                }\r\n                function queueExplicitHydrationTarget(target) {\r\n                    var updatePriority = getCurrentUpdatePriority$1();\r\n                    var queuedTarget = {\r\n                        blockedOn: null,\r\n                        target: target,\r\n                        priority: updatePriority\r\n                    };\r\n                    var i2 = 0;\r\n                    for (; i2 < queuedExplicitHydrationTargets.length; i2++) {\r\n                        if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i2].priority)) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    queuedExplicitHydrationTargets.splice(i2, 0, queuedTarget);\r\n                    if (i2 === 0) {\r\n                        attemptExplicitHydrationTarget(queuedTarget);\r\n                    }\r\n                }\r\n                function attemptReplayContinuousQueuedEvent(queuedEvent) {\r\n                    if (queuedEvent.blockedOn !== null) {\r\n                        return false;\r\n                    }\r\n                    var targetContainers = queuedEvent.targetContainers;\r\n                    while (targetContainers.length > 0) {\r\n                        var targetContainer = targetContainers[0];\r\n                        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);\r\n                        if (nextBlockedOn === null) {\r\n                            {\r\n                                var nativeEvent = queuedEvent.nativeEvent;\r\n                                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);\r\n                                setReplayingEvent(nativeEventClone);\r\n                                nativeEvent.target.dispatchEvent(nativeEventClone);\r\n                                resetReplayingEvent();\r\n                            }\r\n                        }\r\n                        else {\r\n                            var _fiber3 = getInstanceFromNode(nextBlockedOn);\r\n                            if (_fiber3 !== null) {\r\n                                attemptContinuousHydration(_fiber3);\r\n                            }\r\n                            queuedEvent.blockedOn = nextBlockedOn;\r\n                            return false;\r\n                        }\r\n                        targetContainers.shift();\r\n                    }\r\n                    return true;\r\n                }\r\n                function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\r\n                    if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\r\n                        map.delete(key);\r\n                    }\r\n                }\r\n                function replayUnblockedEvents() {\r\n                    hasScheduledReplayAttempt = false;\r\n                    if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\r\n                        queuedFocus = null;\r\n                    }\r\n                    if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\r\n                        queuedDrag = null;\r\n                    }\r\n                    if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\r\n                        queuedMouse = null;\r\n                    }\r\n                    queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\r\n                    queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\r\n                }\r\n                function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\r\n                    if (queuedEvent.blockedOn === unblocked) {\r\n                        queuedEvent.blockedOn = null;\r\n                        if (!hasScheduledReplayAttempt) {\r\n                            hasScheduledReplayAttempt = true;\r\n                            Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);\r\n                        }\r\n                    }\r\n                }\r\n                function retryIfBlockedOn(unblocked) {\r\n                    if (queuedDiscreteEvents.length > 0) {\r\n                        scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\r\n                        for (var i2 = 1; i2 < queuedDiscreteEvents.length; i2++) {\r\n                            var queuedEvent = queuedDiscreteEvents[i2];\r\n                            if (queuedEvent.blockedOn === unblocked) {\r\n                                queuedEvent.blockedOn = null;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (queuedFocus !== null) {\r\n                        scheduleCallbackIfUnblocked(queuedFocus, unblocked);\r\n                    }\r\n                    if (queuedDrag !== null) {\r\n                        scheduleCallbackIfUnblocked(queuedDrag, unblocked);\r\n                    }\r\n                    if (queuedMouse !== null) {\r\n                        scheduleCallbackIfUnblocked(queuedMouse, unblocked);\r\n                    }\r\n                    var unblock = function (queuedEvent2) {\r\n                        return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);\r\n                    };\r\n                    queuedPointers.forEach(unblock);\r\n                    queuedPointerCaptures.forEach(unblock);\r\n                    for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {\r\n                        var queuedTarget = queuedExplicitHydrationTargets[_i];\r\n                        if (queuedTarget.blockedOn === unblocked) {\r\n                            queuedTarget.blockedOn = null;\r\n                        }\r\n                    }\r\n                    while (queuedExplicitHydrationTargets.length > 0) {\r\n                        var nextExplicitTarget = queuedExplicitHydrationTargets[0];\r\n                        if (nextExplicitTarget.blockedOn !== null) {\r\n                            break;\r\n                        }\r\n                        else {\r\n                            attemptExplicitHydrationTarget(nextExplicitTarget);\r\n                            if (nextExplicitTarget.blockedOn === null) {\r\n                                queuedExplicitHydrationTargets.shift();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\r\n                var _enabled = true;\r\n                function setEnabled(enabled) {\r\n                    _enabled = !!enabled;\r\n                }\r\n                function isEnabled() {\r\n                    return _enabled;\r\n                }\r\n                function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {\r\n                    var eventPriority = getEventPriority(domEventName);\r\n                    var listenerWrapper;\r\n                    switch (eventPriority) {\r\n                        case DiscreteEventPriority:\r\n                            listenerWrapper = dispatchDiscreteEvent;\r\n                            break;\r\n                        case ContinuousEventPriority:\r\n                            listenerWrapper = dispatchContinuousEvent;\r\n                            break;\r\n                        case DefaultEventPriority:\r\n                        default:\r\n                            listenerWrapper = dispatchEvent;\r\n                            break;\r\n                    }\r\n                    return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\r\n                }\r\n                function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\r\n                    var previousPriority = getCurrentUpdatePriority();\r\n                    var prevTransition = ReactCurrentBatchConfig.transition;\r\n                    ReactCurrentBatchConfig.transition = null;\r\n                    try {\r\n                        setCurrentUpdatePriority(DiscreteEventPriority);\r\n                        dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\r\n                    }\r\n                    finally {\r\n                        setCurrentUpdatePriority(previousPriority);\r\n                        ReactCurrentBatchConfig.transition = prevTransition;\r\n                    }\r\n                }\r\n                function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {\r\n                    var previousPriority = getCurrentUpdatePriority();\r\n                    var prevTransition = ReactCurrentBatchConfig.transition;\r\n                    ReactCurrentBatchConfig.transition = null;\r\n                    try {\r\n                        setCurrentUpdatePriority(ContinuousEventPriority);\r\n                        dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\r\n                    }\r\n                    finally {\r\n                        setCurrentUpdatePriority(previousPriority);\r\n                        ReactCurrentBatchConfig.transition = prevTransition;\r\n                    }\r\n                }\r\n                function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n                    if (!_enabled) {\r\n                        return;\r\n                    }\r\n                    {\r\n                        dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n                    }\r\n                }\r\n                function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n                    var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n                    if (blockedOn === null) {\r\n                        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\r\n                        clearIfContinuousEvent(domEventName, nativeEvent);\r\n                        return;\r\n                    }\r\n                    if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\r\n                        nativeEvent.stopPropagation();\r\n                        return;\r\n                    }\r\n                    clearIfContinuousEvent(domEventName, nativeEvent);\r\n                    if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {\r\n                        while (blockedOn !== null) {\r\n                            var fiber = getInstanceFromNode(blockedOn);\r\n                            if (fiber !== null) {\r\n                                attemptSynchronousHydration(fiber);\r\n                            }\r\n                            var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\r\n                            if (nextBlockedOn === null) {\r\n                                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\r\n                            }\r\n                            if (nextBlockedOn === blockedOn) {\r\n                                break;\r\n                            }\r\n                            blockedOn = nextBlockedOn;\r\n                        }\r\n                        if (blockedOn !== null) {\r\n                            nativeEvent.stopPropagation();\r\n                        }\r\n                        return;\r\n                    }\r\n                    dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\r\n                }\r\n                var return_targetInst = null;\r\n                function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\r\n                    return_targetInst = null;\r\n                    var nativeEventTarget = getEventTarget(nativeEvent);\r\n                    var targetInst = getClosestInstanceFromNode(nativeEventTarget);\r\n                    if (targetInst !== null) {\r\n                        var nearestMounted = getNearestMountedFiber(targetInst);\r\n                        if (nearestMounted === null) {\r\n                            targetInst = null;\r\n                        }\r\n                        else {\r\n                            var tag = nearestMounted.tag;\r\n                            if (tag === SuspenseComponent) {\r\n                                var instance = getSuspenseInstanceFromFiber(nearestMounted);\r\n                                if (instance !== null) {\r\n                                    return instance;\r\n                                }\r\n                                targetInst = null;\r\n                            }\r\n                            else if (tag === HostRoot) {\r\n                                var root2 = nearestMounted.stateNode;\r\n                                if (isRootDehydrated(root2)) {\r\n                                    return getContainerFromFiber(nearestMounted);\r\n                                }\r\n                                targetInst = null;\r\n                            }\r\n                            else if (nearestMounted !== targetInst) {\r\n                                targetInst = null;\r\n                            }\r\n                        }\r\n                    }\r\n                    return_targetInst = targetInst;\r\n                    return null;\r\n                }\r\n                function getEventPriority(domEventName) {\r\n                    switch (domEventName) {\r\n                        case \"cancel\":\r\n                        case \"click\":\r\n                        case \"close\":\r\n                        case \"contextmenu\":\r\n                        case \"copy\":\r\n                        case \"cut\":\r\n                        case \"auxclick\":\r\n                        case \"dblclick\":\r\n                        case \"dragend\":\r\n                        case \"dragstart\":\r\n                        case \"drop\":\r\n                        case \"focusin\":\r\n                        case \"focusout\":\r\n                        case \"input\":\r\n                        case \"invalid\":\r\n                        case \"keydown\":\r\n                        case \"keypress\":\r\n                        case \"keyup\":\r\n                        case \"mousedown\":\r\n                        case \"mouseup\":\r\n                        case \"paste\":\r\n                        case \"pause\":\r\n                        case \"play\":\r\n                        case \"pointercancel\":\r\n                        case \"pointerdown\":\r\n                        case \"pointerup\":\r\n                        case \"ratechange\":\r\n                        case \"reset\":\r\n                        case \"resize\":\r\n                        case \"seeked\":\r\n                        case \"submit\":\r\n                        case \"touchcancel\":\r\n                        case \"touchend\":\r\n                        case \"touchstart\":\r\n                        case \"volumechange\":\r\n                        case \"change\":\r\n                        case \"selectionchange\":\r\n                        case \"textInput\":\r\n                        case \"compositionstart\":\r\n                        case \"compositionend\":\r\n                        case \"compositionupdate\":\r\n                        case \"beforeblur\":\r\n                        case \"afterblur\":\r\n                        case \"beforeinput\":\r\n                        case \"blur\":\r\n                        case \"fullscreenchange\":\r\n                        case \"focus\":\r\n                        case \"hashchange\":\r\n                        case \"popstate\":\r\n                        case \"select\":\r\n                        case \"selectstart\":\r\n                            return DiscreteEventPriority;\r\n                        case \"drag\":\r\n                        case \"dragenter\":\r\n                        case \"dragexit\":\r\n                        case \"dragleave\":\r\n                        case \"dragover\":\r\n                        case \"mousemove\":\r\n                        case \"mouseout\":\r\n                        case \"mouseover\":\r\n                        case \"pointermove\":\r\n                        case \"pointerout\":\r\n                        case \"pointerover\":\r\n                        case \"scroll\":\r\n                        case \"toggle\":\r\n                        case \"touchmove\":\r\n                        case \"wheel\":\r\n                        case \"mouseenter\":\r\n                        case \"mouseleave\":\r\n                        case \"pointerenter\":\r\n                        case \"pointerleave\":\r\n                            return ContinuousEventPriority;\r\n                        case \"message\": {\r\n                            var schedulerPriority = getCurrentPriorityLevel();\r\n                            switch (schedulerPriority) {\r\n                                case ImmediatePriority:\r\n                                    return DiscreteEventPriority;\r\n                                case UserBlockingPriority:\r\n                                    return ContinuousEventPriority;\r\n                                case NormalPriority:\r\n                                case LowPriority:\r\n                                    return DefaultEventPriority;\r\n                                case IdlePriority:\r\n                                    return IdleEventPriority;\r\n                                default:\r\n                                    return DefaultEventPriority;\r\n                            }\r\n                        }\r\n                        default:\r\n                            return DefaultEventPriority;\r\n                    }\r\n                }\r\n                function addEventBubbleListener(target, eventType, listener) {\r\n                    target.addEventListener(eventType, listener, false);\r\n                    return listener;\r\n                }\r\n                function addEventCaptureListener(target, eventType, listener) {\r\n                    target.addEventListener(eventType, listener, true);\r\n                    return listener;\r\n                }\r\n                function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {\r\n                    target.addEventListener(eventType, listener, {\r\n                        capture: true,\r\n                        passive: passive\r\n                    });\r\n                    return listener;\r\n                }\r\n                function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {\r\n                    target.addEventListener(eventType, listener, {\r\n                        passive: passive\r\n                    });\r\n                    return listener;\r\n                }\r\n                var root = null;\r\n                var startText = null;\r\n                var fallbackText = null;\r\n                function initialize(nativeEventTarget) {\r\n                    root = nativeEventTarget;\r\n                    startText = getText();\r\n                    return true;\r\n                }\r\n                function reset() {\r\n                    root = null;\r\n                    startText = null;\r\n                    fallbackText = null;\r\n                }\r\n                function getData() {\r\n                    if (fallbackText) {\r\n                        return fallbackText;\r\n                    }\r\n                    var start;\r\n                    var startValue = startText;\r\n                    var startLength = startValue.length;\r\n                    var end;\r\n                    var endValue = getText();\r\n                    var endLength = endValue.length;\r\n                    for (start = 0; start < startLength; start++) {\r\n                        if (startValue[start] !== endValue[start]) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    var minEnd = startLength - start;\r\n                    for (end = 1; end <= minEnd; end++) {\r\n                        if (startValue[startLength - end] !== endValue[endLength - end]) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    var sliceTail = end > 1 ? 1 - end : void 0;\r\n                    fallbackText = endValue.slice(start, sliceTail);\r\n                    return fallbackText;\r\n                }\r\n                function getText() {\r\n                    if (\"value\" in root) {\r\n                        return root.value;\r\n                    }\r\n                    return root.textContent;\r\n                }\r\n                function getEventCharCode(nativeEvent) {\r\n                    var charCode;\r\n                    var keyCode = nativeEvent.keyCode;\r\n                    if (\"charCode\" in nativeEvent) {\r\n                        charCode = nativeEvent.charCode;\r\n                        if (charCode === 0 && keyCode === 13) {\r\n                            charCode = 13;\r\n                        }\r\n                    }\r\n                    else {\r\n                        charCode = keyCode;\r\n                    }\r\n                    if (charCode === 10) {\r\n                        charCode = 13;\r\n                    }\r\n                    if (charCode >= 32 || charCode === 13) {\r\n                        return charCode;\r\n                    }\r\n                    return 0;\r\n                }\r\n                function functionThatReturnsTrue() {\r\n                    return true;\r\n                }\r\n                function functionThatReturnsFalse() {\r\n                    return false;\r\n                }\r\n                function createSyntheticEvent(Interface) {\r\n                    function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {\r\n                        this._reactName = reactName;\r\n                        this._targetInst = targetInst;\r\n                        this.type = reactEventType;\r\n                        this.nativeEvent = nativeEvent;\r\n                        this.target = nativeEventTarget;\r\n                        this.currentTarget = null;\r\n                        for (var _propName in Interface) {\r\n                            if (!Interface.hasOwnProperty(_propName)) {\r\n                                continue;\r\n                            }\r\n                            var normalize = Interface[_propName];\r\n                            if (normalize) {\r\n                                this[_propName] = normalize(nativeEvent);\r\n                            }\r\n                            else {\r\n                                this[_propName] = nativeEvent[_propName];\r\n                            }\r\n                        }\r\n                        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\r\n                        if (defaultPrevented) {\r\n                            this.isDefaultPrevented = functionThatReturnsTrue;\r\n                        }\r\n                        else {\r\n                            this.isDefaultPrevented = functionThatReturnsFalse;\r\n                        }\r\n                        this.isPropagationStopped = functionThatReturnsFalse;\r\n                        return this;\r\n                    }\r\n                    assign(SyntheticBaseEvent.prototype, {\r\n                        preventDefault: function () {\r\n                            this.defaultPrevented = true;\r\n                            var event = this.nativeEvent;\r\n                            if (!event) {\r\n                                return;\r\n                            }\r\n                            if (event.preventDefault) {\r\n                                event.preventDefault();\r\n                            }\r\n                            else if (typeof event.returnValue !== \"unknown\") {\r\n                                event.returnValue = false;\r\n                            }\r\n                            this.isDefaultPrevented = functionThatReturnsTrue;\r\n                        },\r\n                        stopPropagation: function () {\r\n                            var event = this.nativeEvent;\r\n                            if (!event) {\r\n                                return;\r\n                            }\r\n                            if (event.stopPropagation) {\r\n                                event.stopPropagation();\r\n                            }\r\n                            else if (typeof event.cancelBubble !== \"unknown\") {\r\n                                event.cancelBubble = true;\r\n                            }\r\n                            this.isPropagationStopped = functionThatReturnsTrue;\r\n                        },\r\n                        persist: function () {\r\n                        },\r\n                        isPersistent: functionThatReturnsTrue\r\n                    });\r\n                    return SyntheticBaseEvent;\r\n                }\r\n                var EventInterface = {\r\n                    eventPhase: 0,\r\n                    bubbles: 0,\r\n                    cancelable: 0,\r\n                    timeStamp: function (event) {\r\n                        return event.timeStamp || Date.now();\r\n                    },\r\n                    defaultPrevented: 0,\r\n                    isTrusted: 0\r\n                };\r\n                var SyntheticEvent = createSyntheticEvent(EventInterface);\r\n                var UIEventInterface = assign({}, EventInterface, {\r\n                    view: 0,\r\n                    detail: 0\r\n                });\r\n                var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);\r\n                var lastMovementX;\r\n                var lastMovementY;\r\n                var lastMouseEvent;\r\n                function updateMouseMovementPolyfillState(event) {\r\n                    if (event !== lastMouseEvent) {\r\n                        if (lastMouseEvent && event.type === \"mousemove\") {\r\n                            lastMovementX = event.screenX - lastMouseEvent.screenX;\r\n                            lastMovementY = event.screenY - lastMouseEvent.screenY;\r\n                        }\r\n                        else {\r\n                            lastMovementX = 0;\r\n                            lastMovementY = 0;\r\n                        }\r\n                        lastMouseEvent = event;\r\n                    }\r\n                }\r\n                var MouseEventInterface = assign({}, UIEventInterface, {\r\n                    screenX: 0,\r\n                    screenY: 0,\r\n                    clientX: 0,\r\n                    clientY: 0,\r\n                    pageX: 0,\r\n                    pageY: 0,\r\n                    ctrlKey: 0,\r\n                    shiftKey: 0,\r\n                    altKey: 0,\r\n                    metaKey: 0,\r\n                    getModifierState: getEventModifierState,\r\n                    button: 0,\r\n                    buttons: 0,\r\n                    relatedTarget: function (event) {\r\n                        if (event.relatedTarget === void 0)\r\n                            return event.fromElement === event.srcElement ? event.toElement : event.fromElement;\r\n                        return event.relatedTarget;\r\n                    },\r\n                    movementX: function (event) {\r\n                        if (\"movementX\" in event) {\r\n                            return event.movementX;\r\n                        }\r\n                        updateMouseMovementPolyfillState(event);\r\n                        return lastMovementX;\r\n                    },\r\n                    movementY: function (event) {\r\n                        if (\"movementY\" in event) {\r\n                            return event.movementY;\r\n                        }\r\n                        return lastMovementY;\r\n                    }\r\n                });\r\n                var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);\r\n                var DragEventInterface = assign({}, MouseEventInterface, {\r\n                    dataTransfer: 0\r\n                });\r\n                var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);\r\n                var FocusEventInterface = assign({}, UIEventInterface, {\r\n                    relatedTarget: 0\r\n                });\r\n                var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);\r\n                var AnimationEventInterface = assign({}, EventInterface, {\r\n                    animationName: 0,\r\n                    elapsedTime: 0,\r\n                    pseudoElement: 0\r\n                });\r\n                var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);\r\n                var ClipboardEventInterface = assign({}, EventInterface, {\r\n                    clipboardData: function (event) {\r\n                        return \"clipboardData\" in event ? event.clipboardData : window.clipboardData;\r\n                    }\r\n                });\r\n                var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);\r\n                var CompositionEventInterface = assign({}, EventInterface, {\r\n                    data: 0\r\n                });\r\n                var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);\r\n                var SyntheticInputEvent = SyntheticCompositionEvent;\r\n                var normalizeKey = {\r\n                    Esc: \"Escape\",\r\n                    Spacebar: \" \",\r\n                    Left: \"ArrowLeft\",\r\n                    Up: \"ArrowUp\",\r\n                    Right: \"ArrowRight\",\r\n                    Down: \"ArrowDown\",\r\n                    Del: \"Delete\",\r\n                    Win: \"OS\",\r\n                    Menu: \"ContextMenu\",\r\n                    Apps: \"ContextMenu\",\r\n                    Scroll: \"ScrollLock\",\r\n                    MozPrintableKey: \"Unidentified\"\r\n                };\r\n                var translateToKey = {\r\n                    \"8\": \"Backspace\",\r\n                    \"9\": \"Tab\",\r\n                    \"12\": \"Clear\",\r\n                    \"13\": \"Enter\",\r\n                    \"16\": \"Shift\",\r\n                    \"17\": \"Control\",\r\n                    \"18\": \"Alt\",\r\n                    \"19\": \"Pause\",\r\n                    \"20\": \"CapsLock\",\r\n                    \"27\": \"Escape\",\r\n                    \"32\": \" \",\r\n                    \"33\": \"PageUp\",\r\n                    \"34\": \"PageDown\",\r\n                    \"35\": \"End\",\r\n                    \"36\": \"Home\",\r\n                    \"37\": \"ArrowLeft\",\r\n                    \"38\": \"ArrowUp\",\r\n                    \"39\": \"ArrowRight\",\r\n                    \"40\": \"ArrowDown\",\r\n                    \"45\": \"Insert\",\r\n                    \"46\": \"Delete\",\r\n                    \"112\": \"F1\",\r\n                    \"113\": \"F2\",\r\n                    \"114\": \"F3\",\r\n                    \"115\": \"F4\",\r\n                    \"116\": \"F5\",\r\n                    \"117\": \"F6\",\r\n                    \"118\": \"F7\",\r\n                    \"119\": \"F8\",\r\n                    \"120\": \"F9\",\r\n                    \"121\": \"F10\",\r\n                    \"122\": \"F11\",\r\n                    \"123\": \"F12\",\r\n                    \"144\": \"NumLock\",\r\n                    \"145\": \"ScrollLock\",\r\n                    \"224\": \"Meta\"\r\n                };\r\n                function getEventKey(nativeEvent) {\r\n                    if (nativeEvent.key) {\r\n                        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\r\n                        if (key !== \"Unidentified\") {\r\n                            return key;\r\n                        }\r\n                    }\r\n                    if (nativeEvent.type === \"keypress\") {\r\n                        var charCode = getEventCharCode(nativeEvent);\r\n                        return charCode === 13 ? \"Enter\" : String.fromCharCode(charCode);\r\n                    }\r\n                    if (nativeEvent.type === \"keydown\" || nativeEvent.type === \"keyup\") {\r\n                        return translateToKey[nativeEvent.keyCode] || \"Unidentified\";\r\n                    }\r\n                    return \"\";\r\n                }\r\n                var modifierKeyToProp = {\r\n                    Alt: \"altKey\",\r\n                    Control: \"ctrlKey\",\r\n                    Meta: \"metaKey\",\r\n                    Shift: \"shiftKey\"\r\n                };\r\n                function modifierStateGetter(keyArg) {\r\n                    var syntheticEvent = this;\r\n                    var nativeEvent = syntheticEvent.nativeEvent;\r\n                    if (nativeEvent.getModifierState) {\r\n                        return nativeEvent.getModifierState(keyArg);\r\n                    }\r\n                    var keyProp = modifierKeyToProp[keyArg];\r\n                    return keyProp ? !!nativeEvent[keyProp] : false;\r\n                }\r\n                function getEventModifierState(nativeEvent) {\r\n                    return modifierStateGetter;\r\n                }\r\n                var KeyboardEventInterface = assign({}, UIEventInterface, {\r\n                    key: getEventKey,\r\n                    code: 0,\r\n                    location: 0,\r\n                    ctrlKey: 0,\r\n                    shiftKey: 0,\r\n                    altKey: 0,\r\n                    metaKey: 0,\r\n                    repeat: 0,\r\n                    locale: 0,\r\n                    getModifierState: getEventModifierState,\r\n                    charCode: function (event) {\r\n                        if (event.type === \"keypress\") {\r\n                            return getEventCharCode(event);\r\n                        }\r\n                        return 0;\r\n                    },\r\n                    keyCode: function (event) {\r\n                        if (event.type === \"keydown\" || event.type === \"keyup\") {\r\n                            return event.keyCode;\r\n                        }\r\n                        return 0;\r\n                    },\r\n                    which: function (event) {\r\n                        if (event.type === \"keypress\") {\r\n                            return getEventCharCode(event);\r\n                        }\r\n                        if (event.type === \"keydown\" || event.type === \"keyup\") {\r\n                            return event.keyCode;\r\n                        }\r\n                        return 0;\r\n                    }\r\n                });\r\n                var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);\r\n                var PointerEventInterface = assign({}, MouseEventInterface, {\r\n                    pointerId: 0,\r\n                    width: 0,\r\n                    height: 0,\r\n                    pressure: 0,\r\n                    tangentialPressure: 0,\r\n                    tiltX: 0,\r\n                    tiltY: 0,\r\n                    twist: 0,\r\n                    pointerType: 0,\r\n                    isPrimary: 0\r\n                });\r\n                var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);\r\n                var TouchEventInterface = assign({}, UIEventInterface, {\r\n                    touches: 0,\r\n                    targetTouches: 0,\r\n                    changedTouches: 0,\r\n                    altKey: 0,\r\n                    metaKey: 0,\r\n                    ctrlKey: 0,\r\n                    shiftKey: 0,\r\n                    getModifierState: getEventModifierState\r\n                });\r\n                var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);\r\n                var TransitionEventInterface = assign({}, EventInterface, {\r\n                    propertyName: 0,\r\n                    elapsedTime: 0,\r\n                    pseudoElement: 0\r\n                });\r\n                var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);\r\n                var WheelEventInterface = assign({}, MouseEventInterface, {\r\n                    deltaX: function (event) {\r\n                        return \"deltaX\" in event ? event.deltaX : \"wheelDeltaX\" in event ? -event.wheelDeltaX : 0;\r\n                    },\r\n                    deltaY: function (event) {\r\n                        return \"deltaY\" in event ? event.deltaY : \"wheelDeltaY\" in event ? -event.wheelDeltaY : \"wheelDelta\" in event ? -event.wheelDelta : 0;\r\n                    },\r\n                    deltaZ: 0,\r\n                    deltaMode: 0\r\n                });\r\n                var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);\r\n                var END_KEYCODES = [9, 13, 27, 32];\r\n                var START_KEYCODE = 229;\r\n                var canUseCompositionEvent = canUseDOM2 && \"CompositionEvent\" in window;\r\n                var documentMode = null;\r\n                if (canUseDOM2 && \"documentMode\" in document) {\r\n                    documentMode = document.documentMode;\r\n                }\r\n                var canUseTextInputEvent = canUseDOM2 && \"TextEvent\" in window && !documentMode;\r\n                var useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\r\n                var SPACEBAR_CODE = 32;\r\n                var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\r\n                function registerEvents() {\r\n                    registerTwoPhaseEvent(\"onBeforeInput\", [\"compositionend\", \"keypress\", \"textInput\", \"paste\"]);\r\n                    registerTwoPhaseEvent(\"onCompositionEnd\", [\"compositionend\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\r\n                    registerTwoPhaseEvent(\"onCompositionStart\", [\"compositionstart\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\r\n                    registerTwoPhaseEvent(\"onCompositionUpdate\", [\"compositionupdate\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\r\n                }\r\n                var hasSpaceKeypress = false;\r\n                function isKeypressCommand(nativeEvent) {\r\n                    return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);\r\n                }\r\n                function getCompositionEventType(domEventName) {\r\n                    switch (domEventName) {\r\n                        case \"compositionstart\":\r\n                            return \"onCompositionStart\";\r\n                        case \"compositionend\":\r\n                            return \"onCompositionEnd\";\r\n                        case \"compositionupdate\":\r\n                            return \"onCompositionUpdate\";\r\n                    }\r\n                }\r\n                function isFallbackCompositionStart(domEventName, nativeEvent) {\r\n                    return domEventName === \"keydown\" && nativeEvent.keyCode === START_KEYCODE;\r\n                }\r\n                function isFallbackCompositionEnd(domEventName, nativeEvent) {\r\n                    switch (domEventName) {\r\n                        case \"keyup\":\r\n                            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\r\n                        case \"keydown\":\r\n                            return nativeEvent.keyCode !== START_KEYCODE;\r\n                        case \"keypress\":\r\n                        case \"mousedown\":\r\n                        case \"focusout\":\r\n                            return true;\r\n                        default:\r\n                            return false;\r\n                    }\r\n                }\r\n                function getDataFromCustomEvent(nativeEvent) {\r\n                    var detail = nativeEvent.detail;\r\n                    if (typeof detail === \"object\" && \"data\" in detail) {\r\n                        return detail.data;\r\n                    }\r\n                    return null;\r\n                }\r\n                function isUsingKoreanIME(nativeEvent) {\r\n                    return nativeEvent.locale === \"ko\";\r\n                }\r\n                var isComposing = false;\r\n                function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\r\n                    var eventType;\r\n                    var fallbackData;\r\n                    if (canUseCompositionEvent) {\r\n                        eventType = getCompositionEventType(domEventName);\r\n                    }\r\n                    else if (!isComposing) {\r\n                        if (isFallbackCompositionStart(domEventName, nativeEvent)) {\r\n                            eventType = \"onCompositionStart\";\r\n                        }\r\n                    }\r\n                    else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\r\n                        eventType = \"onCompositionEnd\";\r\n                    }\r\n                    if (!eventType) {\r\n                        return null;\r\n                    }\r\n                    if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\r\n                        if (!isComposing && eventType === \"onCompositionStart\") {\r\n                            isComposing = initialize(nativeEventTarget);\r\n                        }\r\n                        else if (eventType === \"onCompositionEnd\") {\r\n                            if (isComposing) {\r\n                                fallbackData = getData();\r\n                            }\r\n                        }\r\n                    }\r\n                    var listeners = accumulateTwoPhaseListeners(targetInst, eventType);\r\n                    if (listeners.length > 0) {\r\n                        var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);\r\n                        dispatchQueue.push({\r\n                            event: event,\r\n                            listeners: listeners\r\n                        });\r\n                        if (fallbackData) {\r\n                            event.data = fallbackData;\r\n                        }\r\n                        else {\r\n                            var customData = getDataFromCustomEvent(nativeEvent);\r\n                            if (customData !== null) {\r\n                                event.data = customData;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function getNativeBeforeInputChars(domEventName, nativeEvent) {\r\n                    switch (domEventName) {\r\n                        case \"compositionend\":\r\n                            return getDataFromCustomEvent(nativeEvent);\r\n                        case \"keypress\":\r\n                            var which = nativeEvent.which;\r\n                            if (which !== SPACEBAR_CODE) {\r\n                                return null;\r\n                            }\r\n                            hasSpaceKeypress = true;\r\n                            return SPACEBAR_CHAR;\r\n                        case \"textInput\":\r\n                            var chars = nativeEvent.data;\r\n                            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\r\n                                return null;\r\n                            }\r\n                            return chars;\r\n                        default:\r\n                            return null;\r\n                    }\r\n                }\r\n                function getFallbackBeforeInputChars(domEventName, nativeEvent) {\r\n                    if (isComposing) {\r\n                        if (domEventName === \"compositionend\" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {\r\n                            var chars = getData();\r\n                            reset();\r\n                            isComposing = false;\r\n                            return chars;\r\n                        }\r\n                        return null;\r\n                    }\r\n                    switch (domEventName) {\r\n                        case \"paste\":\r\n                            return null;\r\n                        case \"keypress\":\r\n                            if (!isKeypressCommand(nativeEvent)) {\r\n                                if (nativeEvent.char && nativeEvent.char.length > 1) {\r\n                                    return nativeEvent.char;\r\n                                }\r\n                                else if (nativeEvent.which) {\r\n                                    return String.fromCharCode(nativeEvent.which);\r\n                                }\r\n                            }\r\n                            return null;\r\n                        case \"compositionend\":\r\n                            return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\r\n                        default:\r\n                            return null;\r\n                    }\r\n                }\r\n                function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\r\n                    var chars;\r\n                    if (canUseTextInputEvent) {\r\n                        chars = getNativeBeforeInputChars(domEventName, nativeEvent);\r\n                    }\r\n                    else {\r\n                        chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\r\n                    }\r\n                    if (!chars) {\r\n                        return null;\r\n                    }\r\n                    var listeners = accumulateTwoPhaseListeners(targetInst, \"onBeforeInput\");\r\n                    if (listeners.length > 0) {\r\n                        var event = new SyntheticInputEvent(\"onBeforeInput\", \"beforeinput\", null, nativeEvent, nativeEventTarget);\r\n                        dispatchQueue.push({\r\n                            event: event,\r\n                            listeners: listeners\r\n                        });\r\n                        event.data = chars;\r\n                    }\r\n                }\r\n                function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n                    extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n                    extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n                }\r\n                var supportedInputTypes = {\r\n                    color: true,\r\n                    date: true,\r\n                    datetime: true,\r\n                    \"datetime-local\": true,\r\n                    email: true,\r\n                    month: true,\r\n                    number: true,\r\n                    password: true,\r\n                    range: true,\r\n                    search: true,\r\n                    tel: true,\r\n                    text: true,\r\n                    time: true,\r\n                    url: true,\r\n                    week: true\r\n                };\r\n                function isTextInputElement(elem) {\r\n                    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\r\n                    if (nodeName === \"input\") {\r\n                        return !!supportedInputTypes[elem.type];\r\n                    }\r\n                    if (nodeName === \"textarea\") {\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                }\r\n                function isEventSupported(eventNameSuffix) {\r\n                    if (!canUseDOM2) {\r\n                        return false;\r\n                    }\r\n                    var eventName = \"on\" + eventNameSuffix;\r\n                    var isSupported = eventName in document;\r\n                    if (!isSupported) {\r\n                        var element = document.createElement(\"div\");\r\n                        element.setAttribute(eventName, \"return;\");\r\n                        isSupported = typeof element[eventName] === \"function\";\r\n                    }\r\n                    return isSupported;\r\n                }\r\n                function registerEvents$1() {\r\n                    registerTwoPhaseEvent(\"onChange\", [\"change\", \"click\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"selectionchange\"]);\r\n                }\r\n                function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {\r\n                    enqueueStateRestore(target);\r\n                    var listeners = accumulateTwoPhaseListeners(inst, \"onChange\");\r\n                    if (listeners.length > 0) {\r\n                        var event = new SyntheticEvent(\"onChange\", \"change\", null, nativeEvent, target);\r\n                        dispatchQueue.push({\r\n                            event: event,\r\n                            listeners: listeners\r\n                        });\r\n                    }\r\n                }\r\n                var activeElement = null;\r\n                var activeElementInst = null;\r\n                function shouldUseChangeEvent(elem) {\r\n                    var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\r\n                    return nodeName === \"select\" || nodeName === \"input\" && elem.type === \"file\";\r\n                }\r\n                function manualDispatchChangeEvent(nativeEvent) {\r\n                    var dispatchQueue = [];\r\n                    createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));\r\n                    batchedUpdates(runEventInBatch, dispatchQueue);\r\n                }\r\n                function runEventInBatch(dispatchQueue) {\r\n                    processDispatchQueue(dispatchQueue, 0);\r\n                }\r\n                function getInstIfValueChanged(targetInst) {\r\n                    var targetNode = getNodeFromInstance(targetInst);\r\n                    if (updateValueIfChanged(targetNode)) {\r\n                        return targetInst;\r\n                    }\r\n                }\r\n                function getTargetInstForChangeEvent(domEventName, targetInst) {\r\n                    if (domEventName === \"change\") {\r\n                        return targetInst;\r\n                    }\r\n                }\r\n                var isInputEventSupported = false;\r\n                if (canUseDOM2) {\r\n                    isInputEventSupported = isEventSupported(\"input\") && (!document.documentMode || document.documentMode > 9);\r\n                }\r\n                function startWatchingForValueChange(target, targetInst) {\r\n                    activeElement = target;\r\n                    activeElementInst = targetInst;\r\n                    activeElement.attachEvent(\"onpropertychange\", handlePropertyChange);\r\n                }\r\n                function stopWatchingForValueChange() {\r\n                    if (!activeElement) {\r\n                        return;\r\n                    }\r\n                    activeElement.detachEvent(\"onpropertychange\", handlePropertyChange);\r\n                    activeElement = null;\r\n                    activeElementInst = null;\r\n                }\r\n                function handlePropertyChange(nativeEvent) {\r\n                    if (nativeEvent.propertyName !== \"value\") {\r\n                        return;\r\n                    }\r\n                    if (getInstIfValueChanged(activeElementInst)) {\r\n                        manualDispatchChangeEvent(nativeEvent);\r\n                    }\r\n                }\r\n                function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\r\n                    if (domEventName === \"focusin\") {\r\n                        stopWatchingForValueChange();\r\n                        startWatchingForValueChange(target, targetInst);\r\n                    }\r\n                    else if (domEventName === \"focusout\") {\r\n                        stopWatchingForValueChange();\r\n                    }\r\n                }\r\n                function getTargetInstForInputEventPolyfill(domEventName, targetInst) {\r\n                    if (domEventName === \"selectionchange\" || domEventName === \"keyup\" || domEventName === \"keydown\") {\r\n                        return getInstIfValueChanged(activeElementInst);\r\n                    }\r\n                }\r\n                function shouldUseClickEvent(elem) {\r\n                    var nodeName = elem.nodeName;\r\n                    return nodeName && nodeName.toLowerCase() === \"input\" && (elem.type === \"checkbox\" || elem.type === \"radio\");\r\n                }\r\n                function getTargetInstForClickEvent(domEventName, targetInst) {\r\n                    if (domEventName === \"click\") {\r\n                        return getInstIfValueChanged(targetInst);\r\n                    }\r\n                }\r\n                function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\r\n                    if (domEventName === \"input\" || domEventName === \"change\") {\r\n                        return getInstIfValueChanged(targetInst);\r\n                    }\r\n                }\r\n                function handleControlledInputBlur(node) {\r\n                    var state = node._wrapperState;\r\n                    if (!state || !state.controlled || node.type !== \"number\") {\r\n                        return;\r\n                    }\r\n                    {\r\n                        setDefaultValue(node, \"number\", node.value);\r\n                    }\r\n                }\r\n                function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n                    var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\r\n                    var getTargetInstFunc, handleEventFunc;\r\n                    if (shouldUseChangeEvent(targetNode)) {\r\n                        getTargetInstFunc = getTargetInstForChangeEvent;\r\n                    }\r\n                    else if (isTextInputElement(targetNode)) {\r\n                        if (isInputEventSupported) {\r\n                            getTargetInstFunc = getTargetInstForInputOrChangeEvent;\r\n                        }\r\n                        else {\r\n                            getTargetInstFunc = getTargetInstForInputEventPolyfill;\r\n                            handleEventFunc = handleEventsForInputEventPolyfill;\r\n                        }\r\n                    }\r\n                    else if (shouldUseClickEvent(targetNode)) {\r\n                        getTargetInstFunc = getTargetInstForClickEvent;\r\n                    }\r\n                    if (getTargetInstFunc) {\r\n                        var inst = getTargetInstFunc(domEventName, targetInst);\r\n                        if (inst) {\r\n                            createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (handleEventFunc) {\r\n                        handleEventFunc(domEventName, targetNode, targetInst);\r\n                    }\r\n                    if (domEventName === \"focusout\") {\r\n                        handleControlledInputBlur(targetNode);\r\n                    }\r\n                }\r\n                function registerEvents$2() {\r\n                    registerDirectEvent(\"onMouseEnter\", [\"mouseout\", \"mouseover\"]);\r\n                    registerDirectEvent(\"onMouseLeave\", [\"mouseout\", \"mouseover\"]);\r\n                    registerDirectEvent(\"onPointerEnter\", [\"pointerout\", \"pointerover\"]);\r\n                    registerDirectEvent(\"onPointerLeave\", [\"pointerout\", \"pointerover\"]);\r\n                }\r\n                function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n                    var isOverEvent = domEventName === \"mouseover\" || domEventName === \"pointerover\";\r\n                    var isOutEvent = domEventName === \"mouseout\" || domEventName === \"pointerout\";\r\n                    if (isOverEvent && !isReplayingEvent(nativeEvent)) {\r\n                        var related = nativeEvent.relatedTarget || nativeEvent.fromElement;\r\n                        if (related) {\r\n                            if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (!isOutEvent && !isOverEvent) {\r\n                        return;\r\n                    }\r\n                    var win;\r\n                    if (nativeEventTarget.window === nativeEventTarget) {\r\n                        win = nativeEventTarget;\r\n                    }\r\n                    else {\r\n                        var doc = nativeEventTarget.ownerDocument;\r\n                        if (doc) {\r\n                            win = doc.defaultView || doc.parentWindow;\r\n                        }\r\n                        else {\r\n                            win = window;\r\n                        }\r\n                    }\r\n                    var from;\r\n                    var to;\r\n                    if (isOutEvent) {\r\n                        var _related = nativeEvent.relatedTarget || nativeEvent.toElement;\r\n                        from = targetInst;\r\n                        to = _related ? getClosestInstanceFromNode(_related) : null;\r\n                        if (to !== null) {\r\n                            var nearestMounted = getNearestMountedFiber(to);\r\n                            if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {\r\n                                to = null;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        from = null;\r\n                        to = targetInst;\r\n                    }\r\n                    if (from === to) {\r\n                        return;\r\n                    }\r\n                    var SyntheticEventCtor = SyntheticMouseEvent;\r\n                    var leaveEventType = \"onMouseLeave\";\r\n                    var enterEventType = \"onMouseEnter\";\r\n                    var eventTypePrefix = \"mouse\";\r\n                    if (domEventName === \"pointerout\" || domEventName === \"pointerover\") {\r\n                        SyntheticEventCtor = SyntheticPointerEvent;\r\n                        leaveEventType = \"onPointerLeave\";\r\n                        enterEventType = \"onPointerEnter\";\r\n                        eventTypePrefix = \"pointer\";\r\n                    }\r\n                    var fromNode = from == null ? win : getNodeFromInstance(from);\r\n                    var toNode = to == null ? win : getNodeFromInstance(to);\r\n                    var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + \"leave\", from, nativeEvent, nativeEventTarget);\r\n                    leave.target = fromNode;\r\n                    leave.relatedTarget = toNode;\r\n                    var enter = null;\r\n                    var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);\r\n                    if (nativeTargetInst === targetInst) {\r\n                        var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + \"enter\", to, nativeEvent, nativeEventTarget);\r\n                        enterEvent.target = toNode;\r\n                        enterEvent.relatedTarget = fromNode;\r\n                        enter = enterEvent;\r\n                    }\r\n                    accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);\r\n                }\r\n                function is2(x2, y2) {\r\n                    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;\r\n                }\r\n                var objectIs = typeof Object.is === \"function\" ? Object.is : is2;\r\n                function shallowEqual2(objA, objB) {\r\n                    if (objectIs(objA, objB)) {\r\n                        return true;\r\n                    }\r\n                    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\r\n                        return false;\r\n                    }\r\n                    var keysA = Object.keys(objA);\r\n                    var keysB = Object.keys(objB);\r\n                    if (keysA.length !== keysB.length) {\r\n                        return false;\r\n                    }\r\n                    for (var i2 = 0; i2 < keysA.length; i2++) {\r\n                        var currentKey = keysA[i2];\r\n                        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n                function getLeafNode(node) {\r\n                    while (node && node.firstChild) {\r\n                        node = node.firstChild;\r\n                    }\r\n                    return node;\r\n                }\r\n                function getSiblingNode(node) {\r\n                    while (node) {\r\n                        if (node.nextSibling) {\r\n                            return node.nextSibling;\r\n                        }\r\n                        node = node.parentNode;\r\n                    }\r\n                }\r\n                function getNodeForCharacterOffset(root2, offset) {\r\n                    var node = getLeafNode(root2);\r\n                    var nodeStart = 0;\r\n                    var nodeEnd = 0;\r\n                    while (node) {\r\n                        if (node.nodeType === TEXT_NODE) {\r\n                            nodeEnd = nodeStart + node.textContent.length;\r\n                            if (nodeStart <= offset && nodeEnd >= offset) {\r\n                                return {\r\n                                    node: node,\r\n                                    offset: offset - nodeStart\r\n                                };\r\n                            }\r\n                            nodeStart = nodeEnd;\r\n                        }\r\n                        node = getLeafNode(getSiblingNode(node));\r\n                    }\r\n                }\r\n                function getOffsets(outerNode) {\r\n                    var ownerDocument = outerNode.ownerDocument;\r\n                    var win = ownerDocument && ownerDocument.defaultView || window;\r\n                    var selection = win.getSelection && win.getSelection();\r\n                    if (!selection || selection.rangeCount === 0) {\r\n                        return null;\r\n                    }\r\n                    var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;\r\n                    try {\r\n                        anchorNode.nodeType;\r\n                        focusNode.nodeType;\r\n                    }\r\n                    catch (e2) {\r\n                        return null;\r\n                    }\r\n                    return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\r\n                }\r\n                function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\r\n                    var length = 0;\r\n                    var start = -1;\r\n                    var end = -1;\r\n                    var indexWithinAnchor = 0;\r\n                    var indexWithinFocus = 0;\r\n                    var node = outerNode;\r\n                    var parentNode = null;\r\n                    outer: while (true) {\r\n                        var next = null;\r\n                        while (true) {\r\n                            if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\r\n                                start = length + anchorOffset;\r\n                            }\r\n                            if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\r\n                                end = length + focusOffset;\r\n                            }\r\n                            if (node.nodeType === TEXT_NODE) {\r\n                                length += node.nodeValue.length;\r\n                            }\r\n                            if ((next = node.firstChild) === null) {\r\n                                break;\r\n                            }\r\n                            parentNode = node;\r\n                            node = next;\r\n                        }\r\n                        while (true) {\r\n                            if (node === outerNode) {\r\n                                break outer;\r\n                            }\r\n                            if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\r\n                                start = length;\r\n                            }\r\n                            if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\r\n                                end = length;\r\n                            }\r\n                            if ((next = node.nextSibling) !== null) {\r\n                                break;\r\n                            }\r\n                            node = parentNode;\r\n                            parentNode = node.parentNode;\r\n                        }\r\n                        node = next;\r\n                    }\r\n                    if (start === -1 || end === -1) {\r\n                        return null;\r\n                    }\r\n                    return {\r\n                        start: start,\r\n                        end: end\r\n                    };\r\n                }\r\n                function setOffsets(node, offsets) {\r\n                    var doc = node.ownerDocument || document;\r\n                    var win = doc && doc.defaultView || window;\r\n                    if (!win.getSelection) {\r\n                        return;\r\n                    }\r\n                    var selection = win.getSelection();\r\n                    var length = node.textContent.length;\r\n                    var start = Math.min(offsets.start, length);\r\n                    var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);\r\n                    if (!selection.extend && start > end) {\r\n                        var temp = end;\r\n                        end = start;\r\n                        start = temp;\r\n                    }\r\n                    var startMarker = getNodeForCharacterOffset(node, start);\r\n                    var endMarker = getNodeForCharacterOffset(node, end);\r\n                    if (startMarker && endMarker) {\r\n                        if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\r\n                            return;\r\n                        }\r\n                        var range = doc.createRange();\r\n                        range.setStart(startMarker.node, startMarker.offset);\r\n                        selection.removeAllRanges();\r\n                        if (start > end) {\r\n                            selection.addRange(range);\r\n                            selection.extend(endMarker.node, endMarker.offset);\r\n                        }\r\n                        else {\r\n                            range.setEnd(endMarker.node, endMarker.offset);\r\n                            selection.addRange(range);\r\n                        }\r\n                    }\r\n                }\r\n                function isTextNode(node) {\r\n                    return node && node.nodeType === TEXT_NODE;\r\n                }\r\n                function containsNode(outerNode, innerNode) {\r\n                    if (!outerNode || !innerNode) {\r\n                        return false;\r\n                    }\r\n                    else if (outerNode === innerNode) {\r\n                        return true;\r\n                    }\r\n                    else if (isTextNode(outerNode)) {\r\n                        return false;\r\n                    }\r\n                    else if (isTextNode(innerNode)) {\r\n                        return containsNode(outerNode, innerNode.parentNode);\r\n                    }\r\n                    else if (\"contains\" in outerNode) {\r\n                        return outerNode.contains(innerNode);\r\n                    }\r\n                    else if (outerNode.compareDocumentPosition) {\r\n                        return !!(outerNode.compareDocumentPosition(innerNode) & 16);\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n                function isInDocument(node) {\r\n                    return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\r\n                }\r\n                function isSameOriginFrame(iframe) {\r\n                    try {\r\n                        return typeof iframe.contentWindow.location.href === \"string\";\r\n                    }\r\n                    catch (err) {\r\n                        return false;\r\n                    }\r\n                }\r\n                function getActiveElementDeep() {\r\n                    var win = window;\r\n                    var element = getActiveElement();\r\n                    while (element instanceof win.HTMLIFrameElement) {\r\n                        if (isSameOriginFrame(element)) {\r\n                            win = element.contentWindow;\r\n                        }\r\n                        else {\r\n                            return element;\r\n                        }\r\n                        element = getActiveElement(win.document);\r\n                    }\r\n                    return element;\r\n                }\r\n                function hasSelectionCapabilities(elem) {\r\n                    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\r\n                    return nodeName && (nodeName === \"input\" && (elem.type === \"text\" || elem.type === \"search\" || elem.type === \"tel\" || elem.type === \"url\" || elem.type === \"password\") || nodeName === \"textarea\" || elem.contentEditable === \"true\");\r\n                }\r\n                function getSelectionInformation() {\r\n                    var focusedElem = getActiveElementDeep();\r\n                    return {\r\n                        focusedElem: focusedElem,\r\n                        selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null\r\n                    };\r\n                }\r\n                function restoreSelection(priorSelectionInformation) {\r\n                    var curFocusedElem = getActiveElementDeep();\r\n                    var priorFocusedElem = priorSelectionInformation.focusedElem;\r\n                    var priorSelectionRange = priorSelectionInformation.selectionRange;\r\n                    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\r\n                        if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\r\n                            setSelection(priorFocusedElem, priorSelectionRange);\r\n                        }\r\n                        var ancestors = [];\r\n                        var ancestor = priorFocusedElem;\r\n                        while (ancestor = ancestor.parentNode) {\r\n                            if (ancestor.nodeType === ELEMENT_NODE) {\r\n                                ancestors.push({\r\n                                    element: ancestor,\r\n                                    left: ancestor.scrollLeft,\r\n                                    top: ancestor.scrollTop\r\n                                });\r\n                            }\r\n                        }\r\n                        if (typeof priorFocusedElem.focus === \"function\") {\r\n                            priorFocusedElem.focus();\r\n                        }\r\n                        for (var i2 = 0; i2 < ancestors.length; i2++) {\r\n                            var info = ancestors[i2];\r\n                            info.element.scrollLeft = info.left;\r\n                            info.element.scrollTop = info.top;\r\n                        }\r\n                    }\r\n                }\r\n                function getSelection(input) {\r\n                    var selection;\r\n                    if (\"selectionStart\" in input) {\r\n                        selection = {\r\n                            start: input.selectionStart,\r\n                            end: input.selectionEnd\r\n                        };\r\n                    }\r\n                    else {\r\n                        selection = getOffsets(input);\r\n                    }\r\n                    return selection || {\r\n                        start: 0,\r\n                        end: 0\r\n                    };\r\n                }\r\n                function setSelection(input, offsets) {\r\n                    var start = offsets.start;\r\n                    var end = offsets.end;\r\n                    if (end === void 0) {\r\n                        end = start;\r\n                    }\r\n                    if (\"selectionStart\" in input) {\r\n                        input.selectionStart = start;\r\n                        input.selectionEnd = Math.min(end, input.value.length);\r\n                    }\r\n                    else {\r\n                        setOffsets(input, offsets);\r\n                    }\r\n                }\r\n                var skipSelectionChangeEvent = canUseDOM2 && \"documentMode\" in document && document.documentMode <= 11;\r\n                function registerEvents$3() {\r\n                    registerTwoPhaseEvent(\"onSelect\", [\"focusout\", \"contextmenu\", \"dragend\", \"focusin\", \"keydown\", \"keyup\", \"mousedown\", \"mouseup\", \"selectionchange\"]);\r\n                }\r\n                var activeElement$1 = null;\r\n                var activeElementInst$1 = null;\r\n                var lastSelection = null;\r\n                var mouseDown = false;\r\n                function getSelection$1(node) {\r\n                    if (\"selectionStart\" in node && hasSelectionCapabilities(node)) {\r\n                        return {\r\n                            start: node.selectionStart,\r\n                            end: node.selectionEnd\r\n                        };\r\n                    }\r\n                    else {\r\n                        var win = node.ownerDocument && node.ownerDocument.defaultView || window;\r\n                        var selection = win.getSelection();\r\n                        return {\r\n                            anchorNode: selection.anchorNode,\r\n                            anchorOffset: selection.anchorOffset,\r\n                            focusNode: selection.focusNode,\r\n                            focusOffset: selection.focusOffset\r\n                        };\r\n                    }\r\n                }\r\n                function getEventTargetDocument(eventTarget) {\r\n                    return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\r\n                }\r\n                function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\r\n                    var doc = getEventTargetDocument(nativeEventTarget);\r\n                    if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\r\n                        return;\r\n                    }\r\n                    var currentSelection = getSelection$1(activeElement$1);\r\n                    if (!lastSelection || !shallowEqual2(lastSelection, currentSelection)) {\r\n                        lastSelection = currentSelection;\r\n                        var listeners = accumulateTwoPhaseListeners(activeElementInst$1, \"onSelect\");\r\n                        if (listeners.length > 0) {\r\n                            var event = new SyntheticEvent(\"onSelect\", \"select\", null, nativeEvent, nativeEventTarget);\r\n                            dispatchQueue.push({\r\n                                event: event,\r\n                                listeners: listeners\r\n                            });\r\n                            event.target = activeElement$1;\r\n                        }\r\n                    }\r\n                }\r\n                function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n                    var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\r\n                    switch (domEventName) {\r\n                        case \"focusin\":\r\n                            if (isTextInputElement(targetNode) || targetNode.contentEditable === \"true\") {\r\n                                activeElement$1 = targetNode;\r\n                                activeElementInst$1 = targetInst;\r\n                                lastSelection = null;\r\n                            }\r\n                            break;\r\n                        case \"focusout\":\r\n                            activeElement$1 = null;\r\n                            activeElementInst$1 = null;\r\n                            lastSelection = null;\r\n                            break;\r\n                        case \"mousedown\":\r\n                            mouseDown = true;\r\n                            break;\r\n                        case \"contextmenu\":\r\n                        case \"mouseup\":\r\n                        case \"dragend\":\r\n                            mouseDown = false;\r\n                            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\r\n                            break;\r\n                        case \"selectionchange\":\r\n                            if (skipSelectionChangeEvent) {\r\n                                break;\r\n                            }\r\n                        case \"keydown\":\r\n                        case \"keyup\":\r\n                            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\r\n                    }\r\n                }\r\n                function makePrefixMap(styleProp, eventName) {\r\n                    var prefixes2 = {};\r\n                    prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();\r\n                    prefixes2[\"Webkit\" + styleProp] = \"webkit\" + eventName;\r\n                    prefixes2[\"Moz\" + styleProp] = \"moz\" + eventName;\r\n                    return prefixes2;\r\n                }\r\n                var vendorPrefixes = {\r\n                    animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\r\n                    animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\r\n                    animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\r\n                    transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\r\n                };\r\n                var prefixedEventNames = {};\r\n                var style = {};\r\n                if (canUseDOM2) {\r\n                    style = document.createElement(\"div\").style;\r\n                    if (!(\"AnimationEvent\" in window)) {\r\n                        delete vendorPrefixes.animationend.animation;\r\n                        delete vendorPrefixes.animationiteration.animation;\r\n                        delete vendorPrefixes.animationstart.animation;\r\n                    }\r\n                    if (!(\"TransitionEvent\" in window)) {\r\n                        delete vendorPrefixes.transitionend.transition;\r\n                    }\r\n                }\r\n                function getVendorPrefixedEventName(eventName) {\r\n                    if (prefixedEventNames[eventName]) {\r\n                        return prefixedEventNames[eventName];\r\n                    }\r\n                    else if (!vendorPrefixes[eventName]) {\r\n                        return eventName;\r\n                    }\r\n                    var prefixMap = vendorPrefixes[eventName];\r\n                    for (var styleProp in prefixMap) {\r\n                        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\r\n                            return prefixedEventNames[eventName] = prefixMap[styleProp];\r\n                        }\r\n                    }\r\n                    return eventName;\r\n                }\r\n                var ANIMATION_END = getVendorPrefixedEventName(\"animationend\");\r\n                var ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\");\r\n                var ANIMATION_START = getVendorPrefixedEventName(\"animationstart\");\r\n                var TRANSITION_END = getVendorPrefixedEventName(\"transitionend\");\r\n                var topLevelEventsToReactNames = new Map();\r\n                var simpleEventPluginEvents = [\"abort\", \"auxClick\", \"cancel\", \"canPlay\", \"canPlayThrough\", \"click\", \"close\", \"contextMenu\", \"copy\", \"cut\", \"drag\", \"dragEnd\", \"dragEnter\", \"dragExit\", \"dragLeave\", \"dragOver\", \"dragStart\", \"drop\", \"durationChange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"gotPointerCapture\", \"input\", \"invalid\", \"keyDown\", \"keyPress\", \"keyUp\", \"load\", \"loadedData\", \"loadedMetadata\", \"loadStart\", \"lostPointerCapture\", \"mouseDown\", \"mouseMove\", \"mouseOut\", \"mouseOver\", \"mouseUp\", \"paste\", \"pause\", \"play\", \"playing\", \"pointerCancel\", \"pointerDown\", \"pointerMove\", \"pointerOut\", \"pointerOver\", \"pointerUp\", \"progress\", \"rateChange\", \"reset\", \"resize\", \"seeked\", \"seeking\", \"stalled\", \"submit\", \"suspend\", \"timeUpdate\", \"touchCancel\", \"touchEnd\", \"touchStart\", \"volumeChange\", \"scroll\", \"toggle\", \"touchMove\", \"waiting\", \"wheel\"];\r\n                function registerSimpleEvent(domEventName, reactName) {\r\n                    topLevelEventsToReactNames.set(domEventName, reactName);\r\n                    registerTwoPhaseEvent(reactName, [domEventName]);\r\n                }\r\n                function registerSimpleEvents() {\r\n                    for (var i2 = 0; i2 < simpleEventPluginEvents.length; i2++) {\r\n                        var eventName = simpleEventPluginEvents[i2];\r\n                        var domEventName = eventName.toLowerCase();\r\n                        var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);\r\n                        registerSimpleEvent(domEventName, \"on\" + capitalizedEvent);\r\n                    }\r\n                    registerSimpleEvent(ANIMATION_END, \"onAnimationEnd\");\r\n                    registerSimpleEvent(ANIMATION_ITERATION, \"onAnimationIteration\");\r\n                    registerSimpleEvent(ANIMATION_START, \"onAnimationStart\");\r\n                    registerSimpleEvent(\"dblclick\", \"onDoubleClick\");\r\n                    registerSimpleEvent(\"focusin\", \"onFocus\");\r\n                    registerSimpleEvent(\"focusout\", \"onBlur\");\r\n                    registerSimpleEvent(TRANSITION_END, \"onTransitionEnd\");\r\n                }\r\n                function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n                    var reactName = topLevelEventsToReactNames.get(domEventName);\r\n                    if (reactName === void 0) {\r\n                        return;\r\n                    }\r\n                    var SyntheticEventCtor = SyntheticEvent;\r\n                    var reactEventType = domEventName;\r\n                    switch (domEventName) {\r\n                        case \"keypress\":\r\n                            if (getEventCharCode(nativeEvent) === 0) {\r\n                                return;\r\n                            }\r\n                        case \"keydown\":\r\n                        case \"keyup\":\r\n                            SyntheticEventCtor = SyntheticKeyboardEvent;\r\n                            break;\r\n                        case \"focusin\":\r\n                            reactEventType = \"focus\";\r\n                            SyntheticEventCtor = SyntheticFocusEvent;\r\n                            break;\r\n                        case \"focusout\":\r\n                            reactEventType = \"blur\";\r\n                            SyntheticEventCtor = SyntheticFocusEvent;\r\n                            break;\r\n                        case \"beforeblur\":\r\n                        case \"afterblur\":\r\n                            SyntheticEventCtor = SyntheticFocusEvent;\r\n                            break;\r\n                        case \"click\":\r\n                            if (nativeEvent.button === 2) {\r\n                                return;\r\n                            }\r\n                        case \"auxclick\":\r\n                        case \"dblclick\":\r\n                        case \"mousedown\":\r\n                        case \"mousemove\":\r\n                        case \"mouseup\":\r\n                        case \"mouseout\":\r\n                        case \"mouseover\":\r\n                        case \"contextmenu\":\r\n                            SyntheticEventCtor = SyntheticMouseEvent;\r\n                            break;\r\n                        case \"drag\":\r\n                        case \"dragend\":\r\n                        case \"dragenter\":\r\n                        case \"dragexit\":\r\n                        case \"dragleave\":\r\n                        case \"dragover\":\r\n                        case \"dragstart\":\r\n                        case \"drop\":\r\n                            SyntheticEventCtor = SyntheticDragEvent;\r\n                            break;\r\n                        case \"touchcancel\":\r\n                        case \"touchend\":\r\n                        case \"touchmove\":\r\n                        case \"touchstart\":\r\n                            SyntheticEventCtor = SyntheticTouchEvent;\r\n                            break;\r\n                        case ANIMATION_END:\r\n                        case ANIMATION_ITERATION:\r\n                        case ANIMATION_START:\r\n                            SyntheticEventCtor = SyntheticAnimationEvent;\r\n                            break;\r\n                        case TRANSITION_END:\r\n                            SyntheticEventCtor = SyntheticTransitionEvent;\r\n                            break;\r\n                        case \"scroll\":\r\n                            SyntheticEventCtor = SyntheticUIEvent;\r\n                            break;\r\n                        case \"wheel\":\r\n                            SyntheticEventCtor = SyntheticWheelEvent;\r\n                            break;\r\n                        case \"copy\":\r\n                        case \"cut\":\r\n                        case \"paste\":\r\n                            SyntheticEventCtor = SyntheticClipboardEvent;\r\n                            break;\r\n                        case \"gotpointercapture\":\r\n                        case \"lostpointercapture\":\r\n                        case \"pointercancel\":\r\n                        case \"pointerdown\":\r\n                        case \"pointermove\":\r\n                        case \"pointerout\":\r\n                        case \"pointerover\":\r\n                        case \"pointerup\":\r\n                            SyntheticEventCtor = SyntheticPointerEvent;\r\n                            break;\r\n                    }\r\n                    var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n                    {\r\n                        var accumulateTargetOnly = !inCapturePhase && domEventName === \"scroll\";\r\n                        var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);\r\n                        if (_listeners.length > 0) {\r\n                            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);\r\n                            dispatchQueue.push({\r\n                                event: _event,\r\n                                listeners: _listeners\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                registerSimpleEvents();\r\n                registerEvents$2();\r\n                registerEvents$1();\r\n                registerEvents$3();\r\n                registerEvents();\r\n                function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\r\n                    extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\r\n                    var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;\r\n                    if (shouldProcessPolyfillPlugins) {\r\n                        extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n                        extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n                        extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n                        extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\r\n                    }\r\n                }\r\n                var mediaEventTypes = [\"abort\", \"canplay\", \"canplaythrough\", \"durationchange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"loadeddata\", \"loadedmetadata\", \"loadstart\", \"pause\", \"play\", \"playing\", \"progress\", \"ratechange\", \"resize\", \"seeked\", \"seeking\", \"stalled\", \"suspend\", \"timeupdate\", \"volumechange\", \"waiting\"];\r\n                var nonDelegatedEvents = new Set([\"cancel\", \"close\", \"invalid\", \"load\", \"scroll\", \"toggle\"].concat(mediaEventTypes));\r\n                function executeDispatch(event, listener, currentTarget) {\r\n                    var type = event.type || \"unknown-event\";\r\n                    event.currentTarget = currentTarget;\r\n                    invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);\r\n                    event.currentTarget = null;\r\n                }\r\n                function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {\r\n                    var previousInstance;\r\n                    if (inCapturePhase) {\r\n                        for (var i2 = dispatchListeners.length - 1; i2 >= 0; i2--) {\r\n                            var _dispatchListeners$i = dispatchListeners[i2], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;\r\n                            if (instance !== previousInstance && event.isPropagationStopped()) {\r\n                                return;\r\n                            }\r\n                            executeDispatch(event, listener, currentTarget);\r\n                            previousInstance = instance;\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (var _i = 0; _i < dispatchListeners.length; _i++) {\r\n                            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;\r\n                            if (_instance !== previousInstance && event.isPropagationStopped()) {\r\n                                return;\r\n                            }\r\n                            executeDispatch(event, _listener, _currentTarget);\r\n                            previousInstance = _instance;\r\n                        }\r\n                    }\r\n                }\r\n                function processDispatchQueue(dispatchQueue, eventSystemFlags) {\r\n                    var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\r\n                    for (var i2 = 0; i2 < dispatchQueue.length; i2++) {\r\n                        var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;\r\n                        processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\r\n                    }\r\n                    rethrowCaughtError();\r\n                }\r\n                function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\r\n                    var nativeEventTarget = getEventTarget(nativeEvent);\r\n                    var dispatchQueue = [];\r\n                    extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\r\n                    processDispatchQueue(dispatchQueue, eventSystemFlags);\r\n                }\r\n                function listenToNonDelegatedEvent(domEventName, targetElement) {\r\n                    {\r\n                        if (!nonDelegatedEvents.has(domEventName)) {\r\n                            error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". This is a bug in React. Please file an issue.', domEventName);\r\n                        }\r\n                    }\r\n                    var isCapturePhaseListener = false;\r\n                    var listenerSet = getEventListenerSet(targetElement);\r\n                    var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\r\n                    if (!listenerSet.has(listenerSetKey)) {\r\n                        addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);\r\n                        listenerSet.add(listenerSetKey);\r\n                    }\r\n                }\r\n                function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\r\n                    {\r\n                        if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {\r\n                            error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);\r\n                        }\r\n                    }\r\n                    var eventSystemFlags = 0;\r\n                    if (isCapturePhaseListener) {\r\n                        eventSystemFlags |= IS_CAPTURE_PHASE;\r\n                    }\r\n                    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\r\n                }\r\n                var listeningMarker = \"_reactListening\" + Math.random().toString(36).slice(2);\r\n                function listenToAllSupportedEvents(rootContainerElement) {\r\n                    if (!rootContainerElement[listeningMarker]) {\r\n                        rootContainerElement[listeningMarker] = true;\r\n                        allNativeEvents.forEach(function (domEventName) {\r\n                            if (domEventName !== \"selectionchange\") {\r\n                                if (!nonDelegatedEvents.has(domEventName)) {\r\n                                    listenToNativeEvent(domEventName, false, rootContainerElement);\r\n                                }\r\n                                listenToNativeEvent(domEventName, true, rootContainerElement);\r\n                            }\r\n                        });\r\n                        var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\r\n                        if (ownerDocument !== null) {\r\n                            if (!ownerDocument[listeningMarker]) {\r\n                                ownerDocument[listeningMarker] = true;\r\n                                listenToNativeEvent(\"selectionchange\", false, ownerDocument);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {\r\n                    var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);\r\n                    var isPassiveListener = void 0;\r\n                    if (passiveBrowserEventsSupported) {\r\n                        if (domEventName === \"touchstart\" || domEventName === \"touchmove\" || domEventName === \"wheel\") {\r\n                            isPassiveListener = true;\r\n                        }\r\n                    }\r\n                    targetContainer = targetContainer;\r\n                    var unsubscribeListener;\r\n                    if (isCapturePhaseListener) {\r\n                        if (isPassiveListener !== void 0) {\r\n                            unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\r\n                        }\r\n                        else {\r\n                            unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (isPassiveListener !== void 0) {\r\n                            unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\r\n                        }\r\n                        else {\r\n                            unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);\r\n                        }\r\n                    }\r\n                }\r\n                function isMatchingRootContainer(grandContainer, targetContainer) {\r\n                    return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;\r\n                }\r\n                function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\r\n                    var ancestorInst = targetInst;\r\n                    if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {\r\n                        var targetContainerNode = targetContainer;\r\n                        if (targetInst !== null) {\r\n                            var node = targetInst;\r\n                            mainLoop: while (true) {\r\n                                if (node === null) {\r\n                                    return;\r\n                                }\r\n                                var nodeTag = node.tag;\r\n                                if (nodeTag === HostRoot || nodeTag === HostPortal) {\r\n                                    var container = node.stateNode.containerInfo;\r\n                                    if (isMatchingRootContainer(container, targetContainerNode)) {\r\n                                        break;\r\n                                    }\r\n                                    if (nodeTag === HostPortal) {\r\n                                        var grandNode = node.return;\r\n                                        while (grandNode !== null) {\r\n                                            var grandTag = grandNode.tag;\r\n                                            if (grandTag === HostRoot || grandTag === HostPortal) {\r\n                                                var grandContainer = grandNode.stateNode.containerInfo;\r\n                                                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {\r\n                                                    return;\r\n                                                }\r\n                                            }\r\n                                            grandNode = grandNode.return;\r\n                                        }\r\n                                    }\r\n                                    while (container !== null) {\r\n                                        var parentNode = getClosestInstanceFromNode(container);\r\n                                        if (parentNode === null) {\r\n                                            return;\r\n                                        }\r\n                                        var parentTag = parentNode.tag;\r\n                                        if (parentTag === HostComponent || parentTag === HostText) {\r\n                                            node = ancestorInst = parentNode;\r\n                                            continue mainLoop;\r\n                                        }\r\n                                        container = container.parentNode;\r\n                                    }\r\n                                }\r\n                                node = node.return;\r\n                            }\r\n                        }\r\n                    }\r\n                    batchedUpdates(function () {\r\n                        return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);\r\n                    });\r\n                }\r\n                function createDispatchListener(instance, listener, currentTarget) {\r\n                    return {\r\n                        instance: instance,\r\n                        listener: listener,\r\n                        currentTarget: currentTarget\r\n                    };\r\n                }\r\n                function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {\r\n                    var captureName = reactName !== null ? reactName + \"Capture\" : null;\r\n                    var reactEventName = inCapturePhase ? captureName : reactName;\r\n                    var listeners = [];\r\n                    var instance = targetFiber;\r\n                    var lastHostComponent = null;\r\n                    while (instance !== null) {\r\n                        var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;\r\n                        if (tag === HostComponent && stateNode !== null) {\r\n                            lastHostComponent = stateNode;\r\n                            if (reactEventName !== null) {\r\n                                var listener = getListener(instance, reactEventName);\r\n                                if (listener != null) {\r\n                                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));\r\n                                }\r\n                            }\r\n                        }\r\n                        if (accumulateTargetOnly) {\r\n                            break;\r\n                        }\r\n                        instance = instance.return;\r\n                    }\r\n                    return listeners;\r\n                }\r\n                function accumulateTwoPhaseListeners(targetFiber, reactName) {\r\n                    var captureName = reactName + \"Capture\";\r\n                    var listeners = [];\r\n                    var instance = targetFiber;\r\n                    while (instance !== null) {\r\n                        var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;\r\n                        if (tag === HostComponent && stateNode !== null) {\r\n                            var currentTarget = stateNode;\r\n                            var captureListener = getListener(instance, captureName);\r\n                            if (captureListener != null) {\r\n                                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\r\n                            }\r\n                            var bubbleListener = getListener(instance, reactName);\r\n                            if (bubbleListener != null) {\r\n                                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\r\n                            }\r\n                        }\r\n                        instance = instance.return;\r\n                    }\r\n                    return listeners;\r\n                }\r\n                function getParent(inst) {\r\n                    if (inst === null) {\r\n                        return null;\r\n                    }\r\n                    do {\r\n                        inst = inst.return;\r\n                    } while (inst && inst.tag !== HostComponent);\r\n                    if (inst) {\r\n                        return inst;\r\n                    }\r\n                    return null;\r\n                }\r\n                function getLowestCommonAncestor(instA, instB) {\r\n                    var nodeA = instA;\r\n                    var nodeB = instB;\r\n                    var depthA = 0;\r\n                    for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {\r\n                        depthA++;\r\n                    }\r\n                    var depthB = 0;\r\n                    for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {\r\n                        depthB++;\r\n                    }\r\n                    while (depthA - depthB > 0) {\r\n                        nodeA = getParent(nodeA);\r\n                        depthA--;\r\n                    }\r\n                    while (depthB - depthA > 0) {\r\n                        nodeB = getParent(nodeB);\r\n                        depthB--;\r\n                    }\r\n                    var depth = depthA;\r\n                    while (depth--) {\r\n                        if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {\r\n                            return nodeA;\r\n                        }\r\n                        nodeA = getParent(nodeA);\r\n                        nodeB = getParent(nodeB);\r\n                    }\r\n                    return null;\r\n                }\r\n                function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {\r\n                    var registrationName = event._reactName;\r\n                    var listeners = [];\r\n                    var instance = target;\r\n                    while (instance !== null) {\r\n                        if (instance === common) {\r\n                            break;\r\n                        }\r\n                        var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;\r\n                        if (alternate !== null && alternate === common) {\r\n                            break;\r\n                        }\r\n                        if (tag === HostComponent && stateNode !== null) {\r\n                            var currentTarget = stateNode;\r\n                            if (inCapturePhase) {\r\n                                var captureListener = getListener(instance, registrationName);\r\n                                if (captureListener != null) {\r\n                                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\r\n                                }\r\n                            }\r\n                            else if (!inCapturePhase) {\r\n                                var bubbleListener = getListener(instance, registrationName);\r\n                                if (bubbleListener != null) {\r\n                                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\r\n                                }\r\n                            }\r\n                        }\r\n                        instance = instance.return;\r\n                    }\r\n                    if (listeners.length !== 0) {\r\n                        dispatchQueue.push({\r\n                            event: event,\r\n                            listeners: listeners\r\n                        });\r\n                    }\r\n                }\r\n                function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {\r\n                    var common = from && to ? getLowestCommonAncestor(from, to) : null;\r\n                    if (from !== null) {\r\n                        accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);\r\n                    }\r\n                    if (to !== null && enterEvent !== null) {\r\n                        accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);\r\n                    }\r\n                }\r\n                function getListenerSetKey(domEventName, capture) {\r\n                    return domEventName + \"__\" + (capture ? \"capture\" : \"bubble\");\r\n                }\r\n                var didWarnInvalidHydration = false;\r\n                var DANGEROUSLY_SET_INNER_HTML = \"dangerouslySetInnerHTML\";\r\n                var SUPPRESS_CONTENT_EDITABLE_WARNING = \"suppressContentEditableWarning\";\r\n                var SUPPRESS_HYDRATION_WARNING = \"suppressHydrationWarning\";\r\n                var AUTOFOCUS = \"autoFocus\";\r\n                var CHILDREN = \"children\";\r\n                var STYLE = \"style\";\r\n                var HTML$1 = \"__html\";\r\n                var warnedUnknownTags;\r\n                var validatePropertiesInDevelopment;\r\n                var warnForPropDifference;\r\n                var warnForExtraAttributes;\r\n                var warnForInvalidEventListener;\r\n                var canDiffStyleForHydrationWarning;\r\n                var normalizeHTML;\r\n                {\r\n                    warnedUnknownTags = {\r\n                        dialog: true,\r\n                        webview: true\r\n                    };\r\n                    validatePropertiesInDevelopment = function (type, props) {\r\n                        validateProperties(type, props);\r\n                        validateProperties$1(type, props);\r\n                        validateProperties$2(type, props, {\r\n                            registrationNameDependencies: registrationNameDependencies,\r\n                            possibleRegistrationNames: possibleRegistrationNames\r\n                        });\r\n                    };\r\n                    canDiffStyleForHydrationWarning = canUseDOM2 && !document.documentMode;\r\n                    warnForPropDifference = function (propName, serverValue, clientValue) {\r\n                        if (didWarnInvalidHydration) {\r\n                            return;\r\n                        }\r\n                        var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\r\n                        var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\r\n                        if (normalizedServerValue === normalizedClientValue) {\r\n                            return;\r\n                        }\r\n                        didWarnInvalidHydration = true;\r\n                        error(\"Prop `%s` did not match. Server: %s Client: %s\", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\r\n                    };\r\n                    warnForExtraAttributes = function (attributeNames) {\r\n                        if (didWarnInvalidHydration) {\r\n                            return;\r\n                        }\r\n                        didWarnInvalidHydration = true;\r\n                        var names = [];\r\n                        attributeNames.forEach(function (name) {\r\n                            names.push(name);\r\n                        });\r\n                        error(\"Extra attributes from the server: %s\", names);\r\n                    };\r\n                    warnForInvalidEventListener = function (registrationName, listener) {\r\n                        if (listener === false) {\r\n                            error(\"Expected `%s` listener to be a function, instead got `false`.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.\", registrationName, registrationName, registrationName);\r\n                        }\r\n                        else {\r\n                            error(\"Expected `%s` listener to be a function, instead got a value of `%s` type.\", registrationName, typeof listener);\r\n                        }\r\n                    };\r\n                    normalizeHTML = function (parent, html) {\r\n                        var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\r\n                        testElement.innerHTML = html;\r\n                        return testElement.innerHTML;\r\n                    };\r\n                }\r\n                var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\r\n                var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\r\n                function normalizeMarkupForTextOrAttribute(markup) {\r\n                    {\r\n                        checkHtmlStringCoercion(markup);\r\n                    }\r\n                    var markupString = typeof markup === \"string\" ? markup : \"\" + markup;\r\n                    return markupString.replace(NORMALIZE_NEWLINES_REGEX, \"\\n\").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, \"\");\r\n                }\r\n                function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {\r\n                    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\r\n                    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\r\n                    if (normalizedServerText === normalizedClientText) {\r\n                        return;\r\n                    }\r\n                    if (shouldWarnDev) {\r\n                        {\r\n                            if (!didWarnInvalidHydration) {\r\n                                didWarnInvalidHydration = true;\r\n                                error('Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {\r\n                        throw new Error(\"Text content does not match server-rendered HTML.\");\r\n                    }\r\n                }\r\n                function getOwnerDocumentFromRootContainer(rootContainerElement) {\r\n                    return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\r\n                }\r\n                function noop() {\r\n                }\r\n                function trapClickOnNonInteractiveElement(node) {\r\n                    node.onclick = noop;\r\n                }\r\n                function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\r\n                    for (var propKey in nextProps) {\r\n                        if (!nextProps.hasOwnProperty(propKey)) {\r\n                            continue;\r\n                        }\r\n                        var nextProp = nextProps[propKey];\r\n                        if (propKey === STYLE) {\r\n                            {\r\n                                if (nextProp) {\r\n                                    Object.freeze(nextProp);\r\n                                }\r\n                            }\r\n                            setValueForStyles(domElement, nextProp);\r\n                        }\r\n                        else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\r\n                            var nextHtml = nextProp ? nextProp[HTML$1] : void 0;\r\n                            if (nextHtml != null) {\r\n                                setInnerHTML(domElement, nextHtml);\r\n                            }\r\n                        }\r\n                        else if (propKey === CHILDREN) {\r\n                            if (typeof nextProp === \"string\") {\r\n                                var canSetTextContent = tag !== \"textarea\" || nextProp !== \"\";\r\n                                if (canSetTextContent) {\r\n                                    setTextContent(domElement, nextProp);\r\n                                }\r\n                            }\r\n                            else if (typeof nextProp === \"number\") {\r\n                                setTextContent(domElement, \"\" + nextProp);\r\n                            }\r\n                        }\r\n                        else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\r\n                            ;\r\n                        else if (propKey === AUTOFOCUS)\r\n                            ;\r\n                        else if (registrationNameDependencies.hasOwnProperty(propKey)) {\r\n                            if (nextProp != null) {\r\n                                if (typeof nextProp !== \"function\") {\r\n                                    warnForInvalidEventListener(propKey, nextProp);\r\n                                }\r\n                                if (propKey === \"onScroll\") {\r\n                                    listenTo